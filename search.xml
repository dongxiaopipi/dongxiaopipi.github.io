<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql主从复制</title>
      <link href="/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql主从复制"><a href="#Mysql主从复制" class="headerlink" title="Mysql主从复制"></a>Mysql主从复制</h1><h2 id="一-搭建mysql"><a href="#一-搭建mysql" class="headerlink" title="一.搭建mysql"></a>一.搭建mysql</h2><p>1、下载<code>MySQL</code>的安装包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz</span></span><br></pre></td></tr></table></figure><p>2、解压<code>MySQL</code>的压缩包，并对解压后的目录重命名</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">tar -xvJf mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash"><span class="built_in">mv</span> mysql-8.0.20-linux-glibc2.12-x86_64 mysql8.0</span></span><br></pre></td></tr></table></figure><p>3、卸载Linux自带的MariaDB</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">rpm -qa | grep mariadb</span></span><br><span class="line">mariadb-libs-5.5.68-1.el7.x86_64</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、创建一个<code>data</code>文件夹，用于存放数据</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash"><span class="built_in">cd</span> mysql8.0 &amp;&amp; <span class="built_in">mkdir</span> data</span></span><br></pre></td></tr></table></figure><p>root@localhost: PsdkKQK!I6;8</p><p>5、配置环境变量</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">vi /etc/profile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在最后面加一行：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  <span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/soft/mysql/mysql8.0/bin:/soft/mysql/mysql8.0/lib</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按ESC键，输入 :wq 保存退出</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash"><span class="built_in">source</span> /etc/profile</span></span><br></pre></td></tr></table></figure><p>6、创建一个MySql用户组</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">groupadd mysql</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">useradd -g mysql mysql</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash"><span class="built_in">chown</span> -R mysql.mysql /soft/mysql/mysql8.0</span></span><br></pre></td></tr></table></figure><p>7、初始化mysql信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash"><span class="built_in">cd</span> /soft/mysql/mysql8.0/bin</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">./mysqld --user=mysql --basedir=/soft/mysql/mysql8.0 --datadir=/soft/mysql/mysql8.0/data/ --initialize</span></span><br></pre></td></tr></table></figure><img src="image-20231130095207087.png" alt="image-20231130095207087" style="zoom:67%;"><p>临时密码已创建</p><p>8、配置一下mysql配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">vi /etc/my.cnf</span></span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/soft/mysql/mysql8.0</span><br><span class="line">datadir=/soft/mysql/mysql8.0/data</span><br><span class="line"></span><br><span class="line">port=3306</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">character-set-server=UTF8MB4</span><br></pre></td></tr></table></figure><p>9、配置mysql目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash"><span class="built_in">cd</span> /soft/mysql/mysql8.0</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">vi support-files/mysql.server</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其中安装目录和数据目录默认为空，启动时会去加载/usr/local/mysql/目录</span></span><br><span class="line">basedir=</span><br><span class="line">datadir=</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记得将其修改为你自定义的安装目录和数据目录（最后不要加斜杠）</span></span><br><span class="line">basedir=/soft/mysql/mysql8.0</span><br><span class="line">datadir=/soft/mysql/mysql8.0/data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>10、启动mysql</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">./support-files/mysql.server start</span></span><br><span class="line">Starting MySQL.Logging to &#x27;/soft/mysql/mysql8.0/data/localhost.localdomain.err&#x27;.</span><br><span class="line">.. SUCCESS!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、一主一从搭建"><a href="#二、一主一从搭建" class="headerlink" title="二、一主一从搭建"></a>二、一主一从搭建</h2><h3 id="1-配置mysql主节点（master）"><a href="#1-配置mysql主节点（master）" class="headerlink" title="1.配置mysql主节点（master）"></a>1.配置mysql主节点（master）</h3><p>1、修改配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">service mysql stop</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">vi /etc/my.cnf</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/soft/mysql/mysql8.0</span><br><span class="line">datadir=/soft/mysql/mysql8.0/data</span><br><span class="line"></span><br><span class="line">port=3306</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">character-set-server=UTF8MB4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">------接下来的是主从集群配置-------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主库在主从集群中的唯一标识</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启bin-log日志，并为bin-log日志取个前缀名（有默认值可不写）</span></span><br><span class="line">log-bin=mysql-bin-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步复制时过滤的库（主要将一些不需要备份/同步库写进来）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以通过binlog-do-db=xx1,xx2... 来指定要复制的目标库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定bin-log日志的格式为混合模式（默认为statement）</span></span><br><span class="line">binlog_format=mixed</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置单个binlog日志文件的最大容量</span></span><br><span class="line">max_binlog_size=1024M</span><br></pre></td></tr></table></figure><p>2、开放主节点端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">firewall-cmd --reload</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">firewall-cmd --zone=public --list-ports</span></span><br></pre></td></tr></table></figure><p>3、创建用于数据同步的账号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">service mysql start</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">mysql -uroot -p</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create user <span class="string">&#x27;dongnan&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="string">&#x27;12345678&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">grant replication slave on *.* to <span class="string">&#x27;dongnan&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-配置mysql从节点（slave）"><a href="#2-配置mysql从节点（slave）" class="headerlink" title="2.配置mysql从节点（slave）"></a>2.配置mysql从节点（slave）</h3><p>1、修改配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">service mysql stop</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">vi /etc/my.cnf</span></span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/soft/mysql/mysql8.0</span><br><span class="line">datadir=/soft/mysql/mysql8.0/data</span><br><span class="line"></span><br><span class="line">port=3306</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">character-set-server=UTF8MB4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">------接下来的是主从配置-------</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从库在主从集群中的唯一标识</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启bin-log日志（为了主从切换时使用，不开启bin-log的从机只能当备库使用）</span></span><br><span class="line">log-bin=mysql-bin-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步复制时要过滤的库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定bin-log日志的格式为混合模式</span></span><br><span class="line">binlog_format=mixed</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置单个binlog日志文件的最大容量</span></span><br><span class="line">max_binlog_size=1024M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启relay-log日志（同样可以指定前缀名）</span></span><br><span class="line">relay_log=mysql-relay-log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启存储过程、函数、触发器等内容的同步功能</span></span><br><span class="line">log_bin_trust_function_creators=true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步执行跳过一些错误码（防止同步写入时出现错误导致复制中断）</span></span><br><span class="line">slave_skip_errors=1062</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、开放从节点端口</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">firewall-cmd --reload</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">firewall-cmd --zone=public --list-ports</span></span><br></pre></td></tr></table></figure><p>3、创建用于数据同步的账号</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">service mysql start</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">mysql -uroot -p</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">change master to master_host=<span class="string">&#x27;10.211.55.7&#x27;</span>,</span></span><br><span class="line">       master_user=&#x27;dongnan&#x27;,</span><br><span class="line">       master_password=&#x27;12345678&#x27;,</span><br><span class="line">       master_port=3306,</span><br><span class="line">       master_log_file=&#x27;mysql-bin-log.000001&#x27;,</span><br><span class="line">       master_log_pos=658;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、启动从库线程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">start slave;</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show slave status\G;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Slave_IO_Running、Slave_SQL_Running</code>两个线程的状态都为<code>Yes</code>时，说明主从集群搭建完成。</p><h2 id="三、GTID复制、无损复制"><a href="#三、GTID复制、无损复制" class="headerlink" title="三、GTID复制、无损复制"></a>三、GTID复制、无损复制</h2><h3 id="1、GTID复制"><a href="#1、GTID复制" class="headerlink" title="1、GTID复制"></a>1、GTID复制</h3><blockquote><p>在前面配置从节点时，需要咱们手动指定<code>master_log_pos=653</code>同步点，而开启<code>GTID</code>复制后则可根治该问题</p></blockquote><p>需要先停止从库的同步线程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">stop slave;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主节点退出连接，停止mysql服务</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">quit</span></span><br><span class="line"><span class="meta prompt_">[root@localhost]# </span><span class="language-bash">service mysql stop</span></span><br></pre></td></tr></table></figure><p>更改两个节点的&#x2F;etc&#x2F;my.cnf配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启GTID复制</span></span><br><span class="line">gtid_mode=on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跳过一些可能导致执行出错的SQL语句</span></span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着重启两个节点，登陆从节点，与主库建立连接</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">change master to master_host=&#x27;10.211.55.7&#x27;, master_user=&#x27;dongnan&#x27;, master_password=&#x27;12345678&#x27;,        master_port=3306, master_auto_position=1;</span><br></pre></td></tr></table></figure><p>从库上启动slave线程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure><h3 id="2、无损复制"><a href="#2、无损复制" class="headerlink" title="2、无损复制"></a>2、无损复制</h3><p>安装插件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">主节点执行：INSTALL PLUGIN rpl_semi_sync_master SONAME &#x27;semisync_master.so&#x27;;</span><br><span class="line">从节点执行：INSTALL PLUGIN rpl_semi_sync_slave SONAME &#x27;semisync_slave.so&#x27;;</span><br></pre></td></tr></table></figure><p>停止同步线程、退出连接、关闭<code>MySQL</code>服务，接着再次修改主从的<code>/etc/my.cnf</code>配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">主节点上新增配置：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启无损复制</span></span><br><span class="line">rpl_semi_sync_master_enabled=on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待从节点ACK的时长（不指定默认为10s）</span></span><br><span class="line">rpl_semi_sync_master_timeout=3000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从节点上新增配置：</span></span><br><span class="line">rpl_semi_sync_slave_enabled=on</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/11/27/Docker/"/>
      <url>/2023/11/27/Docker/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h3><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、卸载旧版</span><br><span class="line">    sudo yum remove docker \</span><br><span class="line">                      docker-client \</span><br><span class="line">                      docker-client-latest \</span><br><span class="line">                      docker-common \</span><br><span class="line">                      docker-latest \</span><br><span class="line">                      docker-latest-logrotate \</span><br><span class="line">                      docker-logrotate \</span><br><span class="line">                      docker-engine </span><br><span class="line">                </span><br><span class="line">2、Install the yum-utils package (which provides the yum-config-manager utility) and set up the repository.</span><br><span class="line">    sudo yum install -y yum-utils</span><br><span class="line">    sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line">  </span><br><span class="line">3、Install Docker Engine</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"></span><br><span class="line">4、Start Docker.</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">5、删除包含某个字段的所有镜像</span><br><span class="line">docker rmi $(docker images | grep &quot;dongnan&quot; | awk &#x27;&#123;print $3&#125;&#x27;) </span><br><span class="line">6、停止包含某个字段的所有镜像</span><br><span class="line">docker stop $(docker ps -a | grep &quot;xxx&quot; | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">7、删除所有未运行的容器（已经运行的删除不了，未运行的就一起被删除了）</span><br><span class="line">sudo docker rm $(sudo docker ps -a -q)</span><br><span class="line">1、docker停止所有正在运行的容器</span><br><span class="line">   docker stop $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line">2、docker删除所有容器</span><br><span class="line"> docker rm $(docker ps -a | awk &#x27;&#123; print $1&#125;&#x27; | tail -n +2)</span><br><span class="line">3、docker删除所有镜像</span><br><span class="line"> docker rmi $(docker images | awk &#x27;&#123;print $3&#125;&#x27; |tail -n +2)</span><br><span class="line"> docker rmi $&#123;docker images -qa&#125;</span><br></pre></td></tr></table></figure><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、拉取镜像</span><br><span class="line">sudo docker pull mysql:5.7</span><br><span class="line">2、启动mysql容器</span><br><span class="line">sudo docker run --name mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql:/etc/mysql/conf.d -v /mydata/mysql/log:/var/log/mysql  -e MYSQL_ROOT_PASSWORD=admin123456  -p 3306:3306 -d mysql:5.7</span><br><span class="line">3、查看运行中的容器</span><br><span class="line">docker ps</span><br><span class="line">4、进入mysql容器</span><br><span class="line">docker exec -it mysql /bin/bash</span><br><span class="line">5、重启容器</span><br><span class="line">docker restart mysql</span><br></pre></td></tr></table></figure><h3 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 安装redis</span><br><span class="line">docker pull redis:6.0.10</span><br><span class="line"></span><br><span class="line">2. 修改需要自定义的配置(docker-redis默认没有配置文件，</span><br><span class="line">自己在宿主机建立后挂载映射)</span><br><span class="line">创建并修改/usr/local/redis/redis.conf</span><br><span class="line">bind 0.0.0.0 开启远程权限</span><br><span class="line">appendonly yes 开启aof持久化</span><br><span class="line"></span><br><span class="line">3.</span><br><span class="line">docker run --name redis  -v /usr/local/redis/data:/data  -v /usr/local/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis:6.0.10  redis-server /usr/local/etc/redis/redis.conf  --requirepass admin123456</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run --restart=always --log-opt max-size=100m --log-opt max-file=2 -p 6379:6379 --name redis -v /home/redis/myredis/myredis.conf:/etc/redis/redis.conf -v /home/redis/myredis/data:/data -d redis redis-server /etc/redis/redis.conf  --appendonly yes  --requirepass 000415</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.拉取镜像</span><br><span class="line">docker pull elasticsearch:7.12.0</span><br><span class="line">2.创建挂载目录</span><br><span class="line">比如在用户文件夹下创建</span><br><span class="line">mkdir -p /Users/dongnan/dockerMsg/elasticsearch/config</span><br><span class="line">mkdir -p /Users/dongnan/dockerMsg/elasticsearch/data</span><br><span class="line">cd /Users/dongnan/dockerMsg/elasticsearch/config</span><br><span class="line">vim elasticsearch.yml</span><br><span class="line">输入： </span><br><span class="line">http.host: 0.0.0.0</span><br><span class="line">保存退出</span><br><span class="line">sudo chmod -R 770 /Users/dongnan/dockerMsg/elasticsearch</span><br><span class="line">输入密码</span><br><span class="line">3.创建容器</span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">    -e &quot;discovery.type=single-node&quot; \</span><br><span class="line">    -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">    -v /Users/dongnan/dockerMsg/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">    -v /Users/dongnan/dockerMsg/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">    -v /Users/dongnan/dockerMsg/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">    -d elasticsearch:7.16.2</span><br><span class="line">4.查看es容器的ip</span><br><span class="line">docker inspect containerId</span><br><span class="line"></span><br><span class="line">5.安装Kibana</span><br><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://172.17.0.4:9200 -p 5601:5601 -d kibana:7.16.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker安装RocketMQ</span><br><span class="line"></span><br><span class="line">启动nameserver</span><br><span class="line">docker run -d -p 9876:9876 -v /Users/dongnan/namesrv/logs:/root/logs -v /Users/dongnan/namesrv/store:/root/store --name rmqnamesrv rocketmqinc/rocketmq sh mqnamesrv</span><br><span class="line"> </span><br><span class="line">启动broker</span><br><span class="line">docker run -d -p 10911:10911 -p 10909:10909 -v /Users/dongnan/broker/logs:/root/logs -v /Users/dongnan/broker/store:/root/store --name rmqbroker --link rmqnamesrv:namesrv -e &quot;NAMESRV_ADDR=127.0.0.1:9876&quot; rocketmqinc/rocketmq sh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="帮助启动类命令"><a href="#帮助启动类命令" class="headerlink" title="帮助启动类命令"></a>帮助启动类命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、启动docker</span><br><span class="line">systemctl start docker</span><br><span class="line">2、停止docker</span><br><span class="line">systemctl stop docker</span><br><span class="line">3、查看docker状态</span><br><span class="line">systemctl status docker</span><br><span class="line">4、开机启动</span><br><span class="line">systemctl enable docker</span><br><span class="line">5、查看docker概要信息</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h4 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--name=&quot;容器新名字&quot; 为容器指定一个名称</span><br><span class="line">-d:后台运行容器并返回容器id，即启动守护式容器(后台运行)</span><br><span class="line"></span><br><span class="line">-i:以交互模式运行容器，通常与-t同时使用</span><br><span class="line">-t:为容器重新分配一个伪输入终端，通常与-i同时使用；也即启动交互式容器（前台有伪终端，等待交互）</span><br><span class="line"></span><br><span class="line">-P:随机端口映射，大写P</span><br><span class="line">-p:指定端口映射，小写p</span><br><span class="line"></span><br><span class="line">交互式操作</span><br><span class="line">docker run -it centos /bin/bash</span><br><span class="line"></span><br><span class="line">退出容器</span><br><span class="line">exit: run进去容器，exit退出，容器停止</span><br><span class="line">ctrl+p+q: 容器不停止</span><br><span class="line"></span><br><span class="line">查看容器日志</span><br><span class="line">docker logs containerId</span><br><span class="line">查看容器内部细节</span><br><span class="line">docker inspect containerId</span><br><span class="line">进入容器</span><br><span class="line">docker exec -it containerId /bin/bash</span><br><span class="line">从容器内拷贝文件到主机</span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br><span class="line"></span><br><span class="line">导出容器</span><br><span class="line">docker export containerId &gt; 名称.tar</span><br><span class="line">导入容器</span><br><span class="line">cat 名称.tar | docker import 镜像用户/镜像名:镜像版本号</span><br></pre></td></tr></table></figure><h4 id="network"><a href="#network" class="headerlink" title="network"></a>network</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看所有网络</span><br><span class="line">docker network ls</span><br><span class="line">创建网络(默认网桥模式)</span><br><span class="line">docker network create aa_network</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">网络模式</th><th align="left">简介</th></tr></thead><tbody><tr><td align="left">bridge</td><td align="left">为每个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，默认为该模式</td></tr><tr><td align="left">host</td><td align="left">容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机等IP和端口</td></tr><tr><td align="left">none</td><td align="left">容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，IP等</td></tr><tr><td align="left">container</td><td align="left">新创建的容器不会创建自己的网卡和配置自己的IP，而是和一个指定的容器共享IP、端口范围等</td></tr></tbody></table><p>mogu</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1、启动mysql容器</span><br><span class="line">docker run -d -i -p 3306:3306  --name=mysql --restart=always -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7</span><br><span class="line"></span><br><span class="line">2、启动redis容器</span><br><span class="line">docker run -d --name redis -p 6379:6379 redis --requirepass “redis”</span><br><span class="line">3、启动rabbitmq</span><br><span class="line">docker run -d  --name rabbitmq -p 15672:15672 -p 5673:5672 rabbitmq</span><br><span class="line">4、启动nacos</span><br><span class="line">docker run -d \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">-e MYSQL_SERVICE_HOST=172.17.0.2 \</span><br><span class="line">-e MYSQL_SERVICE_PORT=3306 \</span><br><span class="line">-e MYSQL_SERVICE_USER=root \</span><br><span class="line">-e MYSQL_SERVICE_PASSWORD=root \</span><br><span class="line">-e MYSQL_SERVICE_DB_NAME=nacos_config \</span><br><span class="line">-p 8848:8848 \</span><br><span class="line">--restart=always \</span><br><span class="line">--name nacos \</span><br><span class="line">nacos/nacos-server:1.4.1</span><br><span class="line"></span><br><span class="line">5、docker查看容器ip</span><br><span class="line">docker inspect --format &#x27;&#123;&#123; .NetworkSettings.IPAddress &#125;&#125;&#x27; &lt;container id&gt;</span><br><span class="line"></span><br><span class="line">6、docker启动nginx</span><br><span class="line">docker run --name nginx -p 80:80 -d nginx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">挂载nginx</span><br><span class="line">创建文件路径</span><br><span class="line">mkdir /usr/local/nginx</span><br><span class="line">    mkdir /usr/local/nginx/www</span><br><span class="line">    mkdir /usr/local/nginx/conf</span><br><span class="line">    mkdir /usr/local/nginx/logs</span><br><span class="line">    复制nginx文件到本地</span><br><span class="line">    docker cp 5da957695512:/etc/nginx/nginx.conf /usr/local/nginx/nginx.conf</span><br><span class="line">    docker cp 5da957695512:/etc/nginx/conf.d /usr/local/nginx/conf/</span><br><span class="line">    docker cp 5da957695512:/usr/share/nginx/html/ /usr/local/nginx/www/html/</span><br><span class="line">    docker cp 5da957695512:/var/log/nginx/access.log /usr/local/nginx/logs/access.log</span><br><span class="line">    docker cp 5da957695512:/var/log/nginx/error.log /usr/local/nginx/logs/error.log</span><br><span class="line">  </span><br><span class="line">    删除之前容器</span><br><span class="line">    启动nginx并挂载路径</span><br><span class="line">    docker run -d -p 80:80 --name nginx -v /etc/nginx:/etc/nginx nginx</span><br><span class="line">  </span><br><span class="line">  7、查看容器ip</span><br><span class="line">  mysql:172.17.0.2</span><br><span class="line">  redis:172.17.0.3</span><br><span class="line">  nacos:172.17.0.5</span><br><span class="line">  </span><br><span class="line">  8、启动容器</span><br><span class="line">  docker run -d --name admin -p 8601:8601  gateway</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">加一个 --platform linux/amd64 就可以使用苹果m1自带的模拟器运行了</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch</title>
      <link href="/2023/11/27/ElasticSearch/"/>
      <url>/2023/11/27/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎&#x3D;&#x3D;，其次是Apache Solr，也是基于Lucene。<br>小编也是菜，还是跟着尚硅谷的视频来一样的7.4.2版本，害怕学到后面再来个版本不兼容，直接凉凉哈！！</p><h2 id="二、安装ElasticSearch"><a href="#二、安装ElasticSearch" class="headerlink" title="二、安装ElasticSearch"></a>二、安装ElasticSearch</h2><p><strong>1. 拉去ES镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:7.4.2</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADzIibWbtt9GKotJXZ0alrF5ANMDIwvibgIdOnDsPYnj4U0ficbibwWIpJjDg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">请添加图片描述</p><p><strong>2. 创建要挂载的文件与配置信息（&#x3D;&#x3D;为了数据共享，在虚拟机里修改自动同步到容器中&#x3D;&#x3D;）</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line"># 任何地址都可以访问</span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt;/mydata/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><p><strong>3. 赋予文件写的权限，不然挂载不会同步</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 赋予最高权限</span><br><span class="line">chmod -R 777 /mydata/elasticsearch/</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADzDop5MvxuqAl9upNEypBOY7AVN2hqH1T4fXODC0nicFqo3IKY57qDoUA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">请添加图片描述</p><p><strong>4. 启动Elastic search</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line"># 配置参数，防止ES占用内存过大，大概1GB,我们给他缩小一下</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v  /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADzM9dlibdm6Rliadn8xSZLGWRHQVFOicsKpu2mITTJ5xT6IPaa9J3WBjBibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">请添加图片描述</p><p><strong>5. windows测试访问（ip+9200）</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADz0QSmzoibLqtWwOODje7xuTUdEB4KEClujVOS5kQCzzkVwaXecqcDdqw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">请添加图片描述</p><p><strong>6. 设置开机自启动</strong></p><p>在这里插入图片描述</p><h2 id="三、安装Kibana可视化工具"><a href="#三、安装Kibana可视化工具" class="headerlink" title="三、安装Kibana可视化工具"></a>三、安装Kibana可视化工具</h2><p><strong>1. 拉去Kibana镜像</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull kibana:7.4.2</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADzLyqXBAdPVvQyk0dZwaqicf38qelEMiaMkLGUiblW2ZSngpl37ZFdyEyRg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">请添加图片描述</p><p><strong>2. 启动Kibana</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 地址为自己虚拟机的ip</span><br><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.17.130:9200 -p 5601:5601 -d kibana:7.4.2</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADzicQvnj3wkv9dGXegPOw49WQMkpb0TtQo4JbISMlqBk6ibHTIgCO86qZw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">请添加图片描述</p><p><strong>3. windows测试访问（ip+5601，&#x3D;&#x3D;等待一分钟，不然出不来界面&#x3D;&#x3D;）</strong></p><p>**<br>**</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADzRbuyKg6b4vZspmic8W6dibkyXefyV9RXZ4ic7k5BUXv7pnYs2fBEQMdQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">请添加图片描述</p><p><strong>4. 设置开机自启动</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/aEiceyKIJLoecQjQiaibAVuLkF0niahM3ADzDiaPyA6Wpyw2LmxYvJGO17qwCzFZjM2Q6xicdLd3QvpYoC5lECqy86BA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片">在这里插入图片描述</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这样我们就搭建完成了，可以进行测试了！本文是根据尚硅谷雷神的教学，特此记录一下，供以后查看！</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JDK1.8新特性</title>
      <link href="/2023/11/27/JDK/"/>
      <url>/2023/11/27/JDK/</url>
      
        <content type="html"><![CDATA[<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p><table><thead><tr><th align="left">序号</th><th>方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td>**static <T> Optional<T> empty()**返回空的 Optional 实例。</T></T></td></tr><tr><td align="left">2</td><td>**boolean equals(Object obj)**判断其他对象是否等于 Optional。</td></tr><tr><td align="left">3</td><td>**Optional<T> filter(Predicate&lt;? super <T> predicate)**如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</T></T></td></tr><tr><td align="left">4</td><td>**<U> Optional<U> flatMap(Function&lt;? super T,Optional<U>&gt; mapper)**如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional</U></U></U></td></tr><tr><td align="left">5</td><td>**T get()**如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException</td></tr><tr><td align="left">6</td><td>**int hashCode()**返回存在值的哈希码，如果值不存在 返回 0。</td></tr><tr><td align="left">7</td><td>**void ifPresent(Consumer&lt;? super T&gt; consumer)**如果值存在则使用该值调用 consumer , 否则不做任何事情。</td></tr><tr><td align="left">8</td><td>**boolean isPresent()**如果值存在则方法会返回true，否则返回 false。</td></tr><tr><td align="left">9</td><td>**<U>Optional<U> map(Function&lt;? super T,? extends U&gt; mapper)**如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</U></U></td></tr><tr><td align="left">10</td><td>**static <T> Optional<T> of(T value)**返回一个指定非null值的Optional。</T></T></td></tr><tr><td align="left">11</td><td>**static <T> Optional<T> ofNullable(T value)**如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</T></T></td></tr><tr><td align="left">12</td><td>**T orElse(T other)**如果存在该值，返回值， 否则返回 other。</td></tr><tr><td align="left">13</td><td>**T orElseGet(Supplier&lt;? extends T&gt; other)**如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td></tr><tr><td align="left">14</td><td>**<X extends throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)**如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常</X></td></tr><tr><td align="left">15</td><td>**String toString()**返回一个Optional的非空字符串，用来调试</td></tr></tbody></table><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 获取对应的平方数 List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>); <span class="comment">// 获取空字符串的数量 long count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span></span><br></pre></td></tr></table></figure><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(); random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h2><h4 id="并行（parallel）程序-1"><a href="#并行（parallel）程序-1" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h4><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">// 获取空字符串的数量</span><br><span class="line">long count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><p>我们可以很容易的在顺序运行和并行直接切换。</p><h4 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h4><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;筛选列表: &quot;</span> + filtered);</span><br><span class="line"><span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br></pre></td></tr></table></figure><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>匿名内部类</title>
      <link href="/2023/11/27/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2023/11/27/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p>1.本质还是一个类</p><p>2.是一个内部类</p><p>3.该类没有名字（但是系统会分配一个代号在内存中）</p><h2 id="二、匿名内部类的使用场景"><a href="#二、匿名内部类的使用场景" class="headerlink" title="二、匿名内部类的使用场景"></a>二、匿名内部类的使用场景</h2><p><strong>假设我们有一个接口A<br>内部有一个未被实现的方法eat<br>如果我们想在main中直接调用eat方法<br>则按照传统思路需要一个类B来实现接口A，同时再创建类B的对象来调用A<br>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在调用eat方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------</span><br><span class="line">正在调用eat方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>如果我们只是想单纯的使用一次eat方法，不需要创建对象的话，则上面方法略显古板。<br>此时，便用到了匿名内部类。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在调用eat方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">----------------------</span><br><span class="line">正在调用eat方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>上面这种写法就可以很好的简化代码的书写<br>此时的匿名内部类相当于一个对象，所以它的后面可以直接调用eat方法，非常的简便快捷<br>当A里面有多个方法时，如果想要同时调用，可以采用下面的写法：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在调用eat方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在调用drink方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.eat();</span><br><span class="line">        a.drink();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而此时我们并没有实例化这个接口的类，便实现了里面的方法，所以称之为匿名内部类</p><p>其实，这个类是被临时创建了，在<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">内存</a>中存在系统设定的名字，</p><p>我们可以使用下面方法来得到匿名内部类的（名字）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在调用eat方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;正在调用drink方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.eat();</span><br><span class="line">        a.drink();</span><br><span class="line">        System.out.println(a.getClass()); <span class="comment">//获取类名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">-------------------</span><br><span class="line">正在调用eat方法</span><br><span class="line">正在调用drink方法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span>.interface_.Interface01$<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此可见，这个匿名内部类的名字为Interface01$1，当下一个匿名内部类时，就会变成$2，以此类推</p><h2 id="三、匿名内部类的最常使用场景"><a href="#三、匿名内部类的最常使用场景" class="headerlink" title="三、匿名内部类的最常使用场景"></a>三、匿名内部类的最常使用场景</h2><p>通过实参的形式来使用，大大简化了代码的书写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        f(<span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;没有创建对象便成功的调用了f方法，不需要实现接口&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------</span><br><span class="line">没有创建对象便成功的调用了f方法，不需要实现接口</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>而按照传统方法则需要：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        f(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(A a)</span>&#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在调用eat方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------</span><br><span class="line">正在调用eat方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四、Java匿名内部类的注意事项"><a href="#四、Java匿名内部类的注意事项" class="headerlink" title="四、Java匿名内部类的注意事项"></a>四、Java匿名内部类的注意事项</h2><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><p>1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。</p><p>2、匿名内部类中是不能定义构造函数的。</p><p>3、匿名内部类中不能存在任何的静态成员变量和静态方法。</p><p>4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。</p><p>5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC高级</title>
      <link href="/2023/11/27/JUC%E7%AC%94%E8%AE%B0/JUC%E9%AB%98%E7%BA%A7/"/>
      <url>/2023/11/27/JUC%E7%AC%94%E8%AE%B0/JUC%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC高级"><a href="#JUC高级" class="headerlink" title="JUC高级"></a>JUC高级</h1><h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><blockquote><p>​一个对象里面如果有多个sychronized方法，某一个时刻内，只要一个线程去调用其中的一个sychronized方法了，其他线程都只能等待，换句话说，某一个时刻内，只能有唯一的一个线程去访问这些sychronized方法</p><p>​&#x3D;&#x3D;锁的是当前对象this&#x3D;&#x3D;，被锁定后，其它的线程都不能进入到当前对象的其它sychronized方法</p><p>​&#x3D;&#x3D;静态同步方法，锁的是类，不是对象&#x3D;&#x3D;</p><p>​对于同步方法块，锁的是 sychronized括号内的对象</p></blockquote><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。</p><p>​sychronized关键字和Lock的实现都是悲观锁</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​&#x3D;&#x3D;乐观锁认为自己在修改数据时不会有别的线程修改数据&#x3D;&#x3D;，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已被其他线程更新，则根据不同的实现方式执行不同的操作。</p><p>​乐观锁在Java中是通过使用无锁编程来实现。&#x3D;&#x3D;最常采用的是CAS算法，Java原子类中的递增就是通过CAS自旋实现&#x3D;&#x3D;</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul><li><p>公平锁 </p><p>按序排队，就是判断同步队列里是否还有先驱节点的存在，如果没有先驱节点才能获得锁</p></li><li><p>非公平锁</p><p>先占先得，只要能抢到同步状态就可以</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();<span class="comment">//默认非公平锁，分配不平均</span></span><br><span class="line"></span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);<span class="comment">//公平锁</span></span><br></pre></td></tr></table></figure><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>​可重入锁又名递归锁 是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。 </p><p>​如果是1个有 synchronized 修饰的递归调用方法，程序第2次进入被自己阻塞了岂不是天大的笑话，出现了作茧自缚。所以Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p><ul><li>种类</li></ul><p>​隐式锁（即synchronized关键字使用的锁）默认是可重入锁</p><p>​指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁，这样的锁就叫做可重入锁。简单的来说就是：&#x3D;&#x3D;在一个synchronized修饰的方法或代码块的内部调用本类的其他synchronized修饰的方法或代码块时，是永远可以得到锁的 与可重入锁相反，不可重入锁不可递归调用，递归调用就发生死锁。&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReEntryLockDemo</span>&#123;    </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>    &#123;        </span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">objectLockA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;            </span><br><span class="line">      <span class="keyword">synchronized</span> (objectLockA)&#123;                </span><br><span class="line">        System.out.println(<span class="string">&quot;-----外层调用&quot;</span>);                </span><br><span class="line">        <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;-----中层调用&quot;</span>);                    </span><br><span class="line">          <span class="keyword">synchronized</span> (objectLockA)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----内层调用&quot;</span>);</span><br><span class="line">          &#125;                </span><br><span class="line">        &#125;            </span><br><span class="line">      &#125;        </span><br><span class="line">    &#125;,<span class="string">&quot;a&quot;</span>).start();&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>jconsole命令</p></blockquote><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>wait和notify方法必须要在同步块或者方法里，且成对出现使用。先wait后notify才OK。</p><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><p>p25</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程中断机制</title>
      <link href="/2023/11/27/JUC%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/11/27/JUC%E7%AC%94%E8%AE%B0/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>​首先一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。 </p><p>​其次在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的机制——中断。 </p><p>​&#x3D;&#x3D;中断只是一种协作机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自己实现。&#x3D;&#x3D;</p><p>​若要中断一个线程，你需要手动调用该线程的interrupt方法，该方法也仅仅是&#x3D;&#x3D;将线程对象的中断标识设成true；&#x3D;&#x3D;接着你需要自己写代码不断地检测当前线程的标识位，如果为true，表示别的线程要求这条线程中断，此时究竟该做什么需要你自己写代码实现。 </p><p>​每个线程对象中都有一个标识，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设为true；可以在别的线程中调用，也可以在自己的线程中调用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span></span><br><span class="line">  实例方法，实例方法interrupt()仅仅是设置线程的中断状态为<span class="literal">true</span>，不会停止线程</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">interrupted</span><span class="params">()</span> 静态方法，Thread.interrupted();  </span><br><span class="line">判断线程是否被中断，并清除当前中断状态这个方法做了两件事：</span><br><span class="line">     <span class="number">1</span> 返回当前线程的中断状态</span><br><span class="line">     <span class="number">2</span> 将当前线程的中断状态设为<span class="literal">false</span> </span><br><span class="line">     这个方法有点不好理解，因为连续调用两次的结果可能不一样。</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterrupted</span><span class="params">()</span></span><br><span class="line">     实例方法，判断当前线程是否被中断（通过检查中断标志位） </span><br></pre></td></tr></table></figure><blockquote><p>volatile </p><p>1.线程的可见性：当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</p><p>2.顺序一致性：禁止指令重排序。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM字节码</title>
      <link href="/2023/11/27/JVM/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/"/>
      <url>/2023/11/27/JVM/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="一、字节码文件概述"><a href="#一、字节码文件概述" class="headerlink" title="一、字节码文件概述"></a>一、字节码文件概述</h2><h4 id="1-什么是字节码指令（byte-code）"><a href="#1-什么是字节码指令（byte-code）" class="headerlink" title="1.什么是字节码指令（byte code）"></a>1.什么是字节码指令（byte code）</h4><p>Java虚拟机的指令是由一个字节长度的、代表着某种特定操作含义的操作码（opcode）以及跟随在其后的零至多个代表此操作所需参数的操作数（operand）所构成。虚拟机中许多指令并不包含操作数，只有一个操作码。</p><ul><li><p>包装类对象缓存问题</p><table><thead><tr><th>包装类</th><th>缓存问题</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Integer</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Float</td><td>没有</td></tr><tr><td>Double</td><td>没有</td></tr><tr><td>Character</td><td>0-127</td></tr><tr><td>Boolean</td><td>true和false</td></tr></tbody></table></li></ul><p><strong>class文件的总体结构：</strong></p><ul><li>魔数</li><li>Class文件版本</li><li>常量池</li><li>访问标识</li><li>类索引、父类索引、接口索引集合</li><li>字段表集合</li><li>方法表集合</li><li>属性表集合</li></ul><p><strong>符号引用和直接引用</strong></p><p>​Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。也就是说，&#x3D;&#x3D;在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。&#x3D;&#x3D;当虚拟机运行时，需要从常量池获得对应的符号引用再在类创建时或运行时解析、翻译到具体的内存地址之中。<br>​虚拟机在加载类文件时才会进行动态链接，也就是说，类文件中不会保存各个方法和代码字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。&#x3D;&#x3D;当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。&#x3D;&#x3D;<br>​这里说明下符号引用和直接引用的区别与关联:<br>​符号引用:符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。<br>​直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM类加载过程</title>
      <link href="/2023/11/27/JVM/2%E3%80%81JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/11/27/JVM/2%E3%80%81JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-类的加载过程"><a href="#一、-类的加载过程" class="headerlink" title="一、 类的加载过程"></a>一、 类的加载过程</h2><h3 id="过程一、Loading-装载-阶段"><a href="#过程一、Loading-装载-阶段" class="headerlink" title="过程一、Loading(装载)阶段"></a>过程一、Loading(装载)阶段</h3><p>所谓装载，就是把Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型————类模版对象。</p><p>​<strong>装载完成的操作</strong></p><p>​装载阶段，简言之，查找并加载类的二进制数据，生成class的实例。</p><p>​在加载类时，Java虚拟机必须完成以下3件事情：</p><ul><li>通过类的全名，获取类的二进制数据流</li><li>解析类的二进制数据流为方法区内的数据结构（Java类模型）</li><li>创建java.long.Class类的实例，表示该模型。作为方法区这个类的各种数据的访问入口。</li></ul><p>​<strong>类模版对象</strong></p><p>​所谓类模版对象，其实就是Java类在JVM内存中的一个快照，JVM将从字节码文件中解析出来的常量池、类字段、类方法等信息存储到类模版中，这样JVM在运行期便能通过类模版而获取Java类中的基本信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p><h3 id="过程二、Linking（链接）阶段"><a href="#过程二、Linking（链接）阶段" class="headerlink" title="过程二、Linking（链接）阶段"></a>过程二、Linking（链接）阶段</h3><h4 id="环节1：verification-验证"><a href="#环节1：verification-验证" class="headerlink" title="环节1：verification(验证)"></a>环节1：verification(验证)</h4><p>​当类加载到系统后，就开始链接操作，第一步就是验证</p><p>​&#x3D;&#x3D;目的是保证加载到字节码是合法、合理并符合规范的&#x3D;&#x3D;</p><p>​主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 </p><h4 id="环节2：Preparation（准备）阶段"><a href="#环节2：Preparation（准备）阶段" class="headerlink" title="环节2：Preparation（准备）阶段"></a>环节2：Preparation（准备）阶段</h4><ul><li>为类的静态变量分配内存，并将其初始化为默认值</li><li>这里不包含用final static修饰的，因为final在编译的时候就会分配了，准备阶段会显式初始化； </li><li>这里不会为实例变量分配初始化 ，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。</li></ul><h4 id="环节3-Resolution（解析）阶段"><a href="#环节3-Resolution（解析）阶段" class="headerlink" title="环节3:Resolution（解析）阶段"></a>环节3:Resolution（解析）阶段</h4><ul><li><p>&#x3D;&#x3D;将常量池内的符号引用转换为直接引用的过程。&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。&#x3D;&#x3D; </p><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。 </p><p>在解析阶段，jvm根据字符串的内容找到内存区域中相应的地址，然后把符号引用替换成直接指向目标的指针、句柄、偏移量等，这些直接指向目标的指针、句柄、偏移量就被成为 <strong>直接引用</strong> 。</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</p></li></ul><h3 id="过程三、Initialization（初始化）阶段"><a href="#过程三、Initialization（初始化）阶段" class="headerlink" title="过程三、Initialization（初始化）阶段"></a>过程三、Initialization（初始化）阶段</h3><p>​为类的静态变量赋予正确的初始值。到了初始化阶段，才真正开始执行类中定义的程序代码。</p><p>​初始化阶段重要工作是执行类的初始化方法：<clinit>()方法</clinit></p><p>​</p><h3 id="过程四、类的Using（使用）"><a href="#过程四、类的Using（使用）" class="headerlink" title="过程四、类的Using（使用）"></a>过程四、类的Using（使用）</h3><h3 id="过程五、类的unloading（卸载）"><a href="#过程五、类的unloading（卸载）" class="headerlink" title="过程五、类的unloading（卸载）"></a>过程五、类的unloading（卸载）</h3><h2 id="二、JVM的类加载器"><a href="#二、JVM的类加载器" class="headerlink" title="二、JVM的类加载器"></a>二、JVM的类加载器</h2><img src="11/27/JVM/2%E3%80%81JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/dca31c18354f4f40a7190b17ef2c0eed~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" class title="类加载器"><h4 id="3-1、Bootstrap-引导类加载器"><a href="#3-1、Bootstrap-引导类加载器" class="headerlink" title="3.1、Bootstrap 引导类加载器"></a>3.1、Bootstrap 引导类加载器</h4><p>引导类加载器在有些地方也被称为启动类加载器或根类加载器，但其实都是一个意思，都是在指<code>BootstrapClassLoader</code>。引导类加载器是使用C++语言实现的，是JVM自身的一部分，主要负责将<code>&lt;JAVA_HOME&gt;\lib</code>路径下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的jar包加载到内存中。</p><blockquote><p>注意：因为JVM是通过全限定名加载类库的，所以，如果你的文件名不被虚拟机识别，就算你把jar包丢入到lib目录下，引导类加载器也并不会加载它。出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类文件。</p></blockquote><p>引导类加载器只为JVM提供加载服务，开发者不能直接使用它来加载自己的类。</p><h4 id="3-2、Extension-拓展类加载器"><a href="#3-2、Extension-拓展类加载器" class="headerlink" title="3.2、Extension 拓展类加载器"></a>3.2、Extension 拓展类加载器</h4><p>这个类加载器是由sun公司实现的，位于<code>HotSpot</code>源码目录中的<code>sun.misc.Launcher$ExtClassLoader</code>位置。它主要负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下或者由系统变量<code>-Djava.ext.dir</code>指定位路径中的类库。它可以直接被开发者使用。</p><h4 id="3-3、Application-系统类加载器"><a href="#3-3、Application-系统类加载器" class="headerlink" title="3.3、Application 系统类加载器"></a>3.3、Application 系统类加载器</h4><p>也被称为应用程序类加载器，也是由sun公司实现的，位于<code>HotSpot</code>源码目录中的<code>sun.misc.Launcher$AppClassLoader</code>位置。它负责加载系统类路径<code>java -classpath</code>或<code>-D java.class.path</code>指定路径下的类库，也就是经常用到的<code>classpath</code>路径。应用程序类加载器也可以直接被开发者使用。</p><blockquote><p>一般情况下，该类加载器是程序的默认类加载器，我们可以通过ClassLoader.getSystemClassLoader()方法可以直接获取到它。</p></blockquote><h4 id="3-4、User-自定义类加载器"><a href="#3-4、User-自定义类加载器" class="headerlink" title="3.4、User 自定义类加载器"></a>3.4、User 自定义类加载器</h4><p>在Java程序中，运行时一般都是通过如上三种类加载器相互配合执行的，当然，如果有特殊的加载需求也可以自定义类加载器，通过继承<code>ClassLoader</code>类实现（稍后分析）。</p><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><ul><li>①自下向上检查类是否已经被加载</li><li>②从上至下尝试加载类</li></ul><h4 id="3-1、双亲委派类加载过程"><a href="#3-1、双亲委派类加载过程" class="headerlink" title="3.1、双亲委派类加载过程"></a>3.1、双亲委派类加载过程</h4><ul><li>①当<code>App</code>尝试加载一个类时，它不会直接尝试加载这个类，首先会在自己的命名空间中查询是否已经加载过这个类，如果没有会先将这个类加载请求委派给父类加载器<code>Ext</code>完成</li><li>②当<code>Ext</code>尝试加载一个类时，它也不会直接尝试加载这个类，也会在自己的命名空间中查询是否已经加载过这个类，没有的话也会先将这个类加载请求委派给父类加载器<code>Bootstrap</code>完成</li><li>③如果<code>Bootstrap</code>加载失败，也就是代表着：这个需要被加载的类不在<code>Bootstrap</code>的加载范围内，那么<code>Bootstrap</code>会重新将这个类加载请求交由子类加载器<code>Ext</code>完成</li><li>④如果<code>Ext</code>加载失败，代表着这个类也不在<code>Ext</code>的加载范围内，最后会重新将这个类加载请求交给子类加载器<code>App</code>完成</li><li>⑤如果<code>App</code>加载器也加载失败，就代表这个类根据全限定名无法查找到，则会抛出<code>ClassNotFoundException</code>异常</li></ul><h4 id><a href="#" class="headerlink" title></a></h4><blockquote><p>核心是 ClassLoader类的loadClass方法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2023/11/27/JUC%E7%AC%94%E8%AE%B0/JUC/"/>
      <url>/2023/11/27/JUC%E7%AC%94%E8%AE%B0/JUC/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC-高并发编程"><a href="#JUC-高并发编程" class="headerlink" title="JUC 高并发编程"></a>JUC 高并发编程</h1><h2 id="•-课程内容概览"><a href="#•-课程内容概览" class="headerlink" title="• 课程内容概览"></a>• 课程内容概览</h2><ul><li>1 、什么是JUC</li><li>2 、Lock接口</li><li>3 、线程间通信</li><li>4 、集合的线程安全</li><li>5 、多线程锁</li><li>6 、Callable接口</li><li>7 、JUC三大辅助类: CountDownLatch CyclicBarrier Semaphore</li><li>8 、读写锁: ReentrantReadWriteLock</li><li>9 、阻塞队列</li><li>10 、ThreadPool线程池</li><li>11 、Fork&#x2F;Join框架</li><li>12 、CompletableFuture</li></ul><h1 id="1-什么是-JUC"><a href="#1-什么是-JUC" class="headerlink" title="1 什么是 JUC"></a>1 什么是 JUC</h1><h2 id="1-1-JUC简介"><a href="#1-1-JUC简介" class="headerlink" title="1.1 JUC简介"></a>1.1 JUC简介</h2><p>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK1.5开始出现的。</p><h2 id="1-2-进程与线程"><a href="#1-2-进程与线程" class="headerlink" title="1.2 进程与线程"></a>1.2 进程与线程</h2><p>进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><h4 id="总结来说"><a href="#总结来说" class="headerlink" title="总结来说:"></a>总结来说:</h4><p>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位。</p><p>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位。</p><h2 id="1-3-线程的状态"><a href="#1-3-线程的状态" class="headerlink" title="1.3 线程的状态"></a>1.3 线程的状态</h2><h3 id="1-3-1-线程状态枚举类"><a href="#1-3-1-线程状态枚举类" class="headerlink" title="1.3.1 线程状态枚举类"></a>1.3.1 线程状态枚举类</h3><h4 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread.State"></a>Thread.State</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  NEW,(新建)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Thread state for a runnable thread. A thread in the runnable</span></span><br><span class="line"><span class="comment">* state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">* be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">* such as processor.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RUNNABLE,（准备就绪）</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">* A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">* to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">* reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  BLOCKED,（阻塞）</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* following methods:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;ul&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* perform a particular action.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  WAITING,（不见不散）</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;ul&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">* &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  TIMED_WAITING,（过时不候）</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">* The thread has completed execution.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  TERMINATED;(终结)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-wait-sleep的区别"><a href="#1-3-2-wait-sleep的区别" class="headerlink" title="1.3.2 wait&#x2F;sleep的区别"></a>1.3.2 wait&#x2F;sleep的区别</h3><p>（ 1 ）sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。</p><p>（ 2 ）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized中)。</p><p>（ 3 ）它们都可以被interrupted方法中断。</p><h2 id="1-4-并发与并行"><a href="#1-4-并发与并行" class="headerlink" title="1.4 并发与并行"></a>1.4 并发与并行</h2><h3 id="1-4-1-串行模式"><a href="#1-4-1-串行模式" class="headerlink" title="1.4.1 串行模式"></a>1.4.1 串行模式</h3><p>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步骤，才能进行下一个步骤。</p><p>串行是一次只能取得一个任务，并执行这个任务 。</p><h3 id="1-4-2-并行模式"><a href="#1-4-2-并行模式" class="headerlink" title="1.4.2 并行模式"></a>1.4.2 并行模式</h3><p>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列的长度。并行的效率从代码层次上强依赖于多进程&#x2F;多线程代码，从硬件角度上则依赖于多核CPU。</p><h3 id="1-4-3-并发"><a href="#1-4-3-并发" class="headerlink" title="1.4.3 并发"></a>1.4.3 并发</h3><p>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可以同时运行或者多指令可以同时运行 。但这不是重点，在描述并发的时候也不会去扣这种字眼是否精确，&#x3D;&#x3D;并发的重点在于它是一种现象&#x3D;&#x3D;, &#x3D;&#x3D;并发描述的是多进程同时运行的现象&#x3D;&#x3D;。但实际上，对于单核心CPU来说，同一时刻只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个</p><p>线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一会停一会。要解决大并发问题，通常是将大任务分解成多个小任务 , 由于操作系统对进程的调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可能会出现一些现象：</p><ul><li><p>可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用队列或类似的数据结构来存放各个小任务的成果</p></li><li><p>可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或异步的方式，比如只有准备好产生了事件通知才执行某个任务。</p></li><li><p>可以多进程&#x2F;多线程的方式并行执行这些小任务。也可以单进程&#x2F;单线程执行这些小任务，这时很可能要配合多路复用才能达到较高的效率</p></li></ul><h3 id="1-4-4-小结-重点"><a href="#1-4-4-小结-重点" class="headerlink" title="1.4.4 小结(重点)"></a>1.4.4 小结(重点)</h3><p>并发： 同一时刻多个线程在访问同一个资源，多个线程对一个点</p><p>例子：春运抢票 电商秒杀…</p><p>并行： 多项工作一起执行，之后再汇总</p><p>例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</p><h2 id="1-5管程"><a href="#1-5管程" class="headerlink" title="1.5管程"></a>1.5管程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同</span><br><span class="line">一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程</span><br><span class="line">(monitor)对象，管程(monitor)会随着java对象一同创建和销毁</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方</span><br><span class="line">法在执行时候会持有管程，其他线程无法再获取同一个管程</span><br></pre></td></tr></table></figure><h2 id="1-6用户线程和守护线程"><a href="#1-6用户线程和守护线程" class="headerlink" title="1.6用户线程和守护线程"></a>1.6用户线程和守护线程</h2><p>用户线程: 平时用到的普通线程,自定义线程</p><p>守护线程: 运行在后台,是一种特殊的线程,比如垃圾回收</p><p>当主线程结束后,用户线程还在运行,JVM存活</p><p>如果没有用户线程,都是守护线程,JVM结束</p><h1 id="2-、Lock-接口"><a href="#2-、Lock-接口" class="headerlink" title="2 、Lock 接口"></a>2 、Lock 接口</h1><h2 id="2-1-Synchronized"><a href="#2-1-Synchronized" class="headerlink" title="2.1 Synchronized"></a>2.1 Synchronized</h2><h3 id="2-1-1-Synchronized关键字回顾"><a href="#2-1-1-Synchronized关键字回顾" class="headerlink" title="2.1.1 Synchronized关键字回顾"></a>2.1.1 Synchronized关键字回顾</h3><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ol><li><p>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</p></li><li><p>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；虽然可以使用synchronized来定义方法，但synchronized并不属于方法定义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。</p></li><li><p>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</p></li><li><p>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</p></li></ol><h4 id="2-1-2-售票案例"><a href="#2-1-2-售票案例" class="headerlink" title="2.1.2 售票案例"></a>2.1.2 售票案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line"><span class="comment">// 票数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span> ;</span><br><span class="line"><span class="comment">// 操作方法：卖票</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 判断：是否有票</span></span><br><span class="line"><span class="keyword">if</span> ( number &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">System. out .println(Thread. currentThread ().getName()+ <span class="string">&quot; :</span></span><br><span class="line"><span class="string">&quot;</span> +( number --)+ <span class="string">&quot; &quot;</span> + number );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><p>1 ）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</p><p>2 ）线程执行发生异常，此时JVM会让线程自动释放锁。那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</p><h4 id="2-2-什么是Lock"><a href="#2-2-什么是Lock" class="headerlink" title="2.2 什么是Lock"></a>2.2 什么是Lock</h4><p>Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock提供了比synchronized更多的功能。</p><h4 id="Lock与的Synchronized区别"><a href="#Lock与的Synchronized区别" class="headerlink" title="Lock与的Synchronized区别"></a>Lock与的Synchronized区别</h4><ul><li><p>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；</p></li><li><p>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。</p></li></ul><h4 id="2-2-1-Lock接口"><a href="#2-2-1-Lock接口" class="headerlink" title="2.2.1 Lock接口"></a>2.2.1 Lock接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="下面来逐个讲述Lock接口中每个方法的使用"><a href="#下面来逐个讲述Lock接口中每个方法的使用" class="headerlink" title="下面来逐个讲述Lock接口中每个方法的使用"></a>下面来逐个讲述Lock接口中每个方法的使用</h4><h4 id="2-2-2-lock"><a href="#2-2-2-lock" class="headerlink" title="2.2.2 lock"></a>2.2.2 lock</h4><p>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock来进行同步的话，是以下面这种形式去使用的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-newCondition"><a href="#2-2-3-newCondition" class="headerlink" title="2.2. 3 newCondition"></a>2.2. 3 newCondition</h4><p>​关键字synchronized与wait()&#x2F;notify()这两个方法一起使用可以实现等待&#x2F;通知模式， Lock锁的newContition()方法返回Condition对象，Condition类也可以实现等待&#x2F;通知模式。</p><p>​用notify()通知时，JVM会随机唤醒某个等待的线程， 使用Condition类可以进行选择性通知， Condition比较常用的两个方法：</p><ul><li><p>await()会使当前线程等待,同时会释放锁,当其他线程调用signal()时,线程会重新获得锁并继续执行。</p></li><li><p>signal()用于唤醒一个等待的线程。</p></li></ul><p>&#x3D;&#x3D;</p><p>注意：在调用Condition的await()&#x2F;signal()方法前，也需要线程持有相关的Lock锁，调用await()后线程会释放这个锁，在singal()调用后会从当前Condition对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。</p><p>&#x3D;&#x3D;</p><h4 id="2-3-ReentrantLock"><a href="#2-3-ReentrantLock" class="headerlink" title="2.3 ReentrantLock"></a>2.3 ReentrantLock</h4><p>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。</p><p>ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">private</span> ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">test.insert(Thread.currentThread());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">test.insert(Thread.currentThread());</span><br><span class="line">&#125;;</span><br><span class="line">&#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//注意这个地方</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i= <span class="number">0</span> ;i&lt; <span class="number">5</span> ;i++) &#123;</span><br><span class="line">arrayList.add(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-ReadWriteLock"><a href="#2-4-ReadWriteLock" class="headerlink" title="2.4 ReadWriteLock"></a>2.4 ReadWriteLock</h4><p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Returns the lock used for reading.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Returns the lock used for writing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的ReentrantReadWriteLock 实现了ReadWriteLock接口。ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p><p>下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</p><p>假如有多个线程要同时进行读操作的话，先看一下 synchronized 达到的效果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">#### ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### test.get(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">#### &#125;;</span><br><span class="line"></span><br><span class="line">#### &#125;.start();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">#### test.get(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">#### &#125;;</span><br><span class="line"></span><br><span class="line">#### &#125;.start();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(thread.getName()+<span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### System.out.println(thread.getName()+<span class="string">&quot;读操作完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><p>而改成用读写锁的话：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"></span><br><span class="line">#### ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">#### test.get(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">#### &#125;;</span><br><span class="line"></span><br><span class="line">#### &#125;.start();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">#### test.get(Thread.currentThread());</span><br><span class="line"></span><br><span class="line">#### &#125;;</span><br><span class="line"></span><br><span class="line">#### &#125;.start();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line"></span><br><span class="line">#### rwl.readLock().lock();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(thread.getName()+<span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### System.out.println(thread.getName()+<span class="string">&quot;读操作完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">#### rwl.readLock().unlock();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><p>说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。</p><p>&#x3D;&#x3D; 注意: &#x3D;&#x3D;</p><ul><li><p>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。</p></li><li><p>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。</p></li></ul><h4 id="2-5-小结-重点"><a href="#2-5-小结-重点" class="headerlink" title="2.5 小结(重点)"></a>2.5 小结(重点)</h4><p>Lock和synchronized有以下几点不同：</p><ol><li><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p></li><li><p>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p></li><li><p>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p></li><li><p>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p></li><li><p>Lock可以提高多个线程进行读操作的效率。</p></li></ol><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。</p><h1 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3 线程间通信"></a>3 线程间通信</h1><p>线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模型来实现的。我们来基本一道面试常见的题目来分析场景—两个线程，一个线程对当前数值加 1 ，另一个线程对当前数值减1,要求用线程间通信</p><h2 id="3-1-synchronized方案"><a href="#3-1-synchronized方案" class="headerlink" title="3. 1 synchronized方案"></a>3. 1 synchronized方案</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* volatile关键字实现线程交替加减</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 交替加减</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">DemoClass</span> <span class="variable">demoClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoClass</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">demoClass.increment();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">demoClass.decrement();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加减对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 加 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">number++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;加一成</span></span><br><span class="line"><span class="string">功----------,值为:&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">notifyAll();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 减一</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">number--;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;减一成</span></span><br><span class="line"><span class="string">功----------,值为:&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">notifyAll();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Lock方案"><a href="#3-2-Lock方案" class="headerlink" title="3. 2 Lock方案"></a>3. 2 Lock方案</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加减对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">//声明锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">##### <span class="comment">//声明钥匙</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 加 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">number++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;加一成</span></span><br><span class="line"><span class="string">功----------,值为:&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">condition.signalAll();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 减一</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">condition.await();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">number--;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;--------&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;减一成</span></span><br><span class="line"><span class="string">功----------,值为:&quot;</span> + number);</span><br><span class="line"></span><br><span class="line">condition.signalAll();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### &#125;</span><br><span class="line"></span><br><span class="line">##### &#125;</span><br><span class="line"></span><br><span class="line">##### &#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-线程间定制化通信"><a href="#3-4-线程间定制化通信" class="headerlink" title="3 .4 线程间定制化通信"></a>3 .4 线程间定制化通信</h2><h3 id="4-4-1-案例介绍"><a href="#4-4-1-案例介绍" class="headerlink" title="4.4.1 案例介绍"></a>4.4.1 案例介绍</h3><p>&#x3D;&#x3D; 问题: </p><p>A线程打印 5 次A，B线程打印 10 次B，C线程打印 15 次C,按照此顺序循环 10 轮 </p><p>&#x3D;&#x3D;</p><h3 id="4-4-2-实现流程"><a href="#4-4-2-实现流程" class="headerlink" title="4.4.2 实现流程"></a>4.4.2 实现流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DemoClass</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通信对象:0--打印A 1---打印B 2----打印C</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明钥匙A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明钥匙B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明钥匙C</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * A打印 5 次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">(<span class="type">int</span> j)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">conditionA.await();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出A,第&quot;</span> + j + <span class="string">&quot;</span></span><br><span class="line"><span class="string">轮开始&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 5 次A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始打印B</span></span><br><span class="line"></span><br><span class="line">number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒B</span></span><br><span class="line"></span><br><span class="line">conditionB.signal();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * B打印 10 次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">(<span class="type">int</span> j)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">conditionB.await();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出B,第&quot;</span> + j + <span class="string">&quot;</span></span><br><span class="line"><span class="string">轮开始&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 10 次B</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始打印C</span></span><br><span class="line"></span><br><span class="line">number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒C</span></span><br><span class="line"></span><br><span class="line">conditionC.signal();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * C打印 15 次</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">(<span class="type">int</span> j)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line">conditionC.await();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出C,第&quot;</span> + j + <span class="string">&quot;</span></span><br><span class="line"><span class="string">轮开始&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 15 次C</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始打印A</span></span><br><span class="line"></span><br><span class="line">number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒A</span></span><br><span class="line"></span><br><span class="line">conditionA.signal();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### &#125;</span><br><span class="line"></span><br><span class="line">##### &#125;</span><br><span class="line"></span><br><span class="line">##### 测试类</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* volatile关键字实现线程交替加减</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestVolatile</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 交替加减</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">DemoClass</span> <span class="variable">demoClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">demoClass.printA(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;A线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demoClass.printB(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;B线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">demoClass.printC(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;C线程&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-集合的线程安全"><a href="#4-集合的线程安全" class="headerlink" title="4 集合的线程安全"></a>4 集合的线程安全</h1><h2 id="4-1-集合操作Demo"><a href="#4-1-集合操作Demo" class="headerlink" title="4 .1 集合操作Demo"></a>4 .1 集合操作Demo</h2><p>NotSafeDemo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 集合线程安全案例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">list.add(UUID.randomUUID().toString());</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">异常内容</span><br><span class="line"></span><br><span class="line">java.util.ConcurrentModificationException</span><br><span class="line"></span><br><span class="line">**问题: 为什么会出现并发修改异常?**</span><br><span class="line"></span><br><span class="line">查看ArrayList的add方法源码</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">  ensureCapacityInternal(size + <span class="number">1</span> ); <span class="comment">// Increments modCount!!</span></span><br><span class="line">  elementData[size++] = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D; 那么我们如何去解决List类型的线程安全问题? &#x3D;&#x3D;</p><h2 id="4-2-Vector"><a href="#4-2-Vector" class="headerlink" title="4 .2 Vector"></a>4 .2 Vector</h2><p>Vector 是矢量队列 ，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。 Vector 继承了AbstractList，实现了List；所以， 它是一个队列，支持相关的添加、删除、修改、遍历等功能 。 Vector 实现了RandmoAccess接口，即 提供了随机访问功能 。</p><p>RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。</p><p>&#x3D;&#x3D;和ArrayList不同，Vector中的操作是线程安全的。&#x3D;&#x3D;</p><p>NotSafeDemo代码修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 集合线程安全案例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">list.add(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在没有运行出现并发异常,为什么?</p><p>查看Vector的add方法</p><p>&#x2F;**</p><ul><li>Appends the specified element to the end of this Vector.</li><li></li><li>@param e element to be appended to this Vector</li><li>@return {@code true} (as specified by {@link Collection#add})</li><li>@since 1.2<br>*&#x2F;<br>public synchronized boolean add(E e) {<br>modCount++;<br>ensureCapacityHelper(elementCount + 1 );<br>elementData[elementCount++] &#x3D; e;<br>return true;</li><li>}</li></ul><p>add方法被synchronized同步修辞,线程安全!因此没有并发异常</p><h2 id="4-3-Collections"><a href="#4-3-Collections" class="headerlink" title="4 .3 Collections"></a>4 .3 Collections</h2><p>Collections提供了方法synchronizedList保证list是同步线程安全的</p><h4 id="NotSafeDemo代码修改"><a href="#NotSafeDemo代码修改" class="headerlink" title="NotSafeDemo代码修改"></a>NotSafeDemo代码修改</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 集合线程安全案例</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line">  list.add(UUID.randomUUID().toString());</span><br><span class="line">  System.out.println(list);</span><br><span class="line">  &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>没有并发修改异常</p><p>查看方法源码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line">* Returns a synchronized (thread-safe) list backed by the specified</span><br><span class="line"></span><br><span class="line">* list. In order to guarantee serial access, it is critical that</span><br><span class="line"></span><br><span class="line">* &lt;strong&gt;all&lt;/strong&gt; access to the backing list is accomplished</span><br><span class="line"></span><br><span class="line">* through the returned list.&lt;p&gt;</span><br><span class="line">  *</span><br><span class="line"></span><br><span class="line">* It is imperative that the user manually synchronize on the returned</span><br><span class="line"></span><br><span class="line">* list when iterating over it:</span><br><span class="line"></span><br><span class="line">* &lt;pre&gt;</span><br><span class="line"></span><br><span class="line">* List list = Collections.synchronizedList(new ArrayList());</span><br><span class="line"></span><br><span class="line">* ...</span><br><span class="line"></span><br><span class="line">* synchronized (list) &#123;</span><br><span class="line"></span><br><span class="line">* Iterator i = list.iterator(); // Must be in synchronized block</span><br><span class="line"></span><br><span class="line">* while (i.hasNext())</span><br><span class="line"></span><br><span class="line">* foo(i.next());</span><br><span class="line"></span><br><span class="line">* &#125;</span><br><span class="line"></span><br><span class="line">* &lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">* Failure to follow this advice may result in non-deterministic behavior.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### *</span><br><span class="line">* &lt;p&gt;The returned list will be serializable if the specified list is</span><br><span class="line">* serializable.</span><br><span class="line">*</span><br><span class="line">* @param &lt;T&gt; the class of the objects in the list</span><br><span class="line">* @param list the list to be &quot;wrapped&quot; in a synchronized list.</span><br><span class="line">* @return a synchronized view of the specified list.</span><br><span class="line">*/</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class="line">return (list instanceof RandomAccess?</span><br><span class="line">new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">new SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-CopyOnWriteArrayList-重点"><a href="#4-4-CopyOnWriteArrayList-重点" class="headerlink" title="4 .4 CopyOnWriteArrayList(重点)"></a>4 .4 CopyOnWriteArrayList(重点)</h2><p>首先我们对CopyOnWriteArrayList进行学习,其特点如下:</p><p>它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和ArrayList不同的时，它具有以下特性：</p><ol><li><p>它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。</p></li><li><p>它是线程安全的。</p></li><li><p>因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove()等等）的开销很大。</p></li><li><p>迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</p></li><li><p>使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。</p></li><li><p>独占锁效率低：采用读写分离思想解决</p></li><li><p>写线程获取到锁，其他写线程阻塞</p></li><li><p>复制思想：</p></li></ol><p>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写回内存，其他的线程就会读到了脏数据。</p><p>&#x3D;&#x3D; 这就是CopyOnWriteArrayList 的思想和原理。就是拷贝一份。 &#x3D;&#x3D;</p><p>NotSafeDemo代码修改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 集合线程安全案例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 多个线程同时对集合进行修改</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>();</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"></span><br><span class="line">#### list.add(UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">#### System.out.println(list);</span><br><span class="line"></span><br><span class="line">#### &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### </span><br></pre></td></tr></table></figure><p>没有线程安全问题</p><p>原因分析 ( 重点 ):</p><p>&#x3D;&#x3D; 动态数组与线程安全 &#x3D;&#x3D;</p><p>下面从“动态数组”和“线程安全”两个方面进一步对CopyOnWriteArrayList的原理进行说明。</p><p><strong>“动态数组”机制</strong></p><p>它内部有个“volatile数组”(array)来保持数据。在“添加&#x2F;修改&#x2F;删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile数组”, 这就是它叫做CopyOnWriteArrayList的原因。由于它在“添加&#x2F;修改&#x2F;删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList效率很低；但是单单只是进行遍历查找的话，效率比较高。</p><ul><li><strong>“线程安全”机制</strong></li></ul><p>通过volatile和互斥锁来实现的。</p><p>通过“volatile数组”来保存数据的。一个线程读取volatile数组时，总能看到其它线程对该volatile变量最后的写入；就这样，通过volatile提供了“读取到的数据总是最新的”这个机制的保证。</p><p>通过互斥锁来保护数据。在“添加&#x2F;修改&#x2F;删除”数据时，会先“获取互斥锁”，再修改完毕之后，先将数据更新到“volatile数组”中，然后再“释放互斥锁”，就达到了保护数据的目的。</p><h2 id="4-5-小结-重点"><a href="#4-5-小结-重点" class="headerlink" title="4 .5 小结(重点)"></a>4 .5 小结(重点)</h2><p>1.线程安全与线程不安全集合</p><p>集合类型中存在线程安全与线程不安全的两种,常见例如:</p><p>ArrayList —– Vector</p><p>HashMap —–HashTable</p><p>但是以上都是通过synchronized关键字实现,效率较低</p><p>2.Collections构建的线程安全集合</p><p>3.java.util.concurrent并发包下</p><p>CopyOnWriteArrayList CopyOnWriteArraySet类型,通过动态数组与线程安全的方面保证线程安全</p><h1 id="5-多线程锁"><a href="#5-多线程锁" class="headerlink" title="5 多线程锁"></a>5 多线程锁</h1><h2 id="5-1-锁的八个问题演示"><a href="#5-1-锁的八个问题演示" class="headerlink" title="5 .1 锁的八个问题演示"></a>5 .1 锁的八个问题演示</h2><p>class  Phone {</p><p><strong>public static synchronized void</strong> sendSMS() <strong>throws</strong> Exception {<br><em>&#x2F;&#x2F;</em> 停留 <em>4</em> 秒<br>TimeUnit. <strong><em>SECONDS</em></strong> .sleep( 4 );<br>System. <strong><em>out</em></strong> .println( <strong>“——sendSMS”</strong> );<br>}</p><p><strong>public synchronized void</strong> sendEmail() <strong>throws</strong> Exception {<br>System. <strong><em>out</em></strong> .println( <strong>“——sendEmail”</strong> );<br>}</p><p><strong>public void</strong> getHello() {<br>System. <strong><em>out</em></strong> .println( <strong>“——getHello”</strong> );<br>}<br>}<br>&#x2F;**</p><ul><li><strong>@Description:</strong> 8 锁</li><li>1 标准访问，先打印短信还是邮件<br>——sendSMS<br>——sendEmail</li></ul><p>2 停 4 秒在短信方法内，先打印短信还是邮件<br>——sendSMS<br>——sendEmail</p><p>3 新增普通的hello方法，是先打短信还是hello<br>——getHello<br>——sendSMS</p><p>4 现在有两部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p><p>5 两个静态同步方法， 1 部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail</p><p>6 两个静态同步方法， 2 部手机，先打印短信还是邮件</p><p>——sendSMS<br>——sendEmail</p><p>7 1个静态同步方法,1个普通同步方法， 1 部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p><p>8 1个静态同步方法,1个普通同步方法， 2 部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p><p><strong>结论:</strong></p><p>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized方法加个普通方法后发现和同步锁无关<br>换成两个对象后，不是同一把锁了，情况立刻变化。<br>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。</p><p>具体表现为以下 3 种形式。<br>对于普通同步方法，锁是当前实例对象。<br>对于静态同步方法，锁是当前类的Class对象。<br>对于同步方法块，锁是Synchonized括号里配置的对象</p><p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。<br>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</p><h1 id="6-Callable-Future-接口"><a href="#6-Callable-Future-接口" class="headerlink" title="6 Callable&amp;Future 接口"></a>6 Callable&amp;Future 接口</h1><h2 id="6-1-Callable接口"><a href="#6-1-Callable接口" class="headerlink" title="6 .1 Callable接口"></a>6 .1 Callable接口</h2><p>目前我们学习了有两种创建线程的方法-一种是通过创建Thread类，另一种是通过使用Runnable创建线程。但是，Runnable缺少的一项功能是，当线程终止时（即run（）完成时），我们无法使线程返回结果。为了支持此功能，Java中提供了Callable接口。</p><p>&#x3D;&#x3D; 现在我们学习的是创建线程的第三种方案—Callable接口 &#x3D;&#x3D;</p><p>Callable接口的特点如下(重点)</p><ul><li><p>为了实现Runnable，需要实现不返回任何内容的run（）方法，而对于Callable，需要实现在完成时返回结果的call（）方法。</p></li><li><p>call（）方法可以引发异常，而run（）则不能。</p></li><li><p>为实现Callable而必须重写call方法</p></li><li><p>不能直接替换runnable,因为Thread类的构造方法根本没有Callable</p></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建新类MyThread实现runnable接口</span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">新类MyThread2实现callable接口</span><br><span class="line">class MyThread2 implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">public Integer call() throws Exception &#123;</span><br><span class="line">return 200 ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-Future接口"><a href="#6-2-Future接口" class="headerlink" title="6 .2 Future接口"></a>6 .2 Future接口</h2><p>当call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用Future对象。</p><p>将Future视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable返回）。Future基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:</p><ul><li><strong>public boolean cancel（boolean mayInterrupt）：</strong> 用于停止任务。</li></ul><p>&#x3D;&#x3D;如果尚未启动，它将停止任务。如果已启动，则仅在mayInterrupt为true时才会中断任务。&#x3D;&#x3D;</p><ul><li><strong>public Object get（）抛出InterruptedException，ExecutionException：</strong>用于获取任务的结果。</li></ul><p>&#x3D;&#x3D;如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。&#x3D;&#x3D;</p><ul><li><strong>public boolean isDone（）：</strong> 如果任务完成，则返回true，否则返回false</li></ul><p>可以看到Callable和Future做两件事-Callable与Runnable类似，因为它封装了要在另一个线程上运行的任务，而Future用于存储从另一个线程获得的结果。实际上，future也可以与Runnable一起使用。要创建线程，需要Runnable。为了获得结果，需要future。</p><h2 id="6-3-FutureTask"><a href="#6-3-FutureTask" class="headerlink" title="6. 3 FutureTask"></a>6. 3 FutureTask</h2><p>Java库具有具体的FutureTask类型，该类型实现Runnable和Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供Callable来创建FutureTask。然后，将FutureTask对象提供给Thread的构造函数以创建Thread对象。因此，间接地使用Callable创建线程。</p><h4 id="核心原理-重点"><a href="#核心原理-重点" class="headerlink" title="核心原理:(重点)"></a>核心原理:(重点)</h4><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成</p><ul><li><p>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态</p></li><li><p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p></li><li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</p></li><li><p>一旦计算完成，就不能再重新开始或取消计算</p></li><li><p>get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常</p></li><li><p>get只计算一次,因此get方法放到最后</p></li></ul><h4 id="demo案例"><a href="#demo案例" class="headerlink" title="demo案例"></a>demo案例</h4><h2 id="6-4-使用Callable和Future"><a href="#6-4-使用Callable和Future" class="headerlink" title="6. 4 使用Callable和Future"></a>6. 4 使用Callable和Future</h2><h4 id="CallableDemo案例"><a href="#CallableDemo案例" class="headerlink" title="CallableDemo案例"></a>CallableDemo案例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* CallableDemo案列</span><br><span class="line">*/</span><br><span class="line">public class CallableDemo &#123;</span><br><span class="line">/**</span><br><span class="line">* 实现runnable接口</span><br><span class="line">*/</span><br><span class="line">static class MyThread1 implements Runnable&#123;</span><br><span class="line">/**</span><br><span class="line">* run方法</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">##### </span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;线程进入了run</span><br><span class="line">方法&quot;);</span><br><span class="line"></span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">##### /**</span><br><span class="line"></span><br><span class="line">* 实现callable接口</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">static class MyThread2 implements Callable&#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line">* call方法</span><br><span class="line"></span><br><span class="line">* @return</span><br><span class="line"></span><br><span class="line">* @throws Exception</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"></span><br><span class="line">public Long call() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;线程进入了call</span><br><span class="line">方法,开始准备睡觉&quot;);</span><br><span class="line"></span><br><span class="line">Thread.sleep(1000);</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;睡醒了&quot;);</span><br><span class="line"></span><br><span class="line">&#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">//声明runable</span><br><span class="line">Runnable runable = new MyThread1();</span><br><span class="line">//声明callable</span><br><span class="line">Callable callable = new MyThread2();</span><br><span class="line">//future-callable</span><br><span class="line">FutureTask&lt;Long&gt; futureTask2 = new FutureTask(callable);</span><br><span class="line">//线程二</span><br><span class="line">new Thread(futureTask2, &quot;线程二&quot;).start();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">Long result1 = futureTask2.get();</span><br><span class="line">System.out.println(result1);</span><br><span class="line">&#125;</span><br><span class="line">//线程一</span><br><span class="line">new Thread(runable,&quot;线程一&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-小结-重点"><a href="#6-5-小结-重点" class="headerlink" title="6. 5 小结(重点)"></a>6. 5 小结(重点)</h2><ul><li><p>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成, 当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态</p></li><li><p>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去</p></li></ul><h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><ul><li><p>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</p></li><li><p>只计算一次</p></li></ul><h1 id="7-JUC-三大辅助类"><a href="#7-JUC-三大辅助类" class="headerlink" title="7 JUC 三大辅助类"></a>7 JUC 三大辅助类</h1><p>JUC中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过多时Lock锁的频繁操作。这三种辅助类为：</p><ul><li>CountDownLatch: 减少计数</li><li>CyclicBarrier: 循环栅栏</li><li>Semaphore: 信号灯</li></ul><p>下面我们分别进行详细的介绍和学习</p><h2 id="7-1-减少计数CountDownLatch"><a href="#7-1-减少计数CountDownLatch" class="headerlink" title="7 .1 减少计数CountDownLatch"></a>7 .1 减少计数CountDownLatch</h2><p>CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行减 1 的操作，使用await方法等待计数器不大于 0 ，然后继续执行await方法之后的语句。</p><ul><li><p>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞</p></li><li><p>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)</p></li><li><p>当计数器的值变为 0 时，因await方法阻塞的线程会被唤醒，继续执行</p></li></ul><h4 id="场景-6个同学陆续离开教室后值班同学才可以关门。"><a href="#场景-6个同学陆续离开教室后值班同学才可以关门。" class="headerlink" title="场景: 6个同学陆续离开教室后值班同学才可以关门。"></a>场景: 6个同学陆续离开教室后值班同学才可以关门。</h4><p>CountDownLatchDemo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* CountDownLatchDemo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 6个同学陆续离开教室后值班同学才可以关门</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个数值为 6 的计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">##### <span class="comment">//创建 6 个同学</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;同学6&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计数器减一,不会阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">countDownLatch.countDown();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;同学&quot;</span> + i).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主线程await休息</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;主线程睡觉&quot;</span>);</span><br><span class="line"></span><br><span class="line">countDownLatch.await();</span><br><span class="line"></span><br><span class="line"><span class="comment">//全部离开后自动唤醒主线程</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;全部离开了,现在的计数器为&quot;</span> +</span><br><span class="line">countDownLatch.getCount());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-循环栅栏CyclicBarrier"><a href="#7-2-循环栅栏CyclicBarrier" class="headerlink" title="7 .2 循环栅栏CyclicBarrier"></a>7 .2 循环栅栏CyclicBarrier</h2><p>CyclicBarrier看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier.await()之后的语句。可以将CyclicBarrier理解为加 1 操作</p><h4 id="场景-集齐-7-颗龙珠就可以召唤神龙"><a href="#场景-集齐-7-颗龙珠就可以召唤神龙" class="headerlink" title="场景: 集齐 7 颗龙珠就可以召唤神龙"></a>场景: 集齐 7 颗龙珠就可以召唤神龙</h4><p>CyclicBarrierDemo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* CyclicBarrierDemo案列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">//定义神龙召唤需要的龙珠总数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 集齐 7 颗龙珠就可以召唤神龙</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义循环栅栏</span></span><br><span class="line"></span><br><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(NUMBER, () -&gt;&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;集齐&quot;</span> + NUMBER + <span class="string">&quot;颗龙珠,现在召唤神龙!!!!!!!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 7 个线程分别去收集龙珠</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;龙珠 3 号&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;龙珠 3 号抢夺战开始,孙悟空开启超级赛亚人模式!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;龙珠 3 号抢夺战结束,孙悟空打赢了,拿到了龙珠 3</span></span><br><span class="line"><span class="string">号!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;收集到</span></span><br><span class="line"><span class="string">了!!!!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cyclicBarrier.await();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;龙珠&quot;</span> + i + <span class="string">&quot;号&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3-信号灯Semaphore"><a href="#7-3-信号灯Semaphore" class="headerlink" title="7 .3 信号灯Semaphore"></a>7 .3 信号灯Semaphore</h2><p>Semaphore的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用acquire方法获得许可证，release方法释放许可</p><h4 id="场景-抢车位-6部汽车-3-个停车位"><a href="#场景-抢车位-6部汽车-3-个停车位" class="headerlink" title="场景: 抢车位, 6部汽车 3 个停车位"></a>场景: 抢车位, 6部汽车 3 个停车位</h4><p>SemaphoreDemo</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* Semaphore案列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 抢车位, 10部汽车 1 个停车位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义 3 个停车位</span></span><br><span class="line"></span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟 6 辆汽车停车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//停车</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt;&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;找车位ing&quot;</span>);</span><br><span class="line"></span><br><span class="line">semaphore.acquire();</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;汽车停车成</span></span><br><span class="line"><span class="string">功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;溜了溜了&quot;</span>);</span><br><span class="line"></span><br><span class="line">semaphore.release();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;汽车&quot;</span> + i).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### &#125;</span><br><span class="line"></span><br><span class="line">##### &#125;</span><br><span class="line"></span><br><span class="line">##### &#125;</span><br></pre></td></tr></table></figure><h1 id="8-读写锁"><a href="#8-读写锁" class="headerlink" title="8 读写锁"></a>8 读写锁</h1><h2 id="8-1-读写锁介绍"><a href="#8-1-读写锁介绍" class="headerlink" title="8 .1 读写锁介绍"></a>8 .1 读写锁介绍</h2><p>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。</p><p>针对这种场景， JAVA的并发包提供了读写锁ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</p><h4 id="1-线程进入读锁的前提条件："><a href="#1-线程进入读锁的前提条件：" class="headerlink" title="1. 线程进入读锁的前提条件："></a>1. 线程进入读锁的前提条件：</h4><ul><li>没有其他线程的写锁</li><li>没有写请求, 或者&#x3D;&#x3D;有写请求，但调用线程和持有锁的线程是同一个(可重入锁)。&#x3D;&#x3D;</li></ul><h4 id="2-线程进入写锁的前提条件："><a href="#2-线程进入写锁的前提条件：" class="headerlink" title="2. 线程进入写锁的前提条件："></a>2. 线程进入写锁的前提条件：</h4><ul><li>没有其他线程的读锁</li><li>没有其他线程的写锁</li></ul><p>而读写锁有以下三个重要的特性：</p><p>（ 1 ）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</p><p>（ 2 ）重进入：读锁和写锁都支持线程重进入。</p><p>（ 3 ）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。</p><h2 id="8-2-ReentrantReadWriteLock"><a href="#8-2-ReentrantReadWriteLock" class="headerlink" title="8 .2 ReentrantReadWriteLock"></a>8 .2 ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 类的整体结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title class_">ReadWriteLock</span>, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用给定的公平策略创建一个新的 ReentrantReadWriteLock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line"></span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line"></span><br><span class="line">        readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回用于写入操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> writerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回用于读取操作的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.ReadLock <span class="title function_">readLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readerLock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看到ReentrantReadWriteLock实现了自己的序列化逻辑。</p><h2 id="8-3-入门案例"><a href="#8-3-入门案例" class="headerlink" title="8 .3 入门案例"></a>8 .3 入门案例</h2><p>场景: 使用ReentrantReadWriteLock 对一个hashmap进行读和写操作</p><h4 id="8-3-1-实现案例"><a href="#8-3-1-实现案例" class="headerlink" title="8 .3.1 实现案例"></a>8 .3.1 实现案例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 资源类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCache</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 map 集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建读写锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加写锁</span></span><br><span class="line">        rwLock.writeLock().lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + key);</span><br><span class="line">            <span class="comment">// 暂停一会</span></span><br><span class="line">            TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            <span class="comment">// 放数据</span></span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放写锁</span></span><br><span class="line">            rwLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加读锁</span></span><br><span class="line">        rwLock.readLock().lock();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;</span></span><br><span class="line"><span class="string">                    &quot;</span> +key);</span><br><span class="line">                    <span class="comment">// 暂停一会</span></span><br><span class="line">                    TimeUnit.MICROSECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;</span></span><br><span class="line"><span class="string">                    &quot;</span> +key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line">            rwLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-小结-重要"><a href="#8-4-小结-重要" class="headerlink" title="8. 4 小结(重要)"></a>8. 4 小结(重要)</h2><ul><li><p>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p></li><li><p>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p></li></ul><p>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</p><h1 id="9-阻塞队列"><a href="#9-阻塞队列" class="headerlink" title="9 阻塞队列"></a>9 阻塞队列</h1><h2 id="9-1-BlockingQueue简介"><a href="#9-1-BlockingQueue简介" class="headerlink" title="9 .1 BlockingQueue简介"></a>9 .1 BlockingQueue简介</h2><p>Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；当队列是空的，从队列中获取元素的操作将会被阻塞，当队列是满的，从队列中添加元素的操作将会被阻塞。试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</p><h4 id="常用的队列主要有以下两种："><a href="#常用的队列主要有以下两种：" class="headerlink" title="常用的队列主要有以下两种："></a>常用的队列主要有以下两种：</h4><ul><li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。</li></ul><h4 id="从某种程度上来说这种队列也体现了一种公平性"><a href="#从某种程度上来说这种队列也体现了一种公平性" class="headerlink" title="从某种程度上来说这种队列也体现了一种公平性"></a>从某种程度上来说这种队列也体现了一种公平性</h4><ul><li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发生的事件(栈)</li></ul><h5 id="在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起"><a href="#在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起" class="headerlink" title="在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起"></a>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</h5><p>为什么需要BlockingQueue？</p><p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p><p>​在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</p><p>​多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。</p><ul><li><p>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列</p></li><li><p>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒</p></li></ul><h2 id="9-2-BlockingQueue核心方法"><a href="#9-2-BlockingQueue核心方法" class="headerlink" title="9 .2 BlockingQueue核心方法"></a>9 .2 BlockingQueue核心方法</h2><p>![image-20230220142456775](&#x2F;Users&#x2F;dongnan&#x2F;Desktop&#x2F;code&#x2F;Note&#x2F;JUC笔记&#x2F;分析图&#x2F;BlockingQueue 核心方法.png)</p><h4 id="BlockingQueue的核心方法-："><a href="#BlockingQueue的核心方法-：" class="headerlink" title="BlockingQueue的核心方法 ："></a>BlockingQueue的核心方法 ：</h4><h4 id="1-放入数据"><a href="#1-放入数据" class="headerlink" title="1.放入数据"></a>1.放入数据</h4><ul><li><p>offer(anObject):表示如果可能的话,将an Object加到BlockingQueue里,即如果BlockingQueue可以容纳,则返回true,否则返回false. （本方法不阻塞当前执行方法的线程）</p></li><li><p>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入BlockingQueue，则返回失败</p></li><li><p>put(anObject):把an Object加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</p></li></ul><h4 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h4><ul><li><p>poll(time): 取走BlockingQueue里排在首位的对象,若不能立即取出, 则可以等time参数规定的时间,取不到时返回null</p></li><li><p>poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。</p></li><li><p>take(): 取走BlockingQueue里排在首位的对象,若BlockingQueue为空, <strong>阻断进入等待状态直到BlockingQueue有新的数据被加入</strong> ;</p></li><li><p>drainTo(): 一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p></li></ul><h2 id="9-3-入门案例"><a href="#9-3-入门案例" class="headerlink" title="9 .3 入门案例"></a>9 .3 入门案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 阻塞队列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockingQueueDemo</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="comment">// List list = new ArrayList();</span></span><br><span class="line"></span><br><span class="line">BlockingQueue&lt;String&gt; blockingQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;( <span class="number">3</span> );</span><br><span class="line"><span class="comment">//第一组</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.element());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(blockingQueue.add(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.remove());</span></span><br><span class="line"><span class="comment">// 第二组</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.offer(&quot;x&quot;));</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.poll());</span></span><br><span class="line"><span class="comment">// 第三组</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">// blockingQueue.put(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">// //blockingQueue.put(&quot;x&quot;);</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"><span class="comment">// System.out.println(blockingQueue.take());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四组</span></span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;b&quot;</span>));</span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;c&quot;</span>));</span><br><span class="line">System.out.println(blockingQueue.offer(<span class="string">&quot;a&quot;</span>,<span class="number">3L</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### &#125;</span><br><span class="line"></span><br><span class="line">##### &#125;</span><br></pre></td></tr></table></figure><h2 id="9-4-常见的BlockingQueue"><a href="#9-4-常见的BlockingQueue" class="headerlink" title="9 .4 常见的BlockingQueue"></a>9 .4 常见的BlockingQueue</h2><h3 id="9-4-1-ArrayBlockingQueue-常用"><a href="#9-4-1-ArrayBlockingQueue-常用" class="headerlink" title="9 .4.1 ArrayBlockingQueue(常用)"></a>9 .4.1 ArrayBlockingQueue(常用)</h3><p>​基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p>​ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><h4 id="一句话总结-由数组结构组成的有界阻塞队列。"><a href="#一句话总结-由数组结构组成的有界阻塞队列。" class="headerlink" title="&#x3D;&#x3D;一句话总结: 由数组结构组成的有界阻塞队列。&#x3D;&#x3D;"></a>&#x3D;&#x3D;一句话总结: 由数组结构组成的有界阻塞队列。&#x3D;&#x3D;</h4><h4 id="9-4-2-LinkedBlockingQueue-常用"><a href="#9-4-2-LinkedBlockingQueue-常用" class="headerlink" title="9 .4.2 LinkedBlockingQueue(常用)"></a>9 .4.2 LinkedBlockingQueue(常用)</h4><p>​基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。</p><p>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。</p><h4 id="一句话总结-由链表结构组成的有界（但大小默认值为integer-MAX-VALUE）阻塞队列。"><a href="#一句话总结-由链表结构组成的有界（但大小默认值为integer-MAX-VALUE）阻塞队列。" class="headerlink" title="&#x3D;&#x3D;一句话总结: 由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。&#x3D;&#x3D;"></a>&#x3D;&#x3D;一句话总结: 由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。&#x3D;&#x3D;</h4><h4 id="9-4-3-DelayQueue"><a href="#9-4-3-DelayQueue" class="headerlink" title="9.4.3 DelayQueue"></a>9.4.3 DelayQueue</h4><p>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><h4 id="一句话总结-使用优先级队列实现的延迟无界阻塞队列。"><a href="#一句话总结-使用优先级队列实现的延迟无界阻塞队列。" class="headerlink" title="&#x3D;&#x3D;一句话总结: 使用优先级队列实现的延迟无界阻塞队列。&#x3D;&#x3D;"></a>&#x3D;&#x3D;一句话总结: 使用优先级队列实现的延迟无界阻塞队列。&#x3D;&#x3D;</h4><h4 id="9-4-4-PriorityBlockingQueue"><a href="#9-4-4-PriorityBlockingQueue" class="headerlink" title="9.4.4 PriorityBlockingQueue"></a>9.4.4 PriorityBlockingQueue</h4><p>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue&#x3D;&#x3D;并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者&#x3D;&#x3D;。</p><p>因此使用的时候要特别注意， &#x3D;&#x3D;生产者生产数据的速度绝对不能快于消费者消费数据的速度&#x3D;&#x3D; ，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是 公平锁 。</p><h4 id="一句话总结-支持优先级排序的无界阻塞队列。"><a href="#一句话总结-支持优先级排序的无界阻塞队列。" class="headerlink" title="&#x3D;&#x3D;一句话总结: 支持优先级排序的无界阻塞队列。&#x3D;&#x3D;"></a>&#x3D;&#x3D;一句话总结: 支持优先级排序的无界阻塞队列。&#x3D;&#x3D;</h4><h4 id="9-4-5-SynchronousQueue"><a href="#9-4-5-SynchronousQueue" class="headerlink" title="9 .4.5 SynchronousQueue"></a>9 .4.5 SynchronousQueue</h4><p>​一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。</p><p>​声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。</p><h4 id="公平模式和非公平模式的区别"><a href="#公平模式和非公平模式的区别" class="headerlink" title="公平模式和非公平模式的区别:"></a>公平模式和非公平模式的区别:</h4><ul><li><p>公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；</p></li><li><p>非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p></li></ul><h4 id="一句话总结-不存储元素的阻塞队列，也即单个元素的队列。"><a href="#一句话总结-不存储元素的阻塞队列，也即单个元素的队列。" class="headerlink" title="&#x3D;&#x3D;一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。&#x3D;&#x3D;"></a>&#x3D;&#x3D;一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。&#x3D;&#x3D;</h4><h4 id="9-4-6-LinkedTransferQueue"><a href="#9-4-6-LinkedTransferQueue" class="headerlink" title="9.4.6 LinkedTransferQueue"></a>9.4.6 LinkedTransferQueue</h4><p>​LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。</p><h4 id="一句话总结-由链表组成的无界阻塞队列。"><a href="#一句话总结-由链表组成的无界阻塞队列。" class="headerlink" title="&#x3D;&#x3D;一句话总结: 由链表组成的无界阻塞队列。&#x3D;&#x3D;"></a>&#x3D;&#x3D;一句话总结: 由链表组成的无界阻塞队列。&#x3D;&#x3D;</h4><h4 id="9-4-7-LinkedBlockingDeque"><a href="#9-4-7-LinkedBlockingDeque" class="headerlink" title="9.4.7 LinkedBlockingDeque"></a>9.4.7 LinkedBlockingDeque</h4><p>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况</p><ul><li><p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出InterruptedException异常</p></li><li><p>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p></li></ul><h4 id="一句话总结-由链表组成的双向阻塞队列"><a href="#一句话总结-由链表组成的双向阻塞队列" class="headerlink" title="&#x3D;&#x3D;一句话总结: 由链表组成的双向阻塞队列&#x3D;&#x3D;"></a>&#x3D;&#x3D;一句话总结: 由链表组成的双向阻塞队列&#x3D;&#x3D;</h4><h4 id="9-5-小结"><a href="#9-5-小结" class="headerlink" title="9 .5 小结"></a>9 .5 小结</h4><ol><li><p>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起</p></li><li><p>为什么需要BlockingQueue? 在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p></li></ol><h1 id="10-ThreadPool-线程池"><a href="#10-ThreadPool-线程池" class="headerlink" title="10 ThreadPool 线程池"></a>10 ThreadPool 线程池</h1><h4 id="10-1-线程池简介"><a href="#10-1-线程池简介" class="headerlink" title="10 .1 线程池简介"></a>10 .1 线程池简介</h4><p>​线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</p><p>​例子： 10 年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需要来回切换。 现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换效率高。</p><p>​线程池的优势： 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p><p>它的主要特点为：</p><ul><li><p>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</p></li><li><p>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</p></li><li><p>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p></li><li><p>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类</p></li></ul><h4 id="10-2-线程池参数说明"><a href="#10-2-线程池参数说明" class="headerlink" title="10 .2 线程池参数说明"></a>10 .2 线程池参数说明</h4><p>本次介绍 5 种类型的线程池</p><h4 id="10-2-1常用参数-重点"><a href="#10-2-1常用参数-重点" class="headerlink" title="10 .2.1常用参数(重点)"></a>10 .2.1常用参数(重点)</h4><ul><li>corePoolSize线程池的核心线程数</li><li>maximumPoolSize能容纳的最大线程数</li><li>keepAliveTime空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul><p>​线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -最大线程数</p><p>​当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。</p><p>​总结起来，也就是一句话， 当提交的任务数大于（workQueue.size() +maximumPoolSize ），就会触发线程池的拒绝策略 。</p><h4 id="10-2-2-拒绝策略-重点"><a href="#10-2-2-拒绝策略-重点" class="headerlink" title="10.2.2 拒绝策略(重点)"></a>10.2.2 拒绝策略(重点)</h4><p>​CallerRunsPolicy : 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大</p><p>​AbortPolicy : 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。</p><p>​DiscardPolicy : 直接丢弃，其他啥都没有</p><p>​DiscardOldestPolicy : 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入</p><h4 id="10-3-线程池的种类与创建"><a href="#10-3-线程池的种类与创建" class="headerlink" title="10.3 线程池的种类与创建"></a>10.3 线程池的种类与创建</h4><h4 id="10-3-1-newCachedThreadPool-常用"><a href="#10-3-1-newCachedThreadPool-常用" class="headerlink" title="10.3.1 newCachedThreadPool(常用)"></a>10.3.1 newCachedThreadPool(常用)</h4><p>作用 ：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点 :"></a>特点 :</h4><ul><li>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）</li><li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</li><li>当线程池中，没有可用线程，会重新创建一个线程</li></ul><h4 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可缓存线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * corePoolSize线程池的核心线程数</span></span><br><span class="line"><span class="comment">         * maximumPoolSize能容纳的最大线程数</span></span><br><span class="line"><span class="comment">         * keepAliveTime空闲线程存活时间</span></span><br><span class="line"><span class="comment">         * unit 存活的时间单位</span></span><br><span class="line"><span class="comment">         * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment">         * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment">         * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>,</span><br><span class="line">                                      Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>,</span><br><span class="line">                                      TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">                                      Executors.defaultThreadFactory(),</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>场景: 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景</p><h4 id="10-3-2-newFixedThreadPool-常用"><a href="#10-3-2-newFixedThreadPool-常用" class="headerlink" title="10.3.2 newFixedThreadPool(常用)"></a>10.3.2 newFixedThreadPool(常用)</h4><p>作用 ：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><p>特征：</p><ul><li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li><li>线程可以重复被使用，在显示关闭之前，都将一直存在</li><li>超出一定量的线程被提交时候需在队列中等待</li></ul><p>创建方式 ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定长度线程池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * corePoolSize线程池的核心线程数</span></span><br><span class="line"><span class="comment">         * maximumPoolSize能容纳的最大线程数</span></span><br><span class="line"><span class="comment">         * keepAliveTime空闲线程存活时间</span></span><br><span class="line"><span class="comment">         * unit 存活的时间单位</span></span><br><span class="line"><span class="comment">         * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment">         * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment">         * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">10</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0L</span>,</span><br><span class="line"></span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line"></span><br><span class="line">        Executors.defaultThreadFactory(),</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>场景: 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景</p><h4 id="10-3-3-newSingleThreadExecutor-常用"><a href="#10-3-3-newSingleThreadExecutor-常用" class="headerlink" title="10.3.3 newSingleThreadExecutor(常用)"></a>10.3.3 newSingleThreadExecutor(常用)</h4><p>作用 ：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的newFixedThreadPool不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p><p>特征： 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行</p><p>创建方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 单一线程池</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * corePoolSize线程池的核心线程数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * maximumPoolSize能容纳的最大线程数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * keepAliveTime空闲线程存活时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * unit 存活的时间单位</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * workQueue 存放提交但未执行任务的队列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * threadFactory 创建线程的工厂类:可以省略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * handler 等待队列满后的拒绝策略:可以省略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( <span class="number">1</span> ,</span><br><span class="line"></span><br><span class="line">#### <span class="number">1</span> ,</span><br><span class="line"></span><br><span class="line">#### <span class="number">0L</span>,</span><br><span class="line"></span><br><span class="line">#### TimeUnit.SECONDS,</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line"></span><br><span class="line">#### Executors.defaultThreadFactory(),</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><p>场景: 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景</p><h4 id="10-3-4-newScheduleThreadPool-了解"><a href="#10-3-4-newScheduleThreadPool-了解" class="headerlink" title="10 .3.4 newScheduleThreadPool(了解)"></a>10 .3.4 newScheduleThreadPool(了解)</h4><p>作用: 线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参数，最大线程数为整形的最大数的线程池**</p><p>特征:</p><p>（ 1 ）线程池中具有指定数量的线程，即便是空线程也将保留 （ 2 ）可定时或者延迟执行线程活动</p><p>创建方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">#### corePoolSize,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">#### ThreadFactory threadFactory)</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize,</span><br><span class="line"></span><br><span class="line">#### threadFactory);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><p>场景: 适用于需要多个后台线程执行周期任务的场景</p><h4 id="10-3-5-newWorkStealingPool"><a href="#10-3-5-newWorkStealingPool" class="headerlink" title="10 .3.5 newWorkStealingPool"></a>10 .3.5 newWorkStealingPool</h4><p>jdk1.8提供的线程池，底层使用的是ForkJoinPool实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu核数的线程来并行执行任务</p><p>创建方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* parallelism：并行级别，通常默认为JVM可用的处理器个数</span></span><br><span class="line"><span class="comment">* factory：用于创建ForkJoinPool中使用的线程。</span></span><br><span class="line"><span class="comment">* handler：用于处理工作线程未处理的异常，默认为null</span></span><br><span class="line"><span class="comment">* asyncMode：用于控制WorkQueue的工作模式:队列---反队列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism,</span><br><span class="line">ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line"><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>场景: 适用于大耗时，可并行执行的场景</p><h4 id="10-4-线程池入门案例"><a href="#10-4-线程池入门案例" class="headerlink" title="10 .4 线程池入门案例"></a>10 .4 线程池入门案例</h4><p>场景: 火车站 3 个售票口, 10个用户买票</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 入门案例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo1</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 火车站 3 个售票口, 10个用户买票</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">//定时线程次:线程数量为 3 ---窗口数为 3</span></span><br><span class="line"></span><br><span class="line">#### <span class="type">ExecutorService</span> <span class="variable">threadService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( <span class="number">3</span> ,</span><br><span class="line"></span><br><span class="line">#### <span class="number">3</span> ,</span><br><span class="line"></span><br><span class="line">#### <span class="number">60L</span>,</span><br><span class="line"></span><br><span class="line">#### TimeUnit.SECONDS,</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(),</span><br><span class="line"></span><br><span class="line">#### Executors.defaultThreadFactory(),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">//10个人买票</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= <span class="number">10</span> ; i++) &#123;</span><br><span class="line"></span><br><span class="line">#### threadService.execute(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(Thread.currentThread().getName() + <span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 窗口,开始卖票&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### Thread.sleep( <span class="number">5000</span> );</span><br><span class="line"></span><br><span class="line">#### System.out.println(Thread.currentThread().getName() + <span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 窗口买票结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">#### e.printStackTrace();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">#### e.printStackTrace();</span><br><span class="line"></span><br><span class="line">#### &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">//完成后结束</span></span><br><span class="line"></span><br><span class="line">#### threadService.shutdown();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-线程池底层工作原理-重要"><a href="#10-5-线程池底层工作原理-重要" class="headerlink" title="10 .5 线程池底层工作原理(重要)"></a>10 .5 线程池底层工作原理(重要)</h4><ol><li><p>在创建了线程池后，线程池中的线程数为零</p></li><li><p>当调用execute()方法添加一个请求任务时，线程池会做出如下判断： </p><p>2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</p><p>2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列； </p><p>2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； </p><p>2.4 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。</p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行</p></li><li><p>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</p><p>4.1 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。 </p><p>4.2所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</p></li></ol><h4 id="10-6-注意事项-重要"><a href="#10-6-注意事项-重要" class="headerlink" title="10 .6 注意事项(重要)"></a>10 .6 注意事项(重要)</h4><ol><li><p>项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是FixedThreadPool和SingleThreadExecutor底层都是用LinkedBlockingQueue实现的，这个队列最大长度为Integer.MAX_VALUE，容易导致OOM。所以实际生产一般自己通过ThreadPoolExecutor的 7 个参数，自定义线程池</p></li><li><p>创建线程池推荐适用ThreadPoolExecutor及其 7 个参数手动创建</p></li></ol><ul><li>corePoolSize线程池的核心线程数</li><li>maximumPoolSize能容纳的最大线程数</li><li>keepAliveTime空闲线程存活时间</li><li>unit 存活的时间单位</li><li>workQueue 存放提交但未执行任务的队列</li><li>threadFactory 创建线程的工厂类</li><li>handler 等待队列满后的拒绝策略</li></ul><ol start="3"><li>为什么不允许适用不允许Executors.的方式手动创建线程池,如下图</li></ol><h1 id="11-Fork-Join"><a href="#11-Fork-Join" class="headerlink" title="11 Fork&#x2F;Join"></a>11 Fork&#x2F;Join</h1><h4 id="11-1-Fork-Join框架简介"><a href="#11-1-Fork-Join框架简介" class="headerlink" title="11 .1 Fork&#x2F;Join框架简介"></a>11 .1 Fork&#x2F;Join框架简介</h4><p>Fork&#x2F;Join它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join框架要完成两件事情：</p><p>​Fork：把一个复杂任务进行分拆，大事化小<br>​Join：把分拆任务的结果进行合并</p><ol><li><p>任务分割 ：首先Fork&#x2F;Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</p></li><li><p>执行任务并合并结果 ：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。</p></li></ol><p>在Java的Fork&#x2F;Join框架中，使用两个类完成上述操作</p><ul><li><strong>ForkJoinTask</strong> :我们要使用Fork&#x2F;Join框架，首先需要创建一个ForkJoin任务。</li></ul><p>该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork&#x2F;Join框架提供了两个子类：</p><p>a.RecursiveAction：用于没有返回结果的任务</p><p>b.RecursiveTask:用于有返回结果的任务</p><ul><li><strong>ForkJoinPool</strong> :ForkJoinTask需要通过ForkJoinPool来执行</li><li><strong>RecursiveTask</strong> : 继承后可以实现递归(自己调自己)调用的任务</li></ul><p>Fork&#x2F;Join框架的实现原理</p><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放以及将程序提交给ForkJoinPool，而</p><p>ForkJoinWorkerThread负责执行这些任务。</p><h4 id="11-2-Fork方法"><a href="#11-2-Fork方法" class="headerlink" title="11 .2 Fork方法"></a>11 .2 Fork方法</h4><p>Fork方法的实现原理： 当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的 workQueue 中，异步地执行这个任务，然后立即返回结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">Thread t;</span><br><span class="line"><span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ForkJoinPool.common.externalPush(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> base, s = top, n;</span><br><span class="line"><span class="keyword">if</span> ((a = array) != <span class="literal">null</span>) &#123; <span class="comment">// ignore if queue removed</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> a.length - <span class="number">1</span> ; <span class="comment">// fenced write for task visibility</span></span><br><span class="line">U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">U.putOrderedInt(<span class="built_in">this</span>, QTOP, s + <span class="number">1</span> );</span><br><span class="line"><span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line"><span class="keyword">if</span> ((p = pool) != <span class="literal">null</span>)</span><br><span class="line">p.signalWork(p.workQueues, <span class="built_in">this</span>);<span class="comment">//执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">growArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-3-join方法"><a href="#11-3-join方法" class="headerlink" title="11 .3 join方法"></a>11 .3 join方法</h4><p>Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line"></span><br><span class="line">reportException(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getRawResult();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种：</p><p>&#x3D;&#x3D;已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）&#x3D;&#x3D;</p><ul><li>如果任务状态是已完成，则直接返回任务结果。</li><li>如果任务状态是被取消，则直接抛出CancellationException</li><li>如果任务状态是抛出异常，则直接抛出对应的异常</li></ul><p>让我们分析一下doJoin方法的实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue</span><br><span class="line"></span><br><span class="line">#### w;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span>? s :</span><br><span class="line"></span><br><span class="line">#### ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)?</span><br><span class="line"></span><br><span class="line">#### (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line"></span><br><span class="line">#### tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span>? s :</span><br><span class="line"></span><br><span class="line">#### wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :</span><br><span class="line"></span><br><span class="line">#### externalAwaitDone();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span> ) &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">#### completed = exec();</span><br><span class="line"></span><br><span class="line">#### &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">if</span> (completed)</span><br><span class="line"></span><br><span class="line">#### s = setCompletion(NORMAL);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><p>在doJoin()方法流程如下:</p><ol><li><p>首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；</p></li><li><p>如果没有执行完，则从任务数组里取出任务并执行。</p></li><li><p>如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p></li></ol><h4 id="11-4-Fork-Join框架的异常处理"><a href="#11-4-Fork-Join框架的异常处理" class="headerlink" title="11 .4 Fork&#x2F;Join框架的异常处理"></a>11 .4 Fork&#x2F;Join框架的异常处理</h4><p>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p><h4 id="11-5-入门案例"><a href="#11-5-入门案例" class="headerlink" title="11 .5 入门案例"></a>11 .5 入门案例</h4><p>场景: 生成一个计算任务，计算1+2+3………+1000 , &#x3D;&#x3D;每 100 个数切分一个子任务&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 递归累加</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExample</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Long&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> end;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskExample</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.start = start;</span><br><span class="line">  <span class="built_in">this</span>.end = end;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">* The main computation performed by this task.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Long <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;任务&quot;</span> + start + <span class="string">&quot;=========&quot;</span> + end + <span class="string">&quot;累加开始&quot;</span>);</span><br><span class="line"><span class="comment">//大于 100 个数相加切分,小于直接加</span></span><br><span class="line"><span class="keyword">if</span>(end - start &lt;= <span class="number">100</span> )&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line"><span class="comment">//累加</span></span><br><span class="line">sum += i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//切分为 2 块</span></span><br><span class="line"><span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> start + <span class="number">100</span> ;</span><br><span class="line"><span class="comment">//递归调用,切分为 2 个小任务</span></span><br><span class="line"><span class="type">TaskExample</span> <span class="variable">taskExample1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskExample</span>(start, middle);</span><br><span class="line"><span class="type">TaskExample</span> <span class="variable">taskExample2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskExample</span>(middle + <span class="number">1</span> , end);</span><br><span class="line"><span class="comment">//执行:异步</span></span><br><span class="line">taskExample1.fork();</span><br><span class="line">taskExample2.fork();</span><br><span class="line"><span class="comment">//同步阻塞获取执行结果</span></span><br><span class="line">sum = taskExample1.join() + taskExample2.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加完返回</span></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 分支合并案例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">##### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">##### * 生成一个计算任务，计算1+2+3.........+1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义任务</span></span><br><span class="line"></span><br><span class="line"><span class="type">TaskExample</span> <span class="variable">taskExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskExample</span>(<span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义执行对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入任务执行</span></span><br><span class="line"></span><br><span class="line">ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(taskExample);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(result.get());</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">forkJoinPool.shutdown();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-CompletableFuture"><a href="#12-CompletableFuture" class="headerlink" title="12 CompletableFuture"></a>12 CompletableFuture</h1><h4 id="12-1-CompletableFuture简介"><a href="#12-1-CompletableFuture简介" class="headerlink" title="12 .1 CompletableFuture简介"></a>12 .1 CompletableFuture简介</h4><p>CompletableFuture在Java里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。</p><p>CompletableFuture实现了Future, CompletionStage接口，实现了Future接口就可以兼容现在有线程池框架，而CompletionStage接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的CompletableFuture类。</p><h4 id="12-2-Future与CompletableFuture"><a href="#12-2-Future与CompletableFuture" class="headerlink" title="12 .2 Future与CompletableFuture"></a>12 .2 Future与CompletableFuture</h4><p>Futrue在Java里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个Futrue，在Future里面有isDone方法来 判断任务是否处理结束，还有get方法可以一直阻塞直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。</p><p>Future的主要缺点如下：</p><p>（ 1 ）不支持手动完成</p><p>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成</p><p>（ 2 ）不支持进一步的非阻塞调用</p><p>通过Future的get方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为Future不支持回调函数，所以无法实现这个功能</p><p>（ 3 ）不支持链式调用</p><p>对于Future的执行结果，我们想继续传到下一个Future处理使用，从而形成一个链式的pipline调用，这在Future中是没法实现的。</p><p>（ 4 ）不支持多个Future合并</p><p>比如我们有 10 个Future并行执行，我们想在所有的Future运行完毕之后，执行某些函数，是没法通过Future实现的。</p><p>（ 5 ）不支持异常处理</p><p>Future的API没有任何的异常处理的api，所以在异步运行时，如果出了问题是不好定位的。</p><h4 id="12-3-CompletableFuture入门"><a href="#12-3-CompletableFuture入门" class="headerlink" title="12 .3 CompletableFuture入门"></a>12 .3 CompletableFuture入门</h4><h4 id="12-3-1-使用CompletableFuture"><a href="#12-3-1-使用CompletableFuture" class="headerlink" title="12 .3.1 使用CompletableFuture"></a>12 .3.1 使用CompletableFuture</h4><p>场景:主线程里面创建一个CompletableFuture，然后主线程调用get方法会阻塞，最后我们在一个子线程中使其终止。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">主线程里面创建一个CompletableFuture，然后主线程调用get方法会阻塞，最后我们</span></span><br><span class="line"><span class="comment">在一个子线程中使其终止</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;子线程开始干活&quot;</span>);</span><br><span class="line"><span class="comment">//子线程睡 5 秒</span></span><br><span class="line">Thread.sleep( <span class="number">5000</span> );</span><br><span class="line"><span class="comment">//在子线程中完成主线程</span></span><br><span class="line">future.complete(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="comment">//主线程调用get方法阻塞</span></span><br><span class="line">System.out.println(<span class="string">&quot;主线程调用get方法获取结果为: &quot;</span> + future.get());</span><br><span class="line">System.out.println(<span class="string">&quot;主线程完成,阻塞结束!!!!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-2-没有返回值的异步任务"><a href="#12-3-2-没有返回值的异步任务" class="headerlink" title="12 .3.2 没有返回值的异步任务"></a>12 .3.2 没有返回值的异步任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 没有返回值的异步任务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### <span class="comment">//运行一个没有返回值的异步任务</span></span><br><span class="line"></span><br><span class="line">#### CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -</span><br><span class="line"></span><br><span class="line">#### &gt; &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;子线程启动干活&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;子线程完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">#### e.printStackTrace();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### &#125;);</span><br><span class="line"></span><br><span class="line">#### <span class="comment">//主线程阻塞</span></span><br><span class="line"></span><br><span class="line">#### future.get();</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-3-有返回值的异步任务"><a href="#12-3-3-有返回值的异步任务" class="headerlink" title="12 .3.3 有返回值的异步任务"></a>12 .3.3 有返回值的异步任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 没有返回值的异步任务</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### <span class="comment">//运行一个有返回值的异步任务</span></span><br><span class="line"></span><br><span class="line">#### CompletableFuture&lt;String&gt; future =</span><br><span class="line"></span><br><span class="line">#### CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;子线程开始任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">#### &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">#### e.printStackTrace();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> <span class="string">&quot;子线程完成了!&quot;</span>;</span><br><span class="line"></span><br><span class="line">#### &#125;);</span><br><span class="line"></span><br><span class="line">#### <span class="comment">//主线程阻塞</span></span><br><span class="line"></span><br><span class="line">#### <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> future.get();</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;主线程结束, 子线程的结果为:&quot;</span> + s);</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-4-线程依赖"><a href="#12-3-4-线程依赖" class="headerlink" title="12 .3.4 线程依赖"></a>12 .3.4 线程依赖</h4><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#### <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#### <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * 先对一个数加10,然后取平方</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#### */</span></span><br><span class="line"></span><br><span class="line">#### <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### CompletableFuture&lt;Integer&gt; future =</span><br><span class="line"></span><br><span class="line">#### CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">#### num += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">#### &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">#### e.printStackTrace();</span><br><span class="line"></span><br><span class="line">#### &#125;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">#### &#125;).thenApply(integer -&gt; &#123;</span><br><span class="line"></span><br><span class="line">#### <span class="keyword">return</span> num * num;</span><br><span class="line"></span><br><span class="line">#### &#125;);</span><br><span class="line"></span><br><span class="line">#### <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> future.get();</span><br><span class="line"></span><br><span class="line">#### System.out.println(<span class="string">&quot;主线程结束, 子线程的结果为:&quot;</span> + integer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### &#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-5-消费处理结果"><a href="#12-3-5-消费处理结果" class="headerlink" title="12 .3.5 消费处理结果"></a>12 .3.5 消费处理结果</h4><p>thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">num += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;).thenApply(integer -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num * num;</span><br><span class="line"></span><br><span class="line">&#125;).thenAccept(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;子线程全部处理完成,最后调用了accept,结果为:&quot;</span> +</span><br><span class="line">integer);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-6-异常处理"><a href="#12-3-6-异常处理" class="headerlink" title="12 .3.6 异常处理"></a>12 .3.6 异常处理</h4><h4 id="exceptionally异常处理-出现异常时触发"><a href="#exceptionally异常处理-出现异常时触发" class="headerlink" title="exceptionally异常处理,出现异常时触发"></a>exceptionally异常处理,出现异常时触发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i= <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">num += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line"></span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(ex.getMessage());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle类似于thenAccept/thenRun方法,是最后一步的处理调用,但是同时可以处理异常</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">num += <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;).handle((i,ex) -&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;进入handle方法&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(ex != <span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;发生了异常,内容为:&quot;</span> + ex.getMessage());</span><br><span class="line"><span class="keyword">return</span> - <span class="number">1</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;正常完成,内容为: &quot;</span> + i);</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-3-7-结果合并"><a href="#12-3-7-结果合并" class="headerlink" title="12 .3.7 结果合并"></a>12 .3.7 结果合并</h4><p>thenCompose合并两个有依赖关系的CompletableFutures的执行结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"><span class="comment">//第一步加 10</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">num += <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future1 = future.thenCompose(i - &gt;</span><br><span class="line"><span class="comment">//再来一个CompletableFuture</span></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span> ;</span><br><span class="line">&#125;));</span><br><span class="line">System.out.println(future.get());</span><br><span class="line">System.out.println(future1.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thenCombine合并两个没有依赖关系的CompletableFutures任务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">num += <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);</span><br><span class="line">num = num * <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//合并两个结果</span></span><br><span class="line">CompletableFuture&lt;Object&gt; future = job1.thenCombine(job2, <span class="keyword">new</span></span><br><span class="line"><span class="title class_">BiFunction</span>&lt;Integer, Integer, List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">apply</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(a);</span><br><span class="line">list.add(b);</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;合并结果为:&quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并多个任务的结果allOf与anyOf</p><p><strong>allOf:</strong> 一系列独立的future任务，等其所有的任务执行完后做一些事情</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 先对一个数加10,然后取平方</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">  List&lt;CompletableFuture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line">  num += <span class="number">10</span> ;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">  &#125;);</span><br><span class="line">  list.add(job1);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = num * <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;);</span><br><span class="line">list.add(job2);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);</span><br><span class="line">num = num * <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;);</span><br><span class="line">list.add(job3);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);</span><br><span class="line">num = num * <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;);</span><br><span class="line">list.add(job4);</span><br><span class="line"><span class="comment">//多任务合并</span></span><br><span class="line">List&lt;Integer&gt; collect =</span><br><span class="line">list.stream().map(CompletableFuture&lt;Integer&gt;::join).collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>anyOf</strong> : 只要在多个future里面有一个返回，整个任务就可以结束，而不需要等到每一个future结束</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 先对一个数加10,然后取平方</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">  CompletableFuture&lt;Integer&gt;[] futures = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[ <span class="number">4</span> ];</span><br><span class="line">  CompletableFuture&lt;Integer&gt; job1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">  Thread.sleep( <span class="number">5000</span> );</span><br><span class="line">  System.out.println(<span class="string">&quot;加 10 任务开始&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num += <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">futures[ <span class="number">0</span> ] = job1;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep( <span class="number">2000</span> );</span><br><span class="line">System.out.println(<span class="string">&quot;乘以 10 任务开始&quot;</span>);</span><br><span class="line">num = num * <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">futures[ <span class="number">1</span> ] = job2;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job3 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep( <span class="number">3000</span> );</span><br><span class="line">System.out.println(<span class="string">&quot;减以 10 任务开始&quot;</span>);</span><br><span class="line">num = num * <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">futures[ <span class="number">2</span> ] = job3;</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; job4 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep( <span class="number">4000</span> );</span><br><span class="line">System.out.println(<span class="string">&quot;除以 10 任务开始&quot;</span>);</span><br><span class="line"></span><br><span class="line">num = num * <span class="number">10</span> ;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">futures[ <span class="number">3</span> ] = job4;</span><br><span class="line">CompletableFuture&lt;Object&gt; future = CompletableFuture.anyOf(futures);</span><br><span class="line">System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM运行时内存</title>
      <link href="/2023/11/27/JVM/3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/"/>
      <url>/2023/11/27/JVM/3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JVM运行时内存区"><a href="#一、JVM运行时内存区" class="headerlink" title="一、JVM运行时内存区"></a>一、JVM运行时内存区</h1><p>JVM内存区域也被称为JVM运行时数据区，主要包含<strong>程序计数器、虚拟机栈、本地方法栈、堆空间、元数据空间（方法区）、运行时常量池、字符串常量池、直接内存（本地内存）等</strong></p><img src="9667414c527b4219b3c65a2e9bfc373b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0-1328200.awebp" alt="JVM运行时数据区" style="zoom:67%;"><h2 id="1-1、线程私有区"><a href="#1-1、线程私有区" class="headerlink" title="1.1、线程私有区"></a>1.1、线程私有区</h2><h3 id="1-1-1-、程序计数器（Progran-Counter-Register）"><a href="#1-1-1-、程序计数器（Progran-Counter-Register）" class="headerlink" title="1.1.1 、程序计数器（Progran Counter Register）"></a>1.1.1 、程序计数器（Progran Counter Register）</h3><p>​程序计数器是JVM为每条线程开辟的一块较小的区域，每条线程都有且只有一个程序计数器，线程之间不相互干扰。生命周期与线程一致，随线程启动而生，线程销毁而亡。同时也是JVM所有内存区域中唯一不会发生OOM（<code>OutOfMemoryError</code>&#x2F;内存溢出）的区域，GC机制不会触及的区域。</p><p>​&#x3D;&#x3D;主要是作为当前线程执行时的字节码行号指示器来使用的，当线程执行一个Java方法时，记录线程正在执行的字节码指令地址，当执行引擎处理完某个指令后，程序计数器需要进行对应更新，将指针改向下一条要执行的指令地址，执行引擎会根据PC计数器中记录的地址进行对应的指令执行。当线程在执行一些由<code>C/C++</code>编写的<code>Native</code>方法时，PC计数器中则为空（<code>Undefined</code>）。除此作用之外，也可以保证线程发生CPU时间片切换后能恢复到正确的位置执行&#x3D;&#x3D;。</p><h3 id="1-1-2、虚拟机栈（Stack）"><a href="#1-1-2、虚拟机栈（Stack）" class="headerlink" title="1.1.2、虚拟机栈（Stack）"></a>1.1.2、虚拟机栈（Stack）</h3><p>​栈的作用是负责程序运行时具体如何执行、如何处理数据等工作。生命周期与线程一致，每个线程创建时都会为之创建一个虚拟机栈。</p><p>​当线程在执行一个Java方法时，都会为执行的方法生产一个&#x3D;&#x3D;栈帧（StackFrame）&#x3D;&#x3D;。一个栈帧中主要包含<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p><blockquote><p>栈不存在GC，但是可能会OOM</p><p>1.如何设置栈内存大小?</p><p>​-Xss size    一般默认为512k~1024k</p></blockquote><h4 id="1-1-2-1、局部变量表"><a href="#1-1-2-1、局部变量表" class="headerlink" title="1.1.2.1、局部变量表"></a>1.1.2.1、局部变量表</h4><ul><li>定义为一个由&#x3D;&#x3D;槽（slot）&#x3D;&#x3D;数字数组，用于存放当前实例对象的引用信息、方法参数以及方法体内定义的基本数据类型变量、对象引用以及返回地址等信息</li><li>在<code>Class</code>文件的方法表的<code>Code</code>属性的<code>max_locals</code>指定了该方法所需局部变量表的最大容量。</li><li>局部变量表所容纳的大小是在编译期确定下来的</li><li>方法嵌套调用的次数是由栈的大小决定的</li><li>局部变量表的变量只在当前方法调用中有效。方法调用结束后，随着方法栈桢的销毁，局部变量表也销毁</li></ul><blockquote><p>槽（slot）：槽是局部变量表中的最小单位，规定大小为32bit，对于32bit的数据，比如int类型的变量，指针压缩后的对象信息等，都会使用一个槽来存储。而对于64bit等数据，如long、double类型的变量、未开启指针压缩的对象引用等数据，JVM会为其分配两个连续的槽空间进行存储。</p></blockquote><p>​局部变量表中存储的数据只对当前方法有效，虚拟机在执行时，依靠于操作数栈和局部变量表中存储的数据完成操作。方法执行结束后，局部变量表会随着栈桢的出栈\销毁而销毁。</p><p>​&#x3D;&#x3D;一般而言，如果当前方法属于构造方法或者实例方法，那么这些方法的局部变量表的下标为0的槽位存储的必然是this引用。&#x3D;&#x3D;</p><img src="bb75309d0656409091b720a218c97ab8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0-1397137.awebp" alt="局部变量表结构" style="zoom:67%;"><h4 id="1-1-2-2-操作数栈（Operand-Stack）"><a href="#1-1-2-2-操作数栈（Operand-Stack）" class="headerlink" title="1.1.2.2 操作数栈（Operand Stack）"></a>1.1.2.2 操作数栈（Operand Stack）</h4><p>​操作数栈是一个遵循FILO先进后出模式的栈结构。在class文件的<code>Code</code>属性的<code>max_stacks</code>定义了执行过程中最大的栈深度（在编译期就确定）。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ</title>
      <link href="/2023/11/27/RocketMQ/RocketMQ/"/>
      <url>/2023/11/27/RocketMQ/RocketMQ/</url>
      
        <content type="html"><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><strong>1、消息(Message)</strong></p><p>消息是指，消息系统所传输的物理载体，生产和消费数据的最小单位，每个消息必须属于一个主题。</p><p><strong>2、主题(Topic)</strong></p><p>Topic表示一类消息的集合，每个主题包含若干条消息，是RocketMQ进行消息订阅的基本单位。</p><p>一个生产者可以同时发送多种Topic的消息，而一个消费者只能订阅和消费一种Topic的消息</p><img src="image-20221230102324138.png" alt="image-20221230102324138" style="zoom: 50%;"><p><strong>3、标签（TAG）</strong></p><p><strong>4、队列（Queue）</strong></p><p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区。</p><p>一个Topic中Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。</p><img src="image-20221230102413690.png" alt="image-20221230102413690" style="zoom:50%;"><img src="image-20221230102441974.png" alt="image-20221230102441974" style="zoom:50%;"><p><strong>5、消息标识（MessageId&#x2F;Key）</strong></p><p>RocketMQ中每个消息都拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId(msgId)，当消息达到Broker之后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p><ul><li><p>msgId：由producer生成，其生成规则为：</p><p>producerIp + 进程pid + messageClientIDSetter的ClassLoader的hashCode + 当前时间 + AutomicInteger自增计数器</p></li><li><p>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（也就是queue中的偏移量）</p></li><li><p>key: 由用户指定的业务相关的唯一标识</p></li></ul><h3 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h3><img src="image-20221230103543148.png" alt="image-20221230103543148"><p>RocketMQ架构上主要分为四部分构成：</p><h4 id="1-Producer"><a href="#1-Producer" class="headerlink" title="1 Producer"></a>1 Producer</h4><p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p><p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p><h4 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2 Consumer"></a>2 Consumer</h4><p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。</p><p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。</p><img src="image-20221230143803679.png" alt="image-20221230143803679" style="zoom:50%;"><p>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的Consumer将不能消费消息。</p><img src="image-20221230143837912.png" alt="image-20221230143837912" style="zoom:50%;"><p>不过，一个Topic类型的消息可以被多个消费者组同时消费。</p><blockquote><p>注意， </p><p><em>1</em>）消费者组只能消费一个<em>Topic</em>的消息，不能同时消费多个<em>Topic</em>消息 </p><p><em>2</em>）一个消费者组中的消费者必须订阅完全相同的<em>Topic</em></p></blockquote><h4 id="3-Name-Server"><a href="#3-Name-Server" class="headerlink" title="3 Name Server"></a>3 Name Server</h4><p>NameServer是一个Broker和Topic路由的注册中心，支持Broker的动态注册和发现。</p><p>主要包括两个功能：</p><ul><li><p>Broker管理</p></li><li><p>路由信息管理</p></li></ul><h4 id="4-Broker"><a href="#4-Broker" class="headerlink" title="4 Broker"></a>4 Broker</h4><p>Broker充当消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求做准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。</p><img src="image-20221230154313132.png" alt="image-20221230154313132" style="zoom:50%;"><p>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。</p><p>Client Manager：客户端管理器。负责接收、解析客户端(Producer&#x2F;Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息</p><p>Store Service：存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。</p><p>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p><p>Index Service：索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。</p><h3 id="三、Linux启动"><a href="#三、Linux启动" class="headerlink" title="三、Linux启动"></a>三、Linux启动</h3><h4 id="1-启动nameServer和broker"><a href="#1-启动nameServer和broker" class="headerlink" title="1.启动nameServer和broker"></a>1.启动nameServer和broker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 启动nameServer</span></span></span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证namesrv是否启动成功</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line">The Name Server boot success...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 先启动broker</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 &amp;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/Broker.<span class="built_in">log</span></span> </span><br><span class="line">The broker[broker-a,192.169.1.2:10911] boot success...</span><br></pre></td></tr></table></figure><h4 id="2-消息收发"><a href="#2-消息收发" class="headerlink" title="2.消息收发"></a>2.消息收发</h4><p>在进行消息收发之前，我们需要告诉客户端NameServer的地址，RocketMQ有多种方式在客户端中设置NameServer地址，这里我们利用环境变量<code>NAMESRV_ADDR</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span></span><br><span class="line"> SendResult [sendStatus=SEND_OK, msgId= ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span></span><br><span class="line"><span class="meta prompt_"> ConsumeMessageThread_%</span><span class="language-bash">d Receive New Messages: [MessageExt...</span></span><br></pre></td></tr></table></figure><h4 id="docker启动"><a href="#docker启动" class="headerlink" title="docker启动"></a>docker启动</h4><p>1.拉取镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rocketmqinc/rocketmq</span><br></pre></td></tr></table></figure><p>2.创建数据挂载目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p  /docker/rocketmq/data/namesrv/logs   /docker/rocketmq/data/namesrv/store</span><br><span class="line">mkdir -p  /docker/rocketmq/data/broker/logs   /docker/rocketmq/data/broker/store /docker/rocketmq/conf</span><br></pre></td></tr></table></figure><p>3.启动nameserver</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name rmqnamesrv - -p 9876:9876 -v /Users/dongnan/devEnv/docker/rocketmq/data/namesrv/logs:/root/logs -v /Users/dongnan/devEnv/docker/rocketmq/data/namesrv/store:/root/store -e &quot;MAX_POSSIBLE_HEAP=100000000&quot; rocketmqinc/rocketmq sh mqnamesrv</span><br></pre></td></tr></table></figure><p>4.编辑配置文件</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /docker/rocketmq/conf/broker.conf</span><br><span class="line"></span><br><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">broker名称，master和slave使用相同的名称，表明他们的主从关系</span></span><br><span class="line">brokerName = broker-a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0表示Master，大于0表示不同的slave</span></span><br><span class="line">brokerId = 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示几点做消息删除动作，默认是凌晨4点</span></span><br><span class="line">deleteWhen = 04</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在磁盘上保留消息的时长，单位是小时</span></span><br><span class="line">fileReservedTime = 48</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；</span></span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；</span></span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置broker节点所在服务器的ip地址</span></span><br><span class="line">brokerIP1 = 127.0.0.1</span><br></pre></td></tr></table></figure><p>5.启动broker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d  \                                                                                   </span><br><span class="line">--restart=always \</span><br><span class="line">--name rmqbroker \</span><br><span class="line">--link rmqnamesrv:namesrv \</span><br><span class="line">-p 10911:10911 \</span><br><span class="line">-p 10909:10909 \</span><br><span class="line">-v  /Users/dongnan/devEnv/docker/rocketmq/data/broker/logs:/root/logs \</span><br><span class="line">-v  /Users/dongnan/devEnv/docker/rocketmq/data/broker/store:/root/store \</span><br><span class="line">-v  /Users/dongnan/devEnv/docker/rocketmq/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf \</span><br><span class="line">-e &quot;NAMESRV_ADDR=namesrv:9876&quot; \</span><br><span class="line">-e &quot;MAX_POSSIBLE_HEAP=200000000&quot; \</span><br><span class="line">rocketmqinc/rocketmq \</span><br><span class="line">sh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf</span><br></pre></td></tr></table></figure><p>6.部署rocketmq界面</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull styletang/rocketmq-console-ng</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080 -e &quot;JAVA_OPTS=-Drocketmq.config.namesrvAddr=rmqnamesrv:9876 -Drocketmq.config.isVIPChannel=false&quot; styletang/rocketmq-console-ng</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四、集群搭建"><a href="#四、集群搭建" class="headerlink" title="四、集群搭建"></a>四、集群搭建</h3><h4 id="1-数据复制和刷盘策略"><a href="#1-数据复制和刷盘策略" class="headerlink" title="1.数据复制和刷盘策略"></a>1.数据复制和刷盘策略</h4><img src="image-20230103111235999.png" alt="image-20230103111235999" style="zoom:50%;"><p><strong>复制策略</strong></p><p>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：</p><ul><li><p>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</p></li><li><p>异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功</p></li></ul><blockquote><p>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量</p></blockquote><p><strong>刷盘策略</strong></p><p>刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘：</p><ul><li>同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功</li><li>异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</li></ul><p><strong>最佳实践</strong></p><p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题</p><h3 id="五、工作原理"><a href="#五、工作原理" class="headerlink" title="五、工作原理"></a>五、工作原理</h3><h4 id="1-消息的生产"><a href="#1-消息的生产" class="headerlink" title="1.消息的生产"></a>1.消息的生产</h4><h5 id="消息的生产过程"><a href="#消息的生产过程" class="headerlink" title="消息的生产过程"></a>消息的生产过程</h5><p>Producer可以将消息写入到某broker中的某Queue中，过程如下</p><ul><li><p>Producer发送消息之前，会先向NameServer发出获取<code>消息Topic的路由信息</code>的请求</p></li><li><p>NameServer返回该<code>Topic的路由表</code>及<code>Broker列表</code></p></li><li><p>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</p></li><li><p>Producer对消息做一些特殊的处理，例如，消息本身超过4M，则进行压缩</p></li><li><p>Producer向选择出的Queue所在的broker发出RPC请求，将消息发送到选择出的Queue</p><blockquote><p>路由表：实际是一个Map，key为Topic的名称，value是一个QueueData实例列表，QueueData并不是一个Queue对应一个QueueData，而是一个Broker中该Topic的所有Queue对应一个QueueData。即，只要涉及到该<em>Topic</em>的<em>Broker</em>，一个<em>Broker</em>对应一个<em>QueueData</em>。<em>QueueData</em>中包含<em>brokerName</em>。简单来说，路由表的<em>key</em>为<em>Topic</em>名称，<em>value</em>则为所有涉及该<em>Topic</em>的 </p><p><em>BrokerName</em>列表。</p></blockquote><blockquote><p>一套<em>brokerName</em>名称相同的<em>Master-Slave</em>小集群对应一个 <em>BrokerData</em>。<em>BrokerData</em>中包含<em>brokerName</em>及一个<em>map</em>。该<em>map</em>的<em>key</em>为<em>brokerId</em>，<em>value</em>为该 <em>broker</em>对应的地址。<em>brokerId</em>为<em>0</em>表示该<em>broker</em>为<em>Master</em>，非<em>0</em>表示<em>Slave</em>。</p></blockquote></li></ul><h5 id="Queue选择算法"><a href="#Queue选择算法" class="headerlink" title="Queue选择算法"></a>Queue选择算法</h5><p>轮询算法</p><p>最小投递延迟算法</p><h4 id="2-消息的存储"><a href="#2-消息的存储" class="headerlink" title="2.消息的存储"></a>2.消息的存储</h4><ul><li><p>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。</p></li><li><p>checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳</p></li><li><p>commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的</p></li><li><p>config：存放着Broker运行期间的一些配置数据</p></li><li><p>consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中</p></li><li><p>index：其中存放着消息索引文件indexFile </p></li><li><p>lock：运行期间使用到的全局资源锁</p></li></ul><h4 id="3-Rebalance机制"><a href="#3-Rebalance机制" class="headerlink" title="3.Rebalance机制"></a>3.Rebalance机制</h4><p>​rebalance即再均衡，指的是，将一个topic下的多个Queue在同一个Consumer Group中的多个Consumer间进行重新分配的过程。</p><p><strong>Rebalance限制</strong></p><p>​由于⼀个队列最多分配给⼀个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列</p><h4 id="4-Queue分配算法"><a href="#4-Queue分配算法" class="headerlink" title="4.Queue分配算法"></a>4.Queue分配算法</h4><ul><li><p>平均分配策略</p><img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113458947.png" alt="image-20230209113458947" style="zoom:67%;"><p>该算法是要根据<code>avg = QueueCount / ConsumerCount</code> 的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。</p></li><li><p>环形平均策略</p><img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113715812.png" alt="image-20230209113715812" style="zoom: 50%;"><p>环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。</p></li><li><p>一致性hash策略</p><img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113809700.png" alt="image-20230209113809700" style="zoom:50%;"><p>该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。 </p></li><li><p>同机房策略</p><img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113847285.png" alt="image-20230209113847285" style="zoom:50%;"></li></ul><p>该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。</p><h2 id="六、offset管理"><a href="#六、offset管理" class="headerlink" title="六、offset管理"></a>六、offset管理</h2><p>这里的offset指的是Consumer的消费进度offset。消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p><h3 id="1-offset本地管理模式"><a href="#1-offset本地管理模式" class="headerlink" title="1 offset本地管理模式"></a>1 offset本地管理模式</h3><p>当消费模式为广播消费时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。Consumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的.rocketmq_offsets&#x2F;${clientId}&#x2F;${group}&#x2F;Offsets.json。其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。</p><h3 id="2-offset远程管理模式"><a href="#2-offset远程管理模式" class="headerlink" title="2 offset远程管理模式"></a>2 offset远程管理模式</h3><p>当消费模式为集群消费时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。Consumer在集群消费模式下offset相关数据以json的形式持久化到Broker磁盘文件中，文件路径为当前用户主目录下的store&#x2F;config&#x2F;consumerOffset.json。</p><p>Broker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。</p><p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。</p><h3 id="3-offset用途"><a href="#3-offset用途" class="headerlink" title="3 offset用途"></a>3 offset用途</h3><p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, &quot;GID_jodie_test_3&quot;);</span><br><span class="line">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(&quot;jodie_test_A&quot;, &quot;TagB&quot;, new MessageListener() &#123;</span><br><span class="line">public Action consume(Message message, ConsumeContext context) &#123;</span><br><span class="line">System.out.println(message.getMsgID());</span><br><span class="line">return Action.CommitMessage;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSUME_FROM_LAST_OFFSET：从queue的当前最后一条消息开始消费</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSUME_FROM_FIRST_OFFSET：从queue的第一条消息开始消费</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSUME_FROM_TIMESTAMP：从指定的具 体时间戳位置的消息开始消费。这个具体时间戳</span><br><span class="line">是通过另外一个语句指定的 。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeTimestamp(“20210701080000”) yyyyMMddHHmmss</span><br></pre></td></tr></table></figure><p>当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）。</p><h3 id="4-重试队列"><a href="#4-重试队列" class="headerlink" title="4 重试队列"></a>4 重试队列</h3><p>当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。</p><h3 id="5-offset的同步提交与异步提交"><a href="#5-offset的同步提交与异步提交" class="headerlink" title="5 offset的同步提交与异步提交"></a>5 offset的同步提交与异步提交</h3><p>集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：</p><p>​同步提交：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。</p><p>​异步提交：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。</p><h2 id="七、消费幂等"><a href="#七、消费幂等" class="headerlink" title="七、消费幂等"></a>七、消费幂等</h2><h3 id="1-什么是消费幂等"><a href="#1-什么是消费幂等" class="headerlink" title="1 什么是消费幂等"></a>1 什么是消费幂等</h3><p>​当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p><p>​幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p><h3 id="2-消息重复的场景分析"><a href="#2-消息重复的场景分析" class="headerlink" title="2 消息重复的场景分析"></a>2 消息重复的场景分析</h3><p>什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：</p><h4 id="发送时消息重复"><a href="#发送时消息重复" class="headerlink" title="发送时消息重复"></a>发送时消息重复</h4><p>当一条消息已被成功发送到Broker并完成持久化，此时出现了网络闪断，从而导致Broker对Producer应答失败。 如果此时Producer意识到消息发送失败并尝试再次发送消息，此时Broker中就可能会出现两条内容相同并且Message ID也相同的消息，那么后续Consumer就一定会消费两次该消息。</p><h4 id="消费时消息重复"><a href="#消费时消息重复" class="headerlink" title="消费时消息重复"></a>消费时消息重复</h4><p>消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，Broker没有接收到消费成功响应。为了保证消息至少被消费一次的原则，Broker将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。Rebalance时消息重复当Consumer Group中的Consumer数量发生变化时，或其订阅的Topic的Queue数量发生变化时，会触发Rebalance，此时Consumer可能会收到曾经被消费过的消息。</p><h3 id="3-通用解决方案"><a href="#3-通用解决方案" class="headerlink" title="3 通用解决方案"></a>3 通用解决方案</h3><p>两要素</p><p>幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。</p><p>幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。一般由Producer随着消息一同发送来的。<br>唯一性处理：服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。<br>例如，对同一笔订单的多次支付操作，只会成功一次。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>对于常见的系统，幂等性操作的通用性解决方案是：</p><ol><li><p>首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。</p></li><li><p>在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。</p></li><li><p>在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到DB中。</p></li></ol><p>第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，第 2 次判断是否重复？当然不重复。一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接就到达了DBMS。</p><h4 id="解决方案举例"><a href="#解决方案举例" class="headerlink" title="解决方案举例"></a>解决方案举例</h4><h4 id="以支付场景为例："><a href="#以支付场景为例：" class="headerlink" title="以支付场景为例："></a>以支付场景为例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 当支付请求到达后，首先在Redis缓存中却获取key为支付流水号的缓存value。若value不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若value为空，则进入下一步操作</span><br><span class="line">2. 到DBMS中根据支付流水号查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理</span><br><span class="line">3. 在分布式事务中完成三项操作：</span><br><span class="line">完成支付任务</span><br><span class="line">将当前支付流水号作为key，任意字符串作为value，通过set(key, value, expireTime)将数据写入到Redis缓存</span><br><span class="line">将当前支付流水号作为主键，与其它相关数据共同写入到DBMS</span><br></pre></td></tr></table></figure><h3 id="4-消费幂等的实现"><a href="#4-消费幂等的实现" class="headerlink" title="4 消费幂等的实现"></a>4 消费幂等的实现</h3><p>消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为Message ID有可能出现重复的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。</p><p>以支付场景为例，可以将消息的Key设置为订单号，作为幂等处理的依据。具体代码示例如下：</p><p>消费者收到消息时可以根据消息的Key即订单号来实现消费幂等：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message message = new Message();</span><br><span class="line">message.setKey(&quot;ORDERID_100&quot;);</span><br><span class="line">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>RocketMQ能够保证消息不丢失，但不能保证消息不重复。</p><h2 id="八、消息堆积与消费延迟"><a href="#八、消息堆积与消费延迟" class="headerlink" title="八、消息堆积与消费延迟"></a>八、消息堆积与消费延迟</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><p>消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多（进的多出的少），这部分消息就被称为堆积消息。消息出现堆积进而会造成消息的消费延迟。</p><p>以下场景需要重点关注消息堆积和消费延迟问题：</p><p>​业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</p><p>​业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。</p><h3 id="2-产生原因分析"><a href="#2-产生原因分析" class="headerlink" title="2 产生原因分析"></a>2 产生原因分析</h3><p>Consumer使用长轮询Pull模式消费消息时，分为以下两个阶段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt;</span><br><span class="line">msgs,</span><br><span class="line">ConsumeConcurrentlyContext</span><br><span class="line">context) &#123;</span><br><span class="line">for(MessageExt msg:msgs)&#123;</span><br><span class="line">String key = msg.getKeys();</span><br><span class="line">// 根据业务唯一标识Key做幂等处理</span><br><span class="line">// ......</span><br><span class="line">&#125;</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h4 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h4><p>Consumer通过长轮询Pull模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。</p><p>一个单线程单分区的低规格主机(Consumer，4C8G)，其可达到几万的TPS。如果是多个分区多个线程，则可以轻松达到几十万的TPS。</p><h4 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h4><p>Consumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的消费耗时和消费并发度了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由消费耗时和消费并发度决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。</p><h3 id="3-消费耗时"><a href="#3-消费耗时" class="headerlink" title="3 消费耗时"></a>3 消费耗时</h3><p>​影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型：CPU内部计算型代码和外部I&#x2F;O操作型代码。通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I&#x2F;O操作来说几乎可以忽略。所以外部IO型代码是影响消息处理时长的主要症结所在。外部IO操作型代码举例：</p><ul><li>读写外部数据库，例如对远程MySQL的访问</li><li>读写外部缓存系统，例如对远程Redis的访问</li><li>下游系统调用，例如Dubbo的RPC远程调用，Spring Cloud的对下游系统的Http接口调用</li></ul><p>关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中IO操作的耗时是否合理。通常消息堆积是由于下游系统出现了服务异常或达到了DBMS容量限制，导致消费耗时增加。服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。达到了DBMS容量限制，其也会引发消息的消费耗时增加。</p><h3 id="4-消费并发度"><a href="#4-消费并发度" class="headerlink" title="4 消费并发度"></a>4 消费并发度</h3><p>一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为单节点线程数*节点数量。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。</p><ul><li><p>单节点线程数，即单个Consumer所包含的线程数量</p></li><li><p>节点数量，即Consumer Group所包含的Consumer数量</p></li></ul><p>对于普通消息、延时消息及事务消息，并发度计算都是单节点线程数*节点数量。但对于顺序消息则是不同的。顺序消息的消费并发度等于Topic的Queue分区数量。</p><p>​1 ）全局顺序消息：该类型消息的Topic只有一个Queue分区。其可以保证该Topic的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group中在同一时刻只能有一个Consumer的一个线程进行消费。所以其并发度为 1 。</p><p>​2 ）分区顺序消息：该类型消息的Topic有多个Queue分区。其仅可以保证该Topic的每个Queue分区中的消息被顺序消费，不能保证整个Topic中消息的顺序消费。为了保证这个分区顺序性，每个Queue分区中的消息在Consumer Group中的同一时刻只能有一个Consumer的一个线程进行消费。即，在同一时刻最多会出现多个Queue分蘖有多个Consumer的多个线程并行消费。所以其并发度为Topic的分区数量。</p><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="九、消息的清理"><a href="#九、消息的清理" class="headerlink" title="九、消息的清理"></a>九、消息的清理</h2><h4 id="消息被消费过后会被清理掉吗？不会的。"><a href="#消息被消费过后会被清理掉吗？不会的。" class="headerlink" title="消息被消费过后会被清理掉吗？不会的。"></a>消息被消费过后会被清理掉吗？不会的。</h4><p>消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。commitlog文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p><p>文件过期，且到达清理时间点（默认为凌晨 4 点）后，自动清理过期文件</p><p>文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件</p><p>磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。</p><p>默认会从最老的文件开始清理</p><p>&#x3D;&#x3D;磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入&#x3D;&#x3D;</p><h4 id="需要注意以下几点："><a href="#需要注意以下几点：" class="headerlink" title="需要注意以下几点："></a>需要注意以下几点：</h4><p>1 ）对于RocketMQ系统来说，删除一个1G大小的文件，是一个压力巨大的IO操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除commitlog文件的情况。</p><p>2 ）官方建议RocketMQ服务的Linux文件系统采用ext4。因为对于文件删除操作，ext4要比ext3性能更好</p><h2 id="第-4-章-RocketMQ应用"><a href="#第-4-章-RocketMQ应用" class="headerlink" title="第 4 章 RocketMQ应用"></a>第 4 章 RocketMQ应用</h2><h2 id="一、普通消息"><a href="#一、普通消息" class="headerlink" title="一、普通消息"></a>一、普通消息</h2><h3 id="1-消息发送分类"><a href="#1-消息发送分类" class="headerlink" title="1 消息发送分类"></a>1 消息发送分类</h3><p>Producer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p><h4 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h4><p>同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。</p><h4 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h4><p>异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</p><h4 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h4><p>单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。</p><h2 id="二、顺序消息"><a href="#二、顺序消息" class="headerlink" title="二、顺序消息"></a>二、顺序消息</h2><h3 id="1-什么是顺序消息"><a href="#1-什么是顺序消息" class="headerlink" title="1 什么是顺序消息"></a>1 什么是顺序消息</h3><p>顺序消息指的是，严格按照消息的发送顺序进行消费的消息(FIFO)。</p><p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p><h3 id="2-有序性分类"><a href="#2-有序性分类" class="headerlink" title="2 有序性分类"></a>2 有序性分类</h3><p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：&#x3D;&#x3D;分区有序与全局有序&#x3D;&#x3D;。</p><h4 id="全局有序"><a href="#全局有序" class="headerlink" title="全局有序"></a>全局有序</h4><p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为全局有序。</p><p>在创建Topic时指定Queue的数量。有三种指定方式：</p><p>1 ）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量</p><p>2 ）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量</p><p>3 ）使用mqadmin命令手动创建Topic时指定Queue数量</p><h4 id="分区有序"><a href="#分区有序" class="headerlink" title="分区有序"></a>分区有序</h4><p>​如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为分区有序。</p><p>​如何实现Queue的选择？在定义Producer时我们可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。</p><p>​一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的数量取模，其结果即为选择出的Queue的QueueId。</p><p>​取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。</p><p>​以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。</p><h2 id="三、延时消息"><a href="#三、延时消息" class="headerlink" title="三、延时消息"></a>三、延时消息</h2><h3 id="1-什么是延时消息"><a href="#1-什么是延时消息" class="headerlink" title="1 什么是延时消息"></a>1 什么是延时消息</h3><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。采用RocketMQ的延时消息可以实现定时任务的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。</p><p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。</p><h3 id="2-延时等级"><a href="#2-延时等级" class="headerlink" title="2 延时等级"></a>2 延时等级</h3><p>延时消息的延迟时长不支持随意时长的延迟，是通过特定的延迟等级来指定的。延时等级定义在RocketMQ服务端MessageStoreConfig类中的如下变量中：</p><p>即，若指定的延时等级为 3 ，则表示延迟时长为10s，即延迟等级是从 1 开始计数的。当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了 1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。</p><h3 id="3-延时消息实现原理"><a href="#3-延时消息实现原理" class="headerlink" title="3 延时消息实现原理"></a>3 延时消息实现原理</h3><p>messageDelayLevel &#x3D; 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m1h 2h 1d</p><p>1</p><h4 id="具体实现方案是："><a href="#具体实现方案是：" class="headerlink" title="具体实现方案是："></a>具体实现方案是：</h4><h4 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h4><p>​Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p><p>​修改消息的Topic为SCHEDULE_TOPIC_XXXX</p><p>​根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。</p><p>​延迟等级delayLevel与queueId的对应关系为queueId &#x3D; delayLevel -1</p><p>​需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p><p>​修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的投递时间。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。投递时间 &#x3D; 消息存储时间 + 延时等级时间。消息存储时间指的是消息被发送到Broker时的时间戳。将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？</p><p>​是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于消息存储时间了。即按照消息被发送到Broker的时间进行排序的。</p><p>投递延时消息</p><p>​Broker内部有一个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为 0 ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。</p><p>​ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检 测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。</p><p>将消息重新写入commitlog</p><p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p><p>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService。</p><h2 id="四、事务消息"><a href="#四、事务消息" class="headerlink" title="四、事务消息"></a>四、事务消息</h2><h3 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1 问题引入"></a>1 问题引入</h3><p>​这里的一个需求场景是：工行用户A向建行用户B转账 1 万元。</p><p>​我们可以使用同步消息来处理该需求场景：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 工行系统发送一个给B增款 1 万元的同步消息M给Broker</span><br><span class="line">2. 消息被Broker成功接收后，向工行系统发送成功ACK</span><br><span class="line">3. 工行系统收到成功ACK后从用户A中扣款 1 万元</span><br><span class="line">4. 建行系统从Broker中获取到消息M</span><br><span class="line">5. 建行系统消费消息M，即向用户B中增加 1 万元</span><br></pre></td></tr></table></figure><p>​这其中是有问题的：若第 3 步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了 1 万元。出现了数据不一致问题。</p><h3 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2 解决思路"></a>2 解决思路</h3><p>​解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用事务消息。这里要使用分布式事务解决方案。使用事务消息来处理该需求场景：</p><ol><li><p>事务管理器TM向事务协调器TC发起指令，开启全局事务</p></li><li><p>工行系统发一个给B增款 1 万元的事务消息M给TC</p></li><li><p>TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker。此时的建行系统是看不到Broker中的消息M的</p></li><li><p>Broker会将预提交执行结果Report给TC。</p></li><li><p>如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会调用工行系统的回调操作，去完成工行用户A的预扣款 1 万元的操作</p></li><li><p>工行系统会向TC发送预扣款执行结果，即本地事务的执行状态</p></li><li><p>TC收到预扣款执行结果后，会将结果上报给TM。</p></li><li><p>TM会根据上报结果向TC发出不同的确认指令</p></li><li><p>TC在接收到指令后会向Broker与工行系统发出确认指令</p></li></ol><h4 id="预扣款执行结果存在三种可能性："><a href="#预扣款执行结果存在三种可能性：" class="headerlink" title="预扣款执行结果存在三种可能性："></a>预扣款执行结果存在三种可能性：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 描述本地事务执行状态</span><br><span class="line">public enum LocalTransactionState &#123;</span><br><span class="line">COMMIT_MESSAGE,  // 本地事务执行成功</span><br><span class="line">ROLLBACK_MESSAGE,  // 本地事务执行失败</span><br><span class="line">UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-TM会根据上报结果向TC发出不同的确认指令"><a href="#8-TM会根据上报结果向TC发出不同的确认指令" class="headerlink" title="8. TM会根据上报结果向TC发出不同的确认指令"></a>8. TM会根据上报结果向TC发出不同的确认指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令</span><br><span class="line">若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令</span><br><span class="line">若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态回查操作。回</span><br><span class="line">查操作会将回查结果，即COMMIT_MESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上</span><br><span class="line">报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以上方案就是为了确保消息投递与扣款操作能够在一个事务中，要成功都成功，有一个失败，则全部回滚。</span><br></pre></td></tr></table></figure><p>以上方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p><h3 id="3-基础"><a href="#3-基础" class="headerlink" title="3 基础"></a>3 基础</h3><p>分布式事务</p><p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。</p><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ提供了类似X&#x2F;Open XA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA是一种分布式事务解决方案，一种分布式事务处理模式。</p><h4 id="半事务消息"><a href="#半事务消息" class="headerlink" title="半事务消息"></a>半事务消息</h4><p>暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p><h4 id="本地事务状态"><a href="#本地事务状态" class="headerlink" title="本地事务状态"></a>本地事务状态</h4><p>Producer回调操作执行的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发送来的本地事务状态来决定全局事务确认指令。</p><h4 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h4><p>消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。</p><p>引发消息回查的原因最常见的有两个：</p><p>1)回调操作返回UNKNWON</p><p>2)TC没有接收到TM的最终全局事务确认指令</p><p>RocketMQ中的消息回查设置</p><p>关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 描述本地事务执行状态</span><br><span class="line">public enum LocalTransactionState &#123;</span><br><span class="line">COMMIT_MESSAGE,  // 本地事务执行成功</span><br><span class="line">ROLLBACK_MESSAGE,  // 本地事务执行失败</span><br><span class="line">UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transactionTimeout=20，指定TM在 20 秒内应将最终确认状态发送给TC，否则引发消息回查。默</span><br><span class="line">认为 60 秒</span><br><span class="line">transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。</span><br><span class="line">transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。</span><br></pre></td></tr></table></figure><h3 id="4-XA模式三剑客"><a href="#4-XA模式三剑客" class="headerlink" title="4 XA模式三剑客"></a>4 XA模式三剑客</h3><h4 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h4><p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。XA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的Unix事务系统）首先提出的，并交给X&#x2F;Open组织，作为资源管理器与事务管理器的接口标准。</p><p>XA模式中有三个重要组件：TC、TM、RM。TC</p><p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。RocketMQ中Broker充当着TC。</p><h4 id="TM"><a href="#TM" class="headerlink" title="TM"></a>TM</h4><p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。RocketMQ中事务消息的Producer充当着TM。</p><h4 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h4><p>Resource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。RocketMQ中事务消息的Producer及Broker均是RM。</p><h3 id="5-XA模式架构"><a href="#5-XA模式架构" class="headerlink" title="5 XA模式架构"></a>5 XA模式架构</h3><p>XA模式是一个典型的2PC，其执行原理如下：</p><ol><li><p>TM向TC发起指令，开启一个全局事务。</p></li><li><p>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</p></li><li><p>各个RM在接收到指令后会在进行本地事务预执行。</p></li><li><p>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。</p></li><li><p>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。若所有结果都是成功响应，则向TC发送Global Commit指令。只要有结果是失败响应，则向TC发送Global Rollback指令。</p></li><li><p>TC在接收到指令后再次向RM发送确认指令。事务消息方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p></li></ol><h3 id="6-注意"><a href="#6-注意" class="headerlink" title="6 注意"></a>6 注意</h3><p>事务消息不支持延时消息</p><p>对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）</p><h3 id="7-代码举例"><a href="#7-代码举例" class="headerlink" title="7 代码举例"></a>7 代码举例</h3><p>定义工行事务监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICBCTransactionListener</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line"><span class="comment">// 回调操作方法</span></span><br><span class="line"><span class="comment">// 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg,</span></span><br><span class="line"><span class="params">Object arg)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;预提交消息成功：&quot;</span> + msg);</span><br><span class="line"><span class="comment">// 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，</span></span><br><span class="line"><span class="comment">// TAGC表示扣款结果不清楚，需要执行消息回查</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息回查方法</span><br><span class="line">// 引发消息回查的原因最常见的有两个：</span><br><span class="line">// 1)回调操作返回UNKNWON</span><br><span class="line">// 2)TC没有接收到TM的最终全局事务确认指令</span><br><span class="line">@Override</span><br><span class="line">public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">System.out.println(&quot;执行消息回查&quot; + msg.getTags());</span><br><span class="line">return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义事物消息生产者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TransactionProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">TransactionMQProducer producer = new</span><br><span class="line">TransactionMQProducer(&quot;tpg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个线程池</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> corePoolSize 线程池中核心线程数量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> maximumPoolSize 线程池中最多线程数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量</span></span><br><span class="line"><span class="comment">是，直接使用普通消息的SomeConsumer作为消费者即可。</span></span><br><span class="line"><span class="comment">* 多余空闲线程的存活时长</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> workQueue 临时存放任务的队列，其参数就是队列的长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( <span class="number">2</span> , <span class="number">5</span> ,</span><br><span class="line"><span class="number">100</span> , TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;( <span class="number">2000</span> ), <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="定义消费者"><a href="#定义消费者" class="headerlink" title="定义消费者"></a>定义消费者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 为生产者指定一个线程池</span><br><span class="line">producer.setExecutorService(executorService);</span><br><span class="line">// 为生产者添加事务监听器</span><br><span class="line">producer.setTransactionListener(new ICBCTransactionListener());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer.start();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] tags = &#123;&quot;TAGA&quot;,&quot;TAGB&quot;,&quot;TAGC&quot;&#125;;</span><br><span class="line">for (int i = 0 ; i &lt; 3 ; i++) &#123;</span><br><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">Message msg = new Message(&quot;TTopic&quot;, tags[i], body);</span><br><span class="line">// 发送事务消息</span><br><span class="line">// 第二个参数用于指定在执行本地事务时要使用的业务参数</span><br><span class="line">SendResult sendResult =</span><br><span class="line">producer.sendMessageInTransaction(msg,null);</span><br><span class="line">System.out.println(&quot;发送结果为：&quot; +</span><br><span class="line">sendResult.getSendStatus());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SomeConsumer &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">// 定义一个pull消费者</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// DefaultLitePullConsumer consumer = new</span><br><span class="line">DefaultLitePullConsumer(&quot;cg&quot;);</span><br><span class="line">// 定义一个push消费者</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">// 指定nameServer</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 指定从第一条消息开始消费</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">// 指定消费topic与tag</span><br><span class="line">consumer.subscribe(&quot;TTopic&quot;, &quot;*&quot;);</span><br><span class="line">// 指定采用“广播模式”进行消费，默认为“集群模式”</span><br><span class="line">// consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注册消息监听器</span><br><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span><br><span class="line">// 其返回值为当前consumer消费的状态</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">// 逐条消费消息</span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">// 返回消费状态：消费成功</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 开启消费者消费</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、批量消息"><a href="#五、批量消息" class="headerlink" title="五、批量消息"></a>五、批量消息</h2><h3 id="1-批量发送消息"><a href="#1-批量发送消息" class="headerlink" title="1 批量发送消息"></a>1 批量发送消息</h3><h4 id="发送限制"><a href="#发送限制" class="headerlink" title="发送限制"></a>发送限制</h4><p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以<br>下几点：</p><p>​批量发送的消息必须具有相同的Topic<br>​批量发送的消息必须具有相同的刷盘策略<br>​批量发送的消息不能是延时消息与事务消息</p><h4 id="批量发送大小"><a href="#批量发送大小" class="headerlink" title="批量发送大小"></a>批量发送大小</h4><p>默认情况下，一批发送的消息总大小不能超过4MB字节。如果想超出该值，有两种解决方案：</p><p>方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送</p><p>方案二：在Producer端与Broker端修改属性</p><p>​Producer端需要在发送之前设置Producer的maxMessageSize属性</p><p>​Broker端需要修改其加载的配置文件中的maxMessageSize属性</p><h4 id="生产者发送的消息大小"><a href="#生产者发送的消息大小" class="headerlink" title="生产者发送的消息大小"></a>生产者发送的消息大小</h4><p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占 20 字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p><h3 id="2-批量消费消息"><a href="#2-批量消费消息" class="headerlink" title="2 批量消费消息"></a>2 批量消费消息</h3><h4 id="修改批量属性"><a href="#修改批量属性" class="headerlink" title="修改批量属性"></a>修改批量属性</h4><p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过 32 。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改Consumer的<br>pullBatchSize属性来指定。</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。</p><p>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。<br>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。</p><h3 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3 代码举例"></a>3 代码举例</h3><p>该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。定义消息列表分割器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息列表分割器：其只会处理每条消息的大小不超4M的情况。</span><br><span class="line">// 若存在某条消息，其本身大小大于4M，这个分割器无法处理，</span><br><span class="line">// 其直接将这条消息构成一个子列表返回。并没有再进行分割</span><br><span class="line">public class MessageListSplitter implements Iterator&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line">// 指定极限值为4M</span><br><span class="line">private final int SIZE_LIMIT =  4 * 1024 * 1024 ;</span><br><span class="line">// 存放所有要发送的消息</span><br><span class="line">private final List&lt;Message&gt; messages;</span><br><span class="line">// 要进行批量发送消息的小集合起始索引</span><br><span class="line">private int currIndex;</span><br><span class="line">public MessageListSplitter(List&lt;Message&gt; messages) &#123;</span><br><span class="line">this.messages = messages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">// 判断当前开始遍历的消息索引要小于消息总数</span><br><span class="line">return currIndex &lt; messages.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;Message&gt; next() &#123;</span><br><span class="line">int nextIndex = currIndex;</span><br><span class="line">// 记录当前要发送的这一小批次消息列表的大小</span><br><span class="line">int totalSize = 0 ;</span><br><span class="line">for (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">// 获取当前遍历的消息</span><br><span class="line">Message message = messages.get(nextIndex);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 统计当前遍历的message的大小</span><br><span class="line">int tmpSize = message.getTopic().length() +</span><br><span class="line">message.getBody().length;</span><br><span class="line">Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry :</span><br><span class="line">properties.entrySet()) &#123;</span><br><span class="line">tmpSize += entry.getKey().length() +</span><br><span class="line">entry.getValue().length();</span><br><span class="line">&#125;</span><br><span class="line">tmpSize = tmpSize + 20 ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断当前消息本身是否大于4M</span><br><span class="line">if (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">if (nextIndex - currIndex == 0 ) &#123;</span><br><span class="line">nextIndex++;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">totalSize += tmpSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125; // end-for</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取当前messages列表的子集合[currIndex, nextIndex)</span><br><span class="line">List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">// 下次遍历的开始索引</span><br><span class="line">currIndex = nextIndex;</span><br><span class="line">return subList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义批量消息生产者"><a href="#定义批量消息生产者" class="headerlink" title="定义批量消息生产者"></a>定义批量消息生产者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BatchProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 指定要发送的消息的最大大小，默认是4M</span><br><span class="line">// 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的</span><br><span class="line">// maxMessageSize属性</span><br><span class="line">// producer.setMaxMessageSize(8 * 1024 * 1024);</span><br><span class="line">producer.start();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义要发送的消息集合</span><br><span class="line">List&lt;Message&gt; messages = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0 ; i &lt; 100 ; i++) &#123;</span><br><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">Message msg = new Message(&quot;someTopic&quot;, &quot;someTag&quot;, body);</span><br><span class="line">messages.add(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表</span><br><span class="line">MessageListSplitter splitter = new</span><br><span class="line">MessageListSplitter(messages);</span><br><span class="line">while (splitter.hasNext()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">List&lt;Message&gt; listItem = splitter.next();</span><br><span class="line">producer.send(listItem);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义批量消息消费者"><a href="#定义批量消息消费者" class="headerlink" title="定义批量消息消费者"></a>定义批量消息消费者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BatchConsumer &#123;</span><br><span class="line">public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure><h2 id="六、消息过滤"><a href="#六、消息过滤" class="headerlink" title="六、消息过滤"></a>六、消息过滤</h2><p>消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。对于指定Topic消息的过滤有两种过滤方式：Tag过滤与SQL过滤。</p><h3 id="1-Tag过滤"><a href="#1-Tag过滤" class="headerlink" title="1 Tag过滤"></a>1 Tag过滤</h3><p>通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算符(双竖线||)连接。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">consumer.subscribe(&quot;someTopicA&quot;, &quot;*&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 指定每次可以消费 10 条消息，默认为 1</span><br><span class="line">consumer.setConsumeMessageBatchMaxSize( 10 );</span><br><span class="line">// 指定每次可以从Broker拉取 40 条消息，默认为 32</span><br><span class="line">consumer.setPullBatchSize( 40 );</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs,</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">// 消费成功的返回结果</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">// 消费异常时的返回结果</span><br><span class="line">// return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-SQL过滤"><a href="#2-SQL过滤" class="headerlink" title="2 SQL过滤"></a>2 SQL过滤</h3><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的用户属性进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用PUSH模式的消费者才能使用SQL过滤。SQL过滤表达式中支持多种常量类型与运算符。</p><p>支持的常量类型：数值：比如： 123 ，3.1415</p><p>字符：必须用单引号包裹起来，比如：’abc’<br>布尔：TRUE 或 FALSE<br>NULL：特殊的常量，表示空</p><h4 id="支持的运算符有："><a href="#支持的运算符有：" class="headerlink" title="支持的运算符有："></a>支持的运算符有：</h4><h4 id="数值比较：-，-，"><a href="#数值比较：-，-，" class="headerlink" title="数值比较：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;"></a>数值比较：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;</h4><h4 id="字符比较：-，，IN"><a href="#字符比较：-，，IN" class="headerlink" title="字符比较：&#x3D;，&lt;&gt;，IN"></a>字符比较：&#x3D;，&lt;&gt;，IN</h4><h4 id="逻辑运算-：AND，OR，NOT"><a href="#逻辑运算-：AND，OR，NOT" class="headerlink" title="逻辑运算 ：AND，OR，NOT"></a>逻辑运算 ：AND，OR，NOT</h4><h4 id="NULL判断：IS-NULL-或者-IS-NOT-NULL"><a href="#NULL判断：IS-NULL-或者-IS-NOT-NULL" class="headerlink" title="NULL判断：IS NULL 或者 IS NOT NULL"></a>NULL判断：IS NULL 或者 IS NOT NULL</h4><p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开<br>启该功能：</p><p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是<br>conf&#x2F;broker.conf，启动时使用如下命令：</p><h3 id="3-代码举例-1"><a href="#3-代码举例-1" class="headerlink" title="3 代码举例"></a>3 代码举例</h3><p>定义Tag过滤Producer</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;CID_EXAMPLE&quot;);</span><br><span class="line">consumer.subscribe(&quot;TOPIC&quot;, &quot;TAGA || TAGB || TAGC&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 enablePropertyFilter = true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterByTagProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">producer.start();</span><br><span class="line">String[] tags = &#123;&quot;myTagA&quot;,&quot;myTagB&quot;,&quot;myTagC&quot;&#125;;</span><br><span class="line">for (int i = 0 ; i &lt; 10 ; i++) &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure><p>定义Tag过滤Consumer</p><p>定义SQL过滤Producer</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">String tag = tags[i%tags.length];</span><br><span class="line">Message msg = new Message(&quot;myTopic&quot;,tag,body);</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterByTagConsumer &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;pg&quot;);</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(&quot;myTopic&quot;, &quot;myTagA || myTagB&quot;);</span><br><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs,</span><br><span class="line">ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">for (MessageExt me:msgs)&#123;</span><br><span class="line">System.out.println(me);</span><br><span class="line">&#125;</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterBySQLProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>定义SQL过滤Consumer</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer.start();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 10 ; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">Message msg = new Message(&quot;myTopic&quot;, &quot;myTag&quot;, body);</span><br><span class="line">msg.putUserProperty(&quot;age&quot;, i + &quot;&quot;);</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterBySQLConsumer &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;pg&quot;);</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(&quot;myTopic&quot;, MessageSelector.bySql(&quot;age between</span><br><span class="line">0 and 6&quot;));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext</span><br><span class="line">context) &#123;</span><br><span class="line">for (MessageExt me:msgs)&#123;</span><br><span class="line">System.out.println(me);</span><br><span class="line">&#125;</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">12</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="七、消息发送重试机制"><a href="#七、消息发送重试机制" class="headerlink" title="七、消息发送重试机制"></a>七、消息发送重试机制</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><p>Producer对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。</p><h4 id="对于消息重投，需要注意以下几点："><a href="#对于消息重投，需要注意以下几点：" class="headerlink" title="对于消息重投，需要注意以下几点："></a>对于消息重投，需要注意以下几点：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式</span><br><span class="line">发送失败是没有重试机制的</span><br><span class="line">只有普通消息具有发送重试机制，顺序消息是没有的</span><br><span class="line">消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在</span><br><span class="line">RocketMQ中是无法避免的问题</span><br><span class="line">消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件</span><br><span class="line">producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复</span><br><span class="line">消费）也会导致重复消息</span><br><span class="line">消息重复无法避免，但要避免消息的重复消费。</span><br><span class="line">避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消</span><br><span class="line">费判断来避免重复消费</span><br><span class="line">消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</span><br></pre></td></tr></table></figure><h3 id="2-同步发送失败策略"><a href="#2-同步发送失败策略" class="headerlink" title="2 同步发送失败策略"></a>2 同步发送失败策略</h3><p>对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试 2<br>次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其<br>也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p><p>同时，Broker还具有失败隔离功能，使Producer尽量选择未发生过发送失败的Broker作为目标</p><p>Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思考：让我们自己实现失败隔离功能，如何来做？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个producer，参数为Producer Group名称</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">// 指定nameServer地址</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 设置同步发送失败时重试发送的次数，默认为 2 次</span><br><span class="line">producer.setRetryTimesWhenSendFailed( 3 );</span><br><span class="line">// 设置发送超时时限为5s，默认3s</span><br><span class="line">producer.setSendMsgTimeout( 5000 );</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实</span><br><span class="line">例。Producer中还维护着一个Set集合，其中存放着所有未发生发送异常的Broker实例。选择目</span><br><span class="line">标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送</span><br><span class="line">异常的Broker清理出去，并添加到Set集合。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 ）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该</span><br><span class="line">Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的</span><br><span class="line">Broker。再定义一个定时任务，定期将Broker的该属性置为false。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 ）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该</span><br><span class="line">Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若</span><br><span class="line">该值相同，采用轮询方式选择。</span><br></pre></td></tr></table></figure><p>如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现<br>RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。</p><h3 id="3-异步发送失败策略"><a href="#3-异步发送失败策略" class="headerlink" title="3 异步发送失败策略"></a>3 异步发送失败策略</h3><p>异步发送失败重试时，异步重试不会选择其他broker，仅在同一个broker上做重试，所以该策略无法保<br>证消息不丢。</p><h3 id="4-消息刷盘失败策略"><a href="#4-消息刷盘失败策略" class="headerlink" title="4 消息刷盘失败策略"></a>4 消息刷盘失败策略</h3><p>消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是<br>SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker<br>的配置文件设置retryAnotherBrokerWhenNotStoreOK属性为true来开启。</p><h2 id="八、消息消费重试机制"><a href="#八、消息消费重试机制" class="headerlink" title="八、消息消费重试机制"></a>八、消息消费重试机制</h2><h3 id="1-顺序消息的消费重试"><a href="#1-顺序消息的消费重试" class="headerlink" title="1 顺序消息的消费重试"></a>1 顺序消息的消费重试</h3><p>对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重<br>试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。重试期间应用会出现消息消费被阻塞的情<br>况。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 指定异步发送失败后不进行重试发送</span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed( 0 );</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000 ，其取值范围为[10,</span><br><span class="line">30000]</span><br><span class="line">consumer.setSuspendCurrentQueueTimeMillis( 100 );</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="重试次数-与上次重试的间隔时间-重试次数-与上次重试的间隔时间"><a href="#重试次数-与上次重试的间隔时间-重试次数-与上次重试的间隔时间" class="headerlink" title="重试次数 与上次重试的间隔时间 重试次数 与上次重试的间隔时间"></a>重试次数 与上次重试的间隔时间 重试次数 与上次重试的间隔时间</h4><h4 id="1-10-秒-9-7-分钟"><a href="#1-10-秒-9-7-分钟" class="headerlink" title="1 10 秒 9 7 分钟"></a>1 10 秒 9 7 分钟</h4><h4 id="2-30-秒-10-8-分钟"><a href="#2-30-秒-10-8-分钟" class="headerlink" title="2 30 秒 10 8 分钟"></a>2 30 秒 10 8 分钟</h4><h4 id="3-1-分钟-11-9-分钟"><a href="#3-1-分钟-11-9-分钟" class="headerlink" title="3 1 分钟 11 9 分钟"></a>3 1 分钟 11 9 分钟</h4><h4 id="4-2-分钟-12-10-分钟"><a href="#4-2-分钟-12-10-分钟" class="headerlink" title="4 2 分钟 12 10 分钟"></a>4 2 分钟 12 10 分钟</h4><h4 id="5-3-分钟-13-20-分钟"><a href="#5-3-分钟-13-20-分钟" class="headerlink" title="5 3 分钟 13 20 分钟"></a>5 3 分钟 13 20 分钟</h4><h4 id="6-4-分钟-14-30-分钟"><a href="#6-4-分钟-14-30-分钟" class="headerlink" title="6 4 分钟 14 30 分钟"></a>6 4 分钟 14 30 分钟</h4><h4 id="7-5-分钟-15-1-小时"><a href="#7-5-分钟-15-1-小时" class="headerlink" title="7 5 分钟 15 1 小时"></a>7 5 分钟 15 1 小时</h4><h4 id="8-6-分钟-16-2-小时"><a href="#8-6-分钟-16-2-小时" class="headerlink" title="8 6 分钟 16 2 小时"></a>8 6 分钟 16 2 小时</h4><h4 id="由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，"><a href="#由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，" class="headerlink" title="由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，"></a>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，</h4><h4 id="务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。"><a href="#务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。" class="headerlink" title="务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。"></a>务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。</h4><h4 id="注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制"><a href="#注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制" class="headerlink" title="注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制"></a>注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制</h4><h3 id="2-无序消息的消费重试"><a href="#2-无序消息的消费重试" class="headerlink" title="2 无序消息的消费重试"></a>2 无序消息的消费重试</h3><p>对于无序消息（普通消息、延时消息、事务消息），当Consumer消费消息失败时，可以通过设置返回<br>状态达到消息重试的效果。不过需要注意，无序消息的重试只对集群消费方式生效，广播消费方式不</p><p>提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</p><h3 id="3-消费重试次数与间隔"><a href="#3-消费重试次数与间隔" class="headerlink" title="3 消费重试次数与间隔"></a>3 消费重试次数与间隔</h3><h4 id="对于无序消息集群消费下的重试消费，每条消息默认最多重试-16-次，但每次重试的间隔时间是不同"><a href="#对于无序消息集群消费下的重试消费，每条消息默认最多重试-16-次，但每次重试的间隔时间是不同" class="headerlink" title="对于无序消息集群消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同"></a>对于无序消息集群消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同</h4><h4 id="的，会逐渐变长。每次重试的间隔时间如下表。"><a href="#的，会逐渐变长。每次重试的间隔时间如下表。" class="headerlink" title="的，会逐渐变长。每次重试的间隔时间如下表。"></a>的，会逐渐变长。每次重试的间隔时间如下表。</h4><h4 id="若一条消息在一直消费失败的前提下，将会在正常消费后的第-4-小时-46-分后进行第-16-次重试。"><a href="#若一条消息在一直消费失败的前提下，将会在正常消费后的第-4-小时-46-分后进行第-16-次重试。" class="headerlink" title="若一条消息在一直消费失败的前提下，将会在正常消费后的第 4 小时 46 分后进行第 16 次重试。"></a>若一条消息在一直消费失败的前提下，将会在正常消费后的第 4 小时 46 分后进行第 16 次重试。</h4><h4 id="若仍然失败，则将消息投递到死信队列"><a href="#若仍然失败，则将消息投递到死信队列" class="headerlink" title="若仍然失败，则将消息投递到死信队列"></a>若仍然失败，则将消息投递到死信队列</h4><h4 id="修改消费重试次数"><a href="#修改消费重试次数" class="headerlink" title="修改消费重试次数"></a>修改消费重试次数</h4><h4 id="对于修改过的重试次数，将按照以下策略执行："><a href="#对于修改过的重试次数，将按照以下策略执行：" class="headerlink" title="对于修改过的重试次数，将按照以下策略执行："></a>对于修改过的重试次数，将按照以下策略执行：</h4><h4 id="若修改值小于-16-，则按照指定间隔进行重试"><a href="#若修改值小于-16-，则按照指定间隔进行重试" class="headerlink" title="若修改值小于 16 ，则按照指定间隔进行重试"></a>若修改值小于 16 ，则按照指定间隔进行重试</h4><h4 id="若修改值大于-16-，则超过-16-次的重试时间间隔均为-2-小时"><a href="#若修改值大于-16-，则超过-16-次的重试时间间隔均为-2-小时" class="headerlink" title="若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时"></a>若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有</span><br><span class="line">其它Consumer实例。若出现多个Consumer均做了修改的情况，则采用覆盖方式生效。即最后被</span><br><span class="line">修改的值会覆盖前面设置的值。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">// 修改消费重试次数</span><br><span class="line">consumer.setMaxReconsumeTimes( 10 );</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="4-重试队列-1"><a href="#4-重试队列-1" class="headerlink" title="4 重试队列"></a>4 重试队列</h3><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而<br>是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队<br>列就是重试队列。</p><p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称<br>为%RETRY%consumerGroup@consumerGroup的重试队列。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ）这个重试队列是针对消息才组的，而不是针对每个Topic设置的（一个Topic的消息可以让多</span><br><span class="line">个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）</span><br></pre></td></tr></table></figure><h4 id="2-）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列"><a href="#2-）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列" class="headerlink" title="2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列"></a>2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</h4><h4 id="注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间"><a href="#注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间" class="headerlink" title="注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间"></a>注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间</h4><h4 id="外，其它的时间都是相同的"><a href="#外，其它的时间都是相同的" class="headerlink" title="外，其它的时间都是相同的"></a>外，其它的时间都是相同的</h4><p>Broker对于重试消息的处理是通过延时消息实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队</p><p>列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p><h3 id="5-消费重试配置方式"><a href="#5-消费重试配置方式" class="headerlink" title="5 消费重试配置方式"></a>5 消费重试配置方式</h3><h4 id="集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三"><a href="#集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三" class="headerlink" title="集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三"></a>集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三</h4><h4 id="种方式之一的配置："><a href="#种方式之一的配置：" class="headerlink" title="种方式之一的配置："></a>种方式之一的配置：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式 1 ：返回ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）</span><br><span class="line">方式 2 ：返回Null</span><br><span class="line">方式 3 ：抛出异常</span><br></pre></td></tr></table></figure><h3 id="6-消费不重试配置方式"><a href="#6-消费不重试配置方式" class="headerlink" title="6 消费不重试配置方式"></a>6 消费不重试配置方式</h3><h4 id="集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相"><a href="#集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相" class="headerlink" title="集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相"></a>集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相</h4><p>同的结果，即ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。</p><h2 id="九、死信队列"><a href="#九、死信队列" class="headerlink" title="九、死信队列"></a>九、死信队列</h2><h3 id="1-什么是死信队列"><a href="#1-什么是死信队列" class="headerlink" title="1 什么是死信队列"></a>1 什么是死信队列</h3><p>当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息则称为死信消息（Dead-Letter Message，DLM）。</p><h4 id="死信队列是用于处理无法被正常消费的消息的。"><a href="#死信队列是用于处理无法被正常消费的消息的。" class="headerlink" title="死信队列是用于处理无法被正常消费的消息的。"></a>死信队列是用于处理无法被正常消费的消息的。</h4><h3 id="2-死信队列的特征"><a href="#2-死信队列的特征" class="headerlink" title="2 死信队列的特征"></a>2 死信队列的特征</h3><h4 id="死信队列具有如下特征："><a href="#死信队列具有如下特征：" class="headerlink" title="死信队列具有如下特征："></a>死信队列具有如下特征：</h4><p>死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是不可见的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间）， 3 天后会被自动删除</span><br><span class="line">死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup，即每个消</span><br><span class="line">费者组都有一个死信队列</span><br><span class="line">如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列</span><br></pre></td></tr></table></figure><h3 id="3-死信消息的处理"><a href="#3-死信消息的处理" class="headerlink" title="3 死信消息的处理"></a>3 死信消息的处理</h3><p>实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。</p>]]></content>
      
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL命令</title>
      <link href="/2023/11/27/MySQL/MySQL%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/11/27/MySQL/MySQL%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL命令"><a href="#MySQL命令" class="headerlink" title="MySQL命令"></a>MySQL命令</h1><h2 id="一、基础操作与库命令"><a href="#一、基础操作与库命令" class="headerlink" title="一、基础操作与库命令"></a>一、基础操作与库命令</h2><h3 id="1-MySQL基础操作命令"><a href="#1-MySQL基础操作命令" class="headerlink" title="1.MySQL基础操作命令"></a>1.MySQL基础操作命令</h3><p><code>net start mysql</code>：<code>Windows</code>系统启动<code>MySQL</code>服务。</p><p><code>安装目录/mysql start</code>：<code>Linux</code>系统启动<code>MySQL</code>服务。</p><ul><li><code>shutdown</code>：后面的<code>start</code>换成这个，表示关闭<code>MySQL</code>服务。</li><li><code>restart</code>：换成<code>restart</code>表示重启<code>MySQL</code>服务。</li></ul><p><code>ps -ef | grep mysql</code>：<code>Linux</code>查看<code>MySQL</code>后台进程的命令。</p><p><code>kill -9 MySQL进程ID</code>：强杀<code>MySQL</code>服务的命令。</p><p><code>mysql -h地址 -p端口 -u账号 -p</code>：客户端连接<code>MySQL</code>服务（需要二次输入密码）。</p><p><code>show status;</code>：查看<code>MySQL</code>运行状态。</p><p><code>SHOW VARIABLES like %xxx%;</code>：查看指定的系统变量。</p><p><code>show processlist;</code>：查看当前库中正在运行的所有客户端连接&#x2F;工作线程。</p><p><code>show status like &quot;Threads%&quot;;</code>：查看当前数据库的工作线程系统。</p><p><code>help data types;</code>：查看当前版本<code>MySQL</code>支持的所有数据类型。</p><p><code>help xxx</code>：查看<code>MySQL</code>的帮助信息。</p><p><code>quit</code>：退出当前数据库连接。</p><h3 id="2-MySQL库命令"><a href="#2-MySQL库命令" class="headerlink" title="2.MySQL库命令"></a>2.MySQL库命令</h3><p><code>show databases;</code>：查看目前<code>MySQL</code>中拥有的所有库。</p><p><code>show engines;</code>：查看当前数据库支持的所有存储引擎。</p><p><code>use 库名;</code>：使用&#x2F;进入指定的某个数据库。</p><p><code>show status;</code>：查看当前数据库的状态信息。</p><p><code>show grants;</code>：查看当前连接的权限信息。</p><p><code>show errors;</code>：查看当前库中记录的错误信息。</p><p><code>show warnings</code>：查看当前库抛出的所有警告信息。</p><p><code>show create database 库名;</code>：查看创建某个库的<code>SQL</code>详细信息。</p><p><code>show create table 表名;</code>：查看创建某张表的<code>SQL</code>详细信息。</p><p><code>show tables;</code>：查看一个库中的所有表。</p><p><code>desc 表名;</code>：查看一张表的字段结构。除开这种方式还有几种方式：</p><ul><li><code>describe 表名;</code>：查看一张表的字段结构。</li><li><code>show columns from 表名;</code>：查看一张表的字段结构。</li><li><code>explain 表名;</code>：查看一张表的字段结构。</li></ul><p><code>create database 库名;</code>：新建一个数据库，后面还可以指定编码格式和排序规则。</p><p><code>drop database 库名;</code>：删除一个数据库。</p><p><code>ALTER DATABASE 库名 DEFAULT CHARACTER SET 编码格式 DEFAULT COLLATE 排序规则</code>：修改数据库的编码格式、排序规则。</p><h3 id="3-MySQL表命令"><a href="#3-MySQL表命令" class="headerlink" title="3.MySQL表命令"></a>3.MySQL表命令</h3><h4 id="3-1-字段选项（可以不写，不选使用默认值）："><a href="#3-1-字段选项（可以不写，不选使用默认值）：" class="headerlink" title="3.1 字段选项（可以不写，不选使用默认值）："></a>3.1 字段选项（可以不写，不选使用默认值）：</h4><ul><li><code>NULL</code>：表示该字段可以为空。</li><li><code>NOT NULL</code>：表示改字段不允许为空。</li><li><code>DEFAULT 默认值</code>：插入数据时若未对该字段赋值，则使用这个默认值。</li><li><code>AUTO_INCREMENT</code>：是否将该字段声明为一个自增列。</li><li><code>PRIMARY KEY</code>：将当前字段声明为表的主键。</li><li><code>UNIQUE KEY</code>：为当前字段设置唯一约束，表示不允许重复。</li><li><code>CHARACTER SET 编码格式</code>：指定该字段的编码格式，如<code>utf8</code>。</li><li><code>COLLATE 排序规则</code>：指定该字段的排序规则（非数值类型生效）。</li><li><code>COMMENT 字段描述</code>：为当前字段添加备注信息，类似于代码中的注释。</li></ul><p>表选项（可以不写，不选使用默认值）：</p><ul><li><code>ENGINE = 存储引擎名称</code>：指定表的存储引擎，如<code>InnoDB、MyISAM</code>等。</li><li><code>CHARACTER SET = 编码格式</code>：指定表的编码格式，未指定使用库的编码格式。</li><li><code>COLLATE = 排序规则</code>：指定表的排序规则，未指定则使用库的排序规则。</li><li><code>ROW_FORMAT = 格式</code>：指定存储行数据的格式，如<code>Compact、Redundant、Dynamic....</code>。</li><li><code>AUTO_INCREMENT = n</code>：设置自增列的步长，默认为<code>1</code>。</li><li><code>DATA DIRECTORY = 目录</code>：指定表文件的存储路径。</li><li><code>INDEX DIRECTORY = 目录</code>：指定索引文件的存储路径。</li><li><code>PARTITION BY ...</code>：表分区选项，后续讲《MySQL表分区》再细聊。</li><li><code>COMMENT 表描述</code>：表的注释信息，可以在这里添加一张表的备注。</li></ul><h4 id="3-2-表操作命令"><a href="#3-2-表操作命令" class="headerlink" title="3.2 表操作命令"></a>3.2 表操作命令</h4><p><code>show table status like &#39;zz_users&#39;\G;</code>：纵排输出一张表的状态信息。</p><p><code>alter table 表名 表选项;</code>：修改一张表的结构，如<code>alter table xxx engine=MyISAM</code>。</p><p><code>rename table 表名 to 新表名;</code>：修改一张表的表名。</p><p><code>alter table 表名 字段操作;</code>：修改一张表的字段结构，操作如下：</p><ul><li><code>add column 字段名 数据类型</code>：向已有的表结构添加一个字段。</li><li><code>add primary key(字段名)</code>：将某个字段声明为主键。</li><li><code>add foreing key 外键字段 表名.字段名</code>：将一个字段设置为另一张表的外键。</li><li><code>add unique 索引名(字段名)</code>：为一个字段创建唯一索引。</li><li><code>add index 索引名(字段名)</code>：为一个字段创建普通索引。</li><li><code>drop column 字段名</code>：在已有的表结构中删除一个字段。</li><li><code>modify column 字段名 字段选项</code>：修改一个字段的字段选项。</li><li><code>change column 字段名 新字段名</code>：修改一个字段的字段名称。</li><li><code>drop primary key</code>：移除表中的主键。</li><li><code>drop index 索引名</code>：删除表中的一个索引。</li><li><code>drop foreing key 外键</code>：删除表中的一个外键。</li></ul><p><code>drop table if exists 表名</code>：如果一张表存在，则删除对应的表。</p><p><code>truncate table 表名</code>：清空一张表的所有数据。</p><p><code>create table 表名 like 要复制的表名</code>：复制一张表的结构，然后创建一张新表。</p><p><code>create table 表名 as select * from 要复制的表名</code>：同时复制表结构和数据创建新表。</p><h3 id="1-4、表的分析、检查、修复与优化操作"><a href="#1-4、表的分析、检查、修复与优化操作" class="headerlink" title="1.4、表的分析、检查、修复与优化操作"></a>1.4、表的分析、检查、修复与优化操作</h3><p><code>MySQL</code>本身提供了一系列关于表的分析、检查与优化命令：</p><ul><li>①分析表：分析表中键的分布，如主键、唯一键、外键等是否合理。</li><li>②检查表：检查表以及表的数据文件是否存在错误。</li><li>③修复表：当一个表的数据或结构文件损坏时，可以修复表结构（仅支持<code>MyISAM</code>表）。</li><li>④优化表：消除<code>delete、update</code>语句执行时造成的空间浪费。</li></ul><h4 id="分析表"><a href="#分析表" class="headerlink" title="分析表"></a>分析表</h4><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sql</span></span><br><span class="line">复制代码analyze [<span class="keyword">local</span> <span class="operator">|</span> no_write_to_binlog] <span class="keyword">table</span> 表名<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中的可选参数<code>local、no_write_to_binlog</code>代表是否将本条<code>SQL</code>记录进<code>bin-log</code>日志，默认情况下是记录的，加上这两个参数中的其中一个后则不会记录，执行效果如下：<br> <img src="0cd0bb044c31492bbe454d50e1ba7dea~tplv.png" alt="分析表" style="zoom:67%;"></p><p>如果<code>Msg_text</code>显示的是<code>OK</code>，则代表这张表的键不存在问题，存在问题的情况我这边就不模拟了，后面举例聊。</p><h4 id="检查表"><a href="#检查表" class="headerlink" title="检查表"></a>检查表</h4><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">check</span> <span class="keyword">table</span> 表名<span class="number">1</span>,表名<span class="number">2.</span>.. [检查选项];</span><br></pre></td></tr></table></figure><p>分析、检查、优化、修复的命令都支持同时操作多张表，不同的表之间只需用<code>,</code>逗号隔开即可。检查命令有多个可选项，如下：</p><ul><li><code>quick</code>：不扫描行数据，不检查链接错误，仅检查表结构是否有问题。</li><li><code>fast</code>：只检查表使用完成后，是否正确关闭了表文件的<code>FD</code>文件描述符。</li><li><code>changed</code>：从上述检查过的位置开始，只检查被更改的表数据。</li><li><code>medium</code>：检查行数据，收集每一行数据的键值（主键、外键…），并计算校验和，验证数据是否正确。</li><li><code>extended</code>：对每行数据的所有字段值进行检查，检查完成后可确保数据<code>100%</code>正确。</li></ul><p>先来看看执行结果吧，如下：</p><img src="11/27/MySQL/MySQL%E5%91%BD%E4%BB%A4/bdbb69f859144beaa539b5f673a15699~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0-20231122094545654-1324640.awebp" class title="检查表"><p> 这回的结果出现了些许不同，<code>Msg_text</code>中出现了一个<code>Error</code>信息，提示咱们检查的<code>zz_u</code>表不存在，而对于一张存在的<code>zz_users</code>表，则返回<code>OK</code>，表示没有任何问题。</p><blockquote><p>当然，这里对于其他的检查选项就不做测试了，大家可以自行实验，比如把表的结构文件或数据文件，在本地打开手动删除前面的一点点数据，然后再执行检查命令，其实你也可以观察到，提示“数据不完整”的信息（但需要先停止运行<code>MySQL</code>，并且用本地表测试，不要用线上表瞎搞）。</p></blockquote><h4 id="修复表"><a href="#修复表" class="headerlink" title="修复表"></a>修复表</h4><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sql</span></span><br><span class="line">复制代码repair [<span class="keyword">local</span> <span class="operator">|</span> no_write_to_binlog] <span class="keyword">table</span> 表名 [quick] [extended] [use_frm];</span><br></pre></td></tr></table></figure><p>值得一提的是，修复表的命令不支持<code>InnoDB</code>引擎，仅支持<code>MyISAM、CSV、</code>引擎，比如基于<code>InnoDB</code>引擎的表执行修复命令时，提示如下：</p><img src="11/27/MySQL/MySQL%E5%91%BD%E4%BB%A4/3e6fca7f22054fc682a0f5a73e65d72e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0-20231122094630244-1324643.awebp" class title="修复表"><p> 上述<code>Msg_text</code>信息翻译过来的意思是：选择的表其引擎并不支持修复命令。</p><blockquote><p><code>InnoDB</code>引擎其实也有修复机制，可以在<code>my.ini/my.conf</code>文件中加一行配置：<code>[mysqld]innodb_force_recovery = 1</code>，这样在启动时会强制恢复<code>InnoDB</code>的数据。</p></blockquote><p>上述这个修复机制默认是不开启的，因为<code>InnoDB</code>不需要这个恢复机制，毕竟之前在<a href="https://juejin.cn/post/7160557698642083847">《引擎篇》</a>中聊过：<code>InnoDB</code>有完善的事务和持久化机制，客户端提交的事务都会持久化到磁盘，除非你人为损坏<code>InnoDB</code>的数据文件，否则基本上不会出现<code>InnoDB</code>数据损坏的情况。</p><h4 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h4><p>语法如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sql</span></span><br><span class="line">复制代码optimize [<span class="keyword">local</span> <span class="operator">|</span> no_write_to_binlog] <span class="keyword">table</span> 表名;</span><br></pre></td></tr></table></figure><p>这里值得一提的是：此优化非彼优化，并不意味着你的表存在性能问题，执行后它会自动调优，而是指清除老数据，执行效果如下： </p><img src="11/27/MySQL/MySQL%E5%91%BD%E4%BB%A4/ff05e705aec248b99038ab0c1e485ba1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0-1324648.awebp" class title="优化表"><h2 id="二、数据的导出、导入与备份、还原"><a href="#二、数据的导出、导入与备份、还原" class="headerlink" title="二、数据的导出、导入与备份、还原"></a>二、数据的导出、导入与备份、还原</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- --------使用 mysqldump 工具做数据的逻辑备份（导出的是sql语句）-----------</span></span><br><span class="line"><span class="comment">-- 导出MySQL中全部的库数据（使用--all-databases 或者 -A 参数）</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p密码 <span class="comment">--all-databases &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出MySQL中一部分的库数据（使用--databases 或者 -B 参数）</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p密码 <span class="comment">--databases &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出MySQL单库中的一部分表数据</span></span><br><span class="line">mysqldump –u 用户名 –h主机名 –p密码 库名[表名<span class="number">1</span>,表名<span class="number">2.</span>..]<span class="operator">&gt;</span> 备份文件名.<span class="keyword">sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出MySQL单表的部分数据（使用 --where 参数）</span></span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p 库名 表名 <span class="comment">--where=&quot;条件&quot; &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 排除某些表，导出库中其他的所有数据（使用 --ignore-table 参数）</span></span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p 库名 <span class="comment">--ignore-table=表名1,表名2... &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只导出表的结构（使用 --no-data 或者 -d 选项）</span></span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p 库名 <span class="comment">--no-data &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 只导出表的数据（使用 --no-create-info 或者 -t 选项）</span></span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p 库名 <span class="comment">--no-create-info &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出包含存储过程、函数的库数据（使用--routines 或者 -R选项）</span></span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p <span class="operator">-</span>R <span class="comment">--databases 库名 &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出包含事件（触发器）的库数据（使用 --events 或者 -E选项）</span></span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p <span class="operator">-</span>E <span class="comment">--databases 库名 &gt; 备份文件名.sql</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- --------使用 mysql 工具来恢复备份的数据（导入xx.sql文件执行）-----------</span></span><br><span class="line"><span class="comment">-- 恢复库级别的数据（包含了建库语句的情况下使用）</span></span><br><span class="line">mysql <span class="operator">-</span>u用户名 <span class="operator">-</span>p <span class="operator">&lt;</span> xxx.sql</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 恢复库中表级别的数据</span></span><br><span class="line">mysql <span class="operator">-</span>u用户名 <span class="operator">-</span>p 库名 <span class="operator">&lt;</span> xxx.sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------以物理形式备份数据（导出的是表数据） ------------</span></span><br><span class="line"><span class="comment">-- 查看数据库导出数据的路径（如果没有则需在`my.ini/my.conf`中配置）</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%secure_file_priv%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出一张表的数据为txt文件（使用 select ... into outfile 语句）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">into</span> outfile &quot;备份文件名.txt&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出一张表的数据为txt文件（使用 mysql 工具）</span></span><br><span class="line">mysql <span class="operator">-</span>u用户名 <span class="operator">-</span>p <span class="comment">--execute=&quot;select ...;&quot; 库名 &gt; &quot;数据存放目录/xxx.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出一张表的结构和数据为sql、txt文件（使用 mysqldump -T 的方式）</span></span><br><span class="line">mysqldump <span class="operator">-</span>u用户名 <span class="operator">-</span>p <span class="operator">-</span>T &quot;数据存放目录&quot; 库名 文件名</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出一张表的数据为txt文件，以竖排形式存储（使用 mysql –veritcal 的方式）</span></span><br><span class="line">mysql <span class="operator">-</span>u用户名 <span class="operator">-</span>p <span class="operator">-</span>veritcal <span class="comment">--execute=&quot;select ...;&quot; 库名 &gt; &quot;数据存放目录/xxx.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出一张表的数据为xml文件（使用 mysql -xml 的方式）</span></span><br><span class="line">mysql <span class="operator">-</span>u用户名 <span class="operator">-</span>p <span class="operator">-</span>xml <span class="comment">--execute=&quot;select ...;&quot; 库名 &gt; &quot;数据存放目录/xxx.xml&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- -----------通过物理数据文件恢复数据----------------</span></span><br><span class="line"><span class="comment">-- 使用load data infile 的方式导入.txt 物理数据</span></span><br><span class="line">load data infile &quot;数据目录/xxx.txt&quot; <span class="keyword">into</span> <span class="keyword">table</span> 库名.表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 mysqlimport 工具导入xxx.txt物理数据</span></span><br><span class="line">mysqlimport <span class="operator">-</span>u用户名 <span class="operator">-</span>p 库名 <span class="string">&#x27;数据存放目录/xxx.txt&#x27;</span> </span><br><span class="line">    <span class="comment">--fields-terminatedby=&#x27;,&#x27; </span></span><br><span class="line">    <span class="comment">--fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 mysqldump 工具迁移数据</span></span><br><span class="line">mysqldump –h 地址<span class="number">1</span> –u用户名 –p密码 –<span class="operator">-</span><span class="keyword">all</span><span class="operator">-</span>databases <span class="operator">|</span> mysql –h地址<span class="number">2</span> –u用户名 –p密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、表分区相关命令"><a href="#三、表分区相关命令" class="headerlink" title="三、表分区相关命令"></a>三、表分区相关命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建范围分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名`(</span><br><span class="line">`xxx` xxx <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> ....</span><br><span class="line">) </span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(xxx)(</span><br><span class="line"><span class="keyword">partition</span> 分区名<span class="number">1</span> <span class="keyword">values</span> less than (范围) data directory <span class="operator">=</span> &quot;/xxx/xxx/xxx&quot;,</span><br><span class="line"><span class="keyword">partition</span> 分区名<span class="number">2</span> <span class="keyword">values</span> less than (范围) data directory <span class="operator">=</span> &quot;/xxx/xxx/xxx&quot;,</span><br><span class="line">......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建枚举分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名`(</span><br><span class="line">`xxx` xxx <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> ....</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> list(xxx)(</span><br><span class="line"><span class="keyword">partition</span> 分区名<span class="number">1</span> <span class="keyword">values</span> <span class="keyword">in</span> (枚举值<span class="number">1</span>,枚举值<span class="number">2.</span>..),</span><br><span class="line"><span class="keyword">partition</span> 分区名<span class="number">2</span> <span class="keyword">values</span> <span class="keyword">in</span> (枚举值),</span><br><span class="line">......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建常规哈希分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名`(</span><br><span class="line">`xxx` xxx <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> ....</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> hash(xxx)</span><br><span class="line">partitions 分区数量;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建线性哈希分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名`(</span><br><span class="line">`xxx` xxx <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> ....</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> linear hash(xxx)</span><br><span class="line">partitions 分区数量;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建Key键分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名`(</span><br><span class="line">`xxx` xxx <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> ....</span><br><span class="line">)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> key(xxx)</span><br><span class="line">partitions 分区数量;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建Sub子分区</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `表名`(</span><br><span class="line">`xxx` xxx <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line"> ....</span><br><span class="line">) </span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(父分区键)</span><br><span class="line">subpartition <span class="keyword">by</span> hash(子分区键)(</span><br><span class="line">    <span class="keyword">partition</span> 分区名<span class="number">1</span> <span class="keyword">values</span> less than (范围<span class="number">1</span>)(</span><br><span class="line">        subpartition 子分区名<span class="number">1</span>,</span><br><span class="line">        subpartition 子分区名<span class="number">2</span>,</span><br><span class="line">        ......</span><br><span class="line">    ),</span><br><span class="line">    <span class="keyword">partition</span> 分区名<span class="number">2</span> <span class="keyword">values</span> less than (范围<span class="number">2</span>)(</span><br><span class="line">        subpartition 子分区名<span class="number">1</span>,</span><br><span class="line">        subpartition 子分区名<span class="number">2</span>,</span><br><span class="line">        ......</span><br><span class="line">    ),</span><br><span class="line">    ......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询一张表各个分区的数据量</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    partition_name <span class="keyword">as</span> &quot;分区名称&quot;,table_rows <span class="keyword">as</span> &quot;数据行数&quot;</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    information_schema.partitions </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询一张表父子分区的数据量</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    partition_name <span class="keyword">as</span> &quot;父分区名称&quot;,</span><br><span class="line">subpartition_name <span class="keyword">as</span> &quot;子分区名称&quot;,</span><br><span class="line">table_rows <span class="keyword">as</span> &quot;子分区行数&quot;</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">    information_schema.partitions </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    table_name <span class="operator">=</span> <span class="string">&#x27;表名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询MySQL中所有表分区的信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.partitions;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询一张表某个分区中的所有数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">partition</span> (分区名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对于一张已存在的表添加分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 reorganize <span class="keyword">partition</span> 分区名 <span class="keyword">into</span> (</span><br><span class="line"><span class="keyword">partition</span> 分区名<span class="number">1</span> <span class="keyword">values</span> less than (范围) data directory <span class="operator">=</span> &quot;/xxx/xxx/xxx&quot;,</span><br><span class="line"><span class="keyword">partition</span> 分区名<span class="number">2</span> <span class="keyword">values</span> less than (范围) data directory <span class="operator">=</span> &quot;/xxx/xxx/xxx&quot;,</span><br><span class="line">......</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将多个分区合并成一个分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表明 reorganize <span class="keyword">partition</span> 分区名<span class="number">1</span>,分区名<span class="number">2.</span>.. <span class="keyword">into</span> (</span><br><span class="line">    <span class="keyword">partition</span> 新分区名 <span class="keyword">values</span> less than (范围)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空一个分区中的所有数据</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">truncate</span> <span class="keyword">partition</span> 分区名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除一个表的指定分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> <span class="keyword">partition</span> 分区名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重建一张表的分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 rebuild <span class="keyword">partition</span> 分区名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 分析一个表分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 analyze <span class="keyword">partition</span> 分区名;</span><br><span class="line"><span class="comment">-- 优化一个表分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 optimize <span class="keyword">partition</span> 分区名;</span><br><span class="line"><span class="comment">-- 检查一个表分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">check</span> <span class="keyword">partition</span> 分区名;</span><br><span class="line"><span class="comment">-- 修复一个表分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 repair <span class="keyword">partition</span> 分区名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 减少hash、key分区方式的 n 个分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 coalesce <span class="keyword">partition</span> n;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将一张表的分区切换到另一张表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名<span class="number">1</span> exchange <span class="keyword">partition</span> 分区名 <span class="keyword">with</span> <span class="keyword">table</span> 表名<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 移除一张表的所有分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 remove partitioning;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL内存</title>
      <link href="/2023/11/27/MySQL/MySQL%E5%86%85%E5%AD%98/"/>
      <url>/2023/11/27/MySQL/MySQL%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<img src="e41615f4864a48b7a75695ca5ad0a532~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp.png" alt="MySQL内存结构" style="zoom:67%;"><h3 id="本地内存"><a href="#本地内存" class="headerlink" title="本地内存"></a>本地内存</h3><img src="c0e3d945cbc6463ea5b119ac0bada852~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp.png" alt="工作线程-本地内存" style="zoom:67%;"><p><code>thread_stack</code>：线程堆栈，主要用于暂时存储运行的<code>SQL</code>语句及运算数据，和<code>Java</code>虚拟机栈类似。</p><p><code>sort_buffer</code>：排序缓冲区，执行排序<code>SQL</code>时，用于存放排序后数据的临时缓冲区。</p><p><code>join_buffer</code>：连接缓冲区，做连表查询时，存放符合连表查询条件的数据临时缓冲区。</p><p><code>read_buffer</code>：顺序读缓冲区，<code>MySQL</code>磁盘<code>IO</code>一次读一页数据，这个是顺序<code>IO</code>的数据临时缓冲区。</p><p><code>read_rnd_buffer</code>：随机读缓冲区，当基于无序字段查询数据时，这里存放随机读到的数据。</p><p><code>net_buffer</code>：网络连接缓冲区，这里主要是存放当前线程对应的客户端连接信息。</p><p><code>tmp_table</code>：内存临时表，当<code>SQL</code>中用到了临时表时，这里存放临时表的结构及数据。</p><p><code>bulk_insert_buffer</code>：<code>MyISAM</code>批量插入缓冲区，批量<code>insert</code>时，存放临时数据的缓冲区。</p><p><code>bin_log_buffer</code>：<code>bin-log</code>日志缓冲区，<a href="https://juejin.cn/post/7157956679932313608#heading-11">《日志篇》</a>提到过的，<code>bin-log</code>的缓冲区被设计在工作线程的本地内存中。</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><img src="b6f4e8026d29410aa8d58260aca07a4d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="共享内存" style="zoom:67%;"><p><code>Key Buffer</code>：<code>MyISAM</code>表的索引缓冲区，提升<code>MyISAM</code>表的索引读写速度。</p><p><code>Query Cache</code>：查询缓存区，缓冲<code>SQL</code>的查询结果，提升热点<code>SQL</code>的数据检索效率。</p><p><code>Thread Cache</code>：线程缓存区，存放工作线程运行期间，一些需要被共享的临时数据。</p><p><code>Table Cache</code>：表数据文件的文件描述符缓存，提升数据表的打开效率。</p><p><code>Table Definition Cache</code>：表结构文件的文件描述符缓存，提升结构表的打开效率。</p><h3 id="存储引擎缓存区"><a href="#存储引擎缓存区" class="headerlink" title="存储引擎缓存区"></a>存储引擎缓存区</h3><img src="075bd1f2b07c405ba2fe4de6989f4430~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75-1324591.awebp" alt="BufferPool" style="zoom:67%;"><p><code>Data Page</code>：写入缓冲区，主要用来缓冲磁盘的表数据，将写操作转移到内存进行。</p><p><code>Index Page</code>：索引缓冲页，对于所有已创建的索引根节点，都会放入到内存，提升索引效率。</p><p><code>Lock Space</code>：锁空间，主要是存放所有创建出的锁对象，详情可参考<a href="https://juejin.cn/post/7156111610589741063">《MySQL锁机制实现原理》</a>。</p><p><code>Dict Info</code>：数据字典，主要用来存储<code>MySQL-InnoDB</code>引擎自带的系统表。</p><p><code>redo_log_buffer</code>：<code>redo-log</code>缓冲区，存放写<code>SQL</code>执行时写入的<code>redo</code>记录。</p><p><code>undo_log_buffer</code>：<code>undo-log</code>缓冲区，存放写<code>SQL</code>执行时写入的<code>undo</code>记录。</p><p><code>Adaptivity Hash</code>：自适应哈希索引，<code>InnoDB</code>会为热点索引页，创建相应的哈希索引。</p><p><code>Insert Buffer</code>：写入缓冲区，对于<code>insert</code>的数据，会先放在这里，然后定期刷写磁盘。</p><p><code>Lru List</code>：内存淘汰页列表，对于整个缓冲池的内存管理列表（后续细聊）。</p><p><code>Free List</code>：空闲内存列表，这里面记录着目前未被使用的内存页。</p><p><code>Flush List</code>：脏页内存列表，这里主要记录未落盘的数据。</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL</title>
      <link href="/2023/11/27/MySQL/MySQL/"/>
      <url>/2023/11/27/MySQL/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><img src="11dda1407ff5426285aa18102c2113c4_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0-1324598.webp" alt="11dda1407ff5426285aa18102c2113c4_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0" style="zoom:67%;"><p>从上往下看，依次会分为<code>网络连接层、系统服务层、存储引擎层、以及文件系统层</code>，往往编写<code>SQL</code>后，都会遵守着<code>MySQL</code>的这个架构往下走。</p><ul><li>连接层：主要是指数据库连接池，会负责处理所有客户端接入的工作。</li><li>服务层：主要包含<code>SQL</code>接口、解析器、优化器以及缓存缓冲区四块区域。</li><li>存储引擎层：这里是指<code>MySQL</code>支持的各大存储引擎，如<code>InnoDB、MyISAM</code>等。</li><li>文件系统层：涵盖了所有的日志，以及数据、索引文件，位于系统硬盘上。</li></ul><p><code>show processlist;</code>命令查询所有正在运行的线程</p><h2 id="一、数据库连接池-Connection-Pool"><a href="#一、数据库连接池-Connection-Pool" class="headerlink" title="一、数据库连接池(Connection Pool)"></a>一、数据库连接池(Connection Pool)</h2><p>​连接池的最大线程数可以通过参数<code>max-connections</code>来控制，如果到来的客户端连接超出该值时，新到来的连接都会被拒绝，关于最大连接数的一些命令主要有两条：</p><ul><li><code>show variables like &#39;%max_connections%&#39;;</code>：查询目前<code>DB</code>的最大连接数。</li><li><code>set GLOBAL max_connections = 200;</code>：修改数据库的最大连接数为指定值。</li></ul><h3 id="1、系统服务层"><a href="#1、系统服务层" class="headerlink" title="1、系统服务层"></a>1、系统服务层</h3><img src="1c99681fa9ce43898dfc6e63ae1fd0bc_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0的副本-1324602.webp" alt="1c99681fa9ce43898dfc6e63ae1fd0bc_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0的副本" style="zoom:67%;"><p>在<code>SQL</code>中会分为五大类：</p><ul><li><code>DML</code>：数据库操作语句，比如<code>update、delete、insert</code>等都属于这个分类。</li><li><code>DDL</code>：数据库定义语句，比如<code>create、alter、drop</code>等都属于这个分类。</li><li><code>DQL</code>：数据库查询语句，比如最常见的<code>select</code>就属于这个分类。</li><li><code>DCL</code>：数据库控制语句，比如<code>grant、revoke</code>控制权限的语句都属于这个分类。</li><li><code>TCL</code>：事务控制语句，例如<code>commit、rollback、setpoint</code>等语句属于这个分类。</li></ul><h3 id="2、缓存-缓冲"><a href="#2、缓存-缓冲" class="headerlink" title="2、缓存&amp;缓冲"></a>2、缓存&amp;缓冲</h3><p>​缓冲区的设计主要是：<strong>为了通过内存的速度来弥补磁盘速度较慢对数据库造成的性能影响</strong>。在数据库中读取某页数据操作时，会先将从磁盘读到的页存放在缓冲区中，后续操作相同页的时候，可以基于内存操作。</p><p>​一般来说，当你对数据库进行写操作时，都会先从缓冲区中查询是否有你要操作的页，如果有，则直接对内存中的数据页进行操作（例如修改、删除等），对缓冲区中的数据操作完成后，会直接给客户端返回成功的信息，然后<code>MySQL</code>会在后台利用一种名为<code>Checkpoint</code>的机制，将内存中更新的数据刷写到磁盘。</p><p>​同时缓冲区是与存储引擎有关的，不同的存储引擎实现也不同，比如<code>InnoDB</code>的缓冲区叫做<code>innodb_buffer_pool</code>，而<code>MyISAM</code>则叫做<code>key_buffer</code>。</p><h3 id="3、日志模块"><a href="#3、日志模块" class="headerlink" title="3、日志模块"></a>3、日志模块</h3><p> 在<code>MySQL</code>中主要存在七种常用的日志类型，如下：</p><ul><li><code>binlog</code>二进制日志，主要记录<code>MySQL</code>数据库的所有写操作（增删改）。</li><li><code>redo-log</code>重做&#x2F;重写日志，<code>MySQL</code>崩溃时，对于未落盘的操作会记录在这里面，用于重启时重新落盘（<code>InnoDB</code>专有的）。</li><li><code>undo-logs</code>撤销&#x2F;回滚日志：记录事务开始前[修改数据]的备份，用于回滚事务。</li><li><code>error-log</code>：错误日志：记录<code>MySQL</code>启动、运行、停止时的错误信息。</li><li><code>general-log</code>常规日志，主要记录<code>MySQL</code>收到的每一个查询或<code>SQL</code>命令。</li><li><code>slow-log</code>：慢查询日志，主要记录执行时间较长的<code>SQL</code>。</li><li><code>relay-log</code>：中继日志，主要用于主从复制做数据拷贝。</li></ul><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1、创建索引"><a href="#1、创建索引" class="headerlink" title="1、创建索引"></a>1、创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  INDEX indexName <span class="keyword">ON</span> tableName (columnName(length) [<span class="keyword">ASC</span><span class="operator">*</span><span class="operator">*</span><span class="operator">|</span><span class="operator">*</span><span class="operator">*</span><span class="keyword">DESC</span>]); </span><br></pre></td></tr></table></figure><ul><li><p><code>indexName</code>：当前创建的索引，创建成功后叫啥名字。</p></li><li><p><code>tableName</code>：要在哪张表上创建一个索引，这里指定表名。</p></li><li><p><code>columnName</code>：要为表中的哪个字段创建索引，这里指定字段名。</p></li><li><p><code>length</code>：如果字段存储的值过长，选用值的前多少个字符创建索引。</p></li><li><p><code>ASC|DESC</code>：指定索引的排序方式，<code>ASC</code>是升序，<code>DESC</code>是降序，默认<code>ASC</code>。</p></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> INDEX indexName(columnName(length) [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]);</span><br></pre></td></tr></table></figure><h4 id="2、删除索引"><a href="#2、删除索引" class="headerlink" title="2、删除索引"></a>2、删除索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX indexName <span class="keyword">ON</span> tableName;</span><br></pre></td></tr></table></figure><p>当然，当建立了一条索引后，也可以强制性的为<code>SELECT</code>语句指定索引，如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name FORCE INDEX(index_name) <span class="keyword">WHERE</span> .....;</span><br></pre></td></tr></table></figure><p>这条命令查询一个表中拥有的索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> tableName;</span><br></pre></td></tr></table></figure><img src="4ad9dbbda57c4d5dade247db392c4803_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0-1324607.webp" alt="4ad9dbbda57c4d5dade247db392c4803_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;"><ul><li>①<code>Table</code>：当前索引属于那张表。</li><li>②<code>Non_unique</code>：目前索引是否属于唯一索引，<code>0</code>代表是的，<code>1</code>代表不是。</li><li>③<code>Key_name</code>：当前索引的名字。</li><li>④<code>Seq_in_index</code>：如果当前是联合索引，目前字段在联合索引中排第几个。</li><li>⑤<code>Column_name</code>：当前索引是位于哪个字段上建立的。</li><li>⑥<code>Collation</code>：字段值以什么方式存储在索引中，<code>A</code>表示有序存储，<code>NULL</code>表无序。</li><li>⑦<code>Cardinality</code>：当前索引的散列程度，也就是索引中存储了多少个不同的值。</li><li>⑧<code>Sub_part</code>：当前索引使用了字段值的多少个字符建立，<code>NULL</code>表示全部。</li><li>⑨<code>Packed</code>：表示索引在存储字段值时，以什么方式压缩，<code>NULL</code>表示未压缩，</li><li>⑩<code>Null</code>：当前作为索引字段的值中，是否存在<code>NULL</code>值，<code>YES</code>表示存在。</li><li>⑪<code>Index_type</code>：当前索引的结构（<code>BTREE, FULLTEXT, HASH, RTREE</code>）。</li><li>⑫<code>Comment</code>：创建索引时，是否对索引有备注信息。</li></ul><h4 id="3、多列索引"><a href="#3、多列索引" class="headerlink" title="3、多列索引"></a>3、多列索引</h4><p>​当建立多列索引后，一条<code>SELECT</code>语句，只有当查询条件中了包含了多列索引的第一个字段时，才能使用多列索引，下面举个栗子。</p><p>​比如在用户表中，通过<code>id、name、age</code>三个字段建立一个多列索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 无法使用多列索引的SQL语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_user` <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;竹子&quot; <span class="keyword">AND</span> age <span class="operator">=</span> &quot;18&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 能命中多列索引的SQL语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_user` <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;竹子&quot; <span class="keyword">AND</span> id <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h4 id="4、全文索引"><a href="#4、全文索引" class="headerlink" title="4、全文索引"></a>4、全文索引</h4><p>​全文索引类似于<code>ES、Solr</code>搜索中间件中的分词器，或者说和之前常用的<code>like+%</code>模糊查询很类似，它只能创建在<code>CHAR、VARCHAR、TEXT</code>等这些文本类型字段上，而且使用全文索引查询时，条件字符数量必须大于<code>3</code>才生效。当然，还是举个栗子才有感觉：</p><h3 id="MYSQL各个索引的优劣势"><a href="#MYSQL各个索引的优劣势" class="headerlink" title="MYSQL各个索引的优劣势"></a>MYSQL各个索引的优劣势</h3><h4 id="1、主键索引"><a href="#1、主键索引" class="headerlink" title="1、主键索引"></a>1、主键索引</h4><blockquote><p>数据表的主键，最好选用带顺序性的值，否则有可能掉入主键索引的“陷阱”中。</p></blockquote><h4 id="2、前缀索引"><a href="#2、前缀索引" class="headerlink" title="2、前缀索引"></a>2、前缀索引</h4><blockquote><p>由于其索引节点中，未存储一个字段的完整值，所以<code>MySQL</code>也无法通过前缀索引来完成<code>ORDER BY、GROUP BY</code>等分组排序工作，同时也无法完成覆盖扫描等操作。</p></blockquote><h4 id="3、唯一索引"><a href="#3、唯一索引" class="headerlink" title="3、唯一索引"></a>3、唯一索引</h4><blockquote><p>如果<code>COLUMN_XX</code>字段上建立的是唯一索引，当找到一条数据后就会立马停下检索，因此本身建立唯一索引的字段值就具备唯一性。</p></blockquote><blockquote><p>但插入数据时就不同了，因为要确保数据不重复，所以插入前会检查一遍表中是否存在相同的数据。但普通索引则不需要考虑这个问题，因此普通索引的数据插入会快一些。</p></blockquote><h4 id="4、哈希索引"><a href="#4、哈希索引" class="headerlink" title="4、哈希索引"></a>4、哈希索引</h4><blockquote><p>但哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。</p></blockquote><h4 id="建立索引时遵循的原则"><a href="#建立索引时遵循的原则" class="headerlink" title="建立索引时遵循的原则"></a>建立索引时遵循的原则</h4><p>建立索引时，需要遵守的一些原则：</p><ul><li>①经常频繁用作查询条件的字段应酌情考虑为其创建索引。</li><li>②表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。</li><li>③建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。</li><li>④建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。</li><li>⑤建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。</li><li>⑥经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。</li><li>⑦对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为<code>Hash</code>结构。</li><li>⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。</li></ul><p>同时，除开上述一些建立索引的原则外，在建立索引时还需有些注意点：</p><ul><li>❶值经常会增删改的字段，不合适建立索引，因为每次改变后需维护索引结构。</li><li>❷一个字段存在大量的重复值时，不适合建立索引，比如之前举例的性别字段。</li><li>❸索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。</li><li>❹一张表中的索引数量并不是越多越好，一般控制在<code>3</code>，最多不能超过<code>5</code>。</li><li>❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。</li><li>❻当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。</li><li>❼索引的字段值无序时，不推荐建立索引，因为会造成页分裂，尤其是主键索引。</li></ul><h4 id="联合索引的最左前缀原则"><a href="#联合索引的最左前缀原则" class="headerlink" title="联合索引的最左前缀原则"></a>联合索引的最左前缀原则</h4><p>​联合索引的最左前缀原则，道理很简单的，就是组成联合索引的多个列，越靠左边优先级越高，同时也只有<code>SQL</code>查询条件中，包含了最左的字段，才能使用联合索引，例如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于上面的哪个X、Y、Z联合索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> Y <span class="operator">=</span> &quot;...&quot; <span class="keyword">AND</span> Z <span class="operator">=</span> &quot;...&quot;;   不会使用联合索引</span><br></pre></td></tr></table></figure><h3 id="执行分析工具-Explain"><a href="#执行分析工具-Explain" class="headerlink" title="执行分析工具 - Explain"></a>执行分析工具 - Explain</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_users`;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------+---------------+------+---------+------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> zz_users <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------+---------------+------+---------+------+------+-------+</span></span><br></pre></td></tr></table></figure><p><code>id</code>：这是执行计划的<code>ID</code>值，这个值越大，表示执行的优先级越高。</p><p><code>select_type</code>：当前查询语句的类型，有如下几个值：</p><ul><li><code>simple</code>：简单查询。</li><li><code>primary</code>：复杂查询的外层查询。</li><li><code>subquery</code>：包含在查询语句中的子查询。</li><li><code>derived</code>：包含在<code>FROM</code>中的子查询。</li></ul><p><code>table</code>：表示当前这个执行计划是基于那张表执行的。</p><p><code>type</code>：当前执行计划查询的类型，有几种情况：</p><ul><li><code>all</code>：表示走了全表查询，未命中索引或索引失效。</li><li><code>system</code>：表示要查询的表中仅有一条数据。</li><li><code>const</code>：表示当前<code>SQL</code>语句的查询条件中，可以命中索引查询。</li><li><code>range</code>：表示当前查询操作是查某个区间。</li><li><code>eq_ref</code>：表示目前在做多表关联查询。</li><li><code>ref</code>：表示目前使用了普通索引查询。</li><li><code>index</code>：表示目前<code>SQL</code>使用了辅助索引查询。</li></ul><p><code>possible_keys</code>：执行<code>SQL</code>时，优化器可能会选择的索引（最后执行不一定用）。</p><p><code>key</code>：查询语句执行时，用到的索引名字。</p><p><code>key_len</code>：这里表示索引字段使用的字节数。</p><p><code>ref</code>：这里显示使用了那种查询的类型。</p><p><code>rows</code>：当前查询语句可能会扫描多少行数据才能检索出结果。</p><p><code>Extra</code>：这里是记录着额外的一些索引使用信息，有几种状态：</p><ul><li><code>using index</code>：表示目前使用了覆盖索引查询（稍后讲）。</li><li><code>using where</code>：表示使用了<code>where</code>子句查询，通常表示没使用索引。</li><li><code>using index condition</code>：表示查询条件使用到了联合索引的前面几个字段。</li><li><code>using temporary</code>：表示使用了临时表处理查询结果。</li><li><code>using filesort</code>：表示以索引字段之外的方式进行排序，效率较低。</li><li><code>select tables optimized away</code>：表示在索引字段上使用了聚合函数</li></ul><h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul><li><p>查询中带有OR会导致索引失效</p></li><li><p>模糊查询中like以%开头导致索引失效</p></li><li><p>字符类型查询时不带引号导致索引失效</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先插入一条user_name = 1111 的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `zz_users` <span class="keyword">VALUES</span>(<span class="number">4</span>,&quot;1111&quot;,&quot;男&quot;,&quot;4321&quot;,&quot;2022-09-17 23:48:29&quot;);</span><br><span class="line"></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_users` <span class="keyword">WHERE</span> user_name <span class="operator">=</span> <span class="number">111</span>;</span><br></pre></td></tr></table></figure></li><li><p>索引字段参与计算导致索引失效</p></li><li><p>字段被用于函数计算导致索引失效</p></li><li><p>违背最左前缀原则导致索引失效</p></li><li><p>不同字段值比对导致索引失效</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_users` <span class="keyword">WHERE</span> user_name <span class="operator">=</span> user_sex;</span><br></pre></td></tr></table></figure></li><li><p>反向范围操作</p><blockquote><p>一般来说，如果<code>SQL</code>属于正向范围查询，例如<code>&gt;、&lt;、between、like、in...</code>等操作时，索引是可以正常生效的，但如果<code>SQL</code>执行的是反向范围操作，例如<code>NOT IN、NOT LIKE、IS NOT NULL、!=、&lt;&gt;...</code>等操作时，就会出现问题，例如：</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_users` <span class="keyword">WHERE</span> user_id <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ul><p><code>MyISAM</code>引擎的表，在磁盘中有三个文件：</p><ul><li><code>zz_myisam_index.frm</code>：该文件中存储表的结构信息。</li><li><code>zz_myisam_index.MYD</code>：该文件中存储表的行数据。</li><li><code>zz_myisam_index.MYI</code>：该文件中存储表的索引数据。</li></ul><p>也就是说，<code>MyISAM</code>引擎的表数据和索引数据，是分别放在两个不同的磁盘文件中存储的，这也意味着<code>MyISAM</code>引擎并不支持聚簇索引，因为聚簇索引要求表数据和索引数据一起存储在同一块空间，而<code>MyISAM</code>的<code>.MYI</code>索引文件中，存储的是表数据所在的地址指针。</p><p><code>InnoDB</code>引擎的表，在磁盘中仅有两个文件：</p><ul><li><code>zz_innodb_index.frm</code>：该文件中存储表的结构信息。</li><li><code>zz_innodb_index.ibd</code>：该文件中存储表的行数据和索引数据。</li></ul><p>因为<code>InnoDB</code>引擎中，表数据和索引数据都一起放在<code>.ibd</code>文件中，也就代表着索引数据和表数据是处于同一块空间存储的，这符合聚簇索引的定义，因此<code>InnoDB</code>支持聚簇索引。</p><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="Atomicity原子性"><a href="#Atomicity原子性" class="headerlink" title="Atomicity原子性"></a>Atomicity原子性</h4><p>指组成一个事务的一组<code>SQL</code>要么全部执行成功，要么全部执行失败，事务中的一组<code>SQL</code>会被看成一个不可分割的整体，当成一个操作看待。</p><h4 id="Consistency一致性"><a href="#Consistency一致性" class="headerlink" title="Consistency一致性"></a>Consistency一致性</h4><p>一致性也比较好理解，也就是不管事务发生的前后，<code>MySQL</code>中原本的数据变化都是一致的，也就是<code>DB</code>中的数据只允许从一个一致性状态变化为另一个一致性状态。这句话似乎听起来有些绕，不太好理解对嘛？简单解释一下就是：一个事务中的所有操作，要么一起改变数据库中的数据，要么都不改变，对于其他事务而言，数据的变化是一致的。</p><h4 id="Isolation独立性-隔离性"><a href="#Isolation独立性-隔离性" class="headerlink" title="Isolation独立性&#x2F;隔离性"></a>Isolation独立性&#x2F;隔离性</h4><p>指多个事务之间都是独立的，相当于每个事务都被装在一个箱子中，每个箱子之间都是隔开的，相互之间并不影响。</p><h4 id="Durability持久性"><a href="#Durability持久性" class="headerlink" title="Durability持久性"></a>Durability持久性</h4><p>持久性是指一个事务一旦被提交，它会保持永久性，所更改的数据都会被写入到磁盘做持久化处理，就算<code>MySQL</code>宕机也不会影响数据改变，因为宕机后也可以通过日志恢复数据。</p><h3 id="手动管理事务"><a href="#手动管理事务" class="headerlink" title="手动管理事务"></a>手动管理事务</h3><ul><li><code>start transaction | begin | begin work</code>：开启一个事务</li><li><code>commit</code>：提交一个事务</li><li><code>rollback</code>：回滚一个事务</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第一条SQL语句</span></span><br><span class="line"><span class="comment">-- 第二条SQL语句</span></span><br><span class="line"><span class="comment">-- 第三条SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交或回滚事务</span></span><br><span class="line"><span class="keyword">commit</span> <span class="operator">||</span> <span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h4 id="事务回滚点"><a href="#事务回滚点" class="headerlink" title="事务回滚点"></a>事务回滚点</h4><p>在<code>MySQL</code>中提供了两个关于事务回滚点的命令：</p><ul><li><code>savepoint point_name</code>：添加一个事务回滚点</li><li><code>rollback to point_name</code>：回滚到指定的事务回滚点</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先查询一次用户表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_users`;</span><br><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="comment">-- 修改 ID=4 的姓名为：黑熊</span></span><br><span class="line"><span class="keyword">update</span> `zz_users` <span class="keyword">set</span> `user_name` <span class="operator">=</span> &quot;黑熊&quot; <span class="keyword">where</span> `user_id` <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 添加一个事务回滚点：update_name</span></span><br><span class="line"><span class="keyword">savepoint</span> update_name;</span><br><span class="line"><span class="comment">-- 删除 ID=1 的行数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> `zz_users` <span class="keyword">where</span> `user_id` <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 回滚到 update_name 这个事务点</span></span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> update_name;</span><br><span class="line"><span class="comment">-- 再次查询一次数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `zz_users`;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><h3 id="MySQL事务的隔离机制"><a href="#MySQL事务的隔离机制" class="headerlink" title="MySQL事务的隔离机制"></a>MySQL事务的隔离机制</h3><p>在<code>MySQL</code>中，事务隔离机制分为了四个级别：</p><ul><li>①<code>Read uncommitted/RU</code>：读未提交</li><li>②<code>Read committed/RC</code>：读已提交</li><li>③<code>Repeatable read/RR</code>：可重复读(MySQL默认)</li><li>④<code>Serializable</code>：序列化&#x2F;串行化</li></ul><h4 id="脏读、幻读、不可重复读问题"><a href="#脏读、幻读、不可重复读问题" class="headerlink" title="脏读、幻读、不可重复读问题"></a>脏读、幻读、不可重复读问题</h4><h5 id="脏读问题"><a href="#脏读问题" class="headerlink" title="脏读问题"></a>脏读问题</h5><p>脏读的意思是指一个事务读到了其他事务还未提交的数据，也就是当前事务读到的数据，由于还未提交，因此有可能会回滚。</p><h5 id="不可重复读问题"><a href="#不可重复读问题" class="headerlink" title="不可重复读问题"></a>不可重复读问题</h5><p>不可重复读问题是指在一个事务中，多次读取同一数据，先后读取到的数据不一致。</p><h5 id="幻读问题"><a href="#幻读问题" class="headerlink" title="幻读问题"></a>幻读问题</h5><p>幻读：指同一个事务内多次查询返回的结果集不一样。比如同一个事务<code>A</code>，在第一次查询表的数据行数时，发现表中有<code>n</code>条行记录，但是第二次以同等条件查询时，却发现有<code>n+1</code>条记录，这就好像产生了幻觉。</p><p>发生幻读问题的原因是在于：另外一个事务在第一个事务要处理的目标数据范围之内新增了数据，然后先于第一个事务提交造成的问题。</p><p>①<strong>读未提交</strong></p><p>​处于该隔离级别的数据库，脏读、不可重复读、幻读问题都有可能发生。</p><p>​这种隔离级别是基于「写互斥锁」实现的，当一个事务开始写某一个数据时，另外一个事务也来操作同一个数据，此时为了防止出现问题则需要先获取锁资源，只有获取到锁的事务，才允许对数据进行写操作，同时获取到锁的事务具备排他性&#x2F;互斥性，也就是其他线程无法再操作这个数据。</p><blockquote><p>但虽然这个级别中，写同一数据时会互斥，但读操作却并不是互斥的，也就是当一个事务在写某个数据时，就算没有提交事务，其他事务来读取该数据时，也可以读到未提交的数据，因此就会导致脏读、不可重复读、幻读一系列问题出现。</p></blockquote><p>②<strong>读已提交</strong></p><p>​处于该隔离级别的数据库，解决了脏读问题，不可重复读、幻读问题依旧存在。</p><p>​在这个隔离级别中，对于写操作同样会使用「写互斥锁」，也就是两个事务操作同一事务时，会出现排他性，而对于读操作则使用了一种名为<code>MVCC</code>多版本并发控制的技术处理，也就是有事务中的<code>SQL</code>需要读取当前事务正在操作的数据时，<code>MVCC</code>机制不会让另一个事务读取正在修改的数据，而是读取上一次提交的数据（也就是读原本的老数据）。</p><p>③<strong>可重复读</strong></p><p>​处于该隔离级别的数据库，解决了脏读、不可重复读问题，幻读问题依旧存在。</p><p>在可重复读级别中，则不会每次查询时都创建新的<code>ReadView</code>，而是在一个事务中，只有第一次执行查询会创建一个<code>ReadView</code>，在这个事务的生命周期内，所有的查询都会从这一个<code>ReadView</code>中读取数据，从而确保了一个事务中多次读取相同数据是一致的，也就是解决了不可重复读问题。</p><p>④<strong>序列化&#x2F;串行化</strong></p><p>​处于该隔离级别的数据库，解决了脏读、不可重复读、幻读问题都不存在。</p><p>​序列化意思是将所有的事务按序排队后串行化处理，也就是操作同一张表的事务只能一个一个执行，事务在执行前需要先获取表级别的锁资源，拿到锁资源的事务才能执行，其余事务则陷入阻塞，等待当前事务释放锁。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式①：查询当前数据库的隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx_isolation</span>;</span><br><span class="line"><span class="comment">-- 方式②：查询当前数据库的隔离级别</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%tx_isolation%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置隔离级别为RU级别（当前连接生效）</span></span><br><span class="line"><span class="keyword">set</span> transaction isolation level read uncommitted;</span><br><span class="line"><span class="comment">-- 设置隔离级别为RC级别（全局生效）</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read committed;</span><br><span class="line"><span class="comment">-- 设置隔离级别为RR级别（当前连接生效）</span></span><br><span class="line"><span class="comment">-- 这里和上述的那条命令作用相同，是第二种设置的方式</span></span><br><span class="line"><span class="keyword">set</span> tx_isolation <span class="operator">=</span> <span class="string">&#x27;repeatable-read&#x27;</span>;</span><br><span class="line"><span class="comment">-- 设置隔离级别为最高的serializable级别（全局生效）</span></span><br><span class="line"><span class="keyword">set</span> global.tx_isolation <span class="operator">=</span> <span class="string">&#x27;serializable&#x27;</span>; </span><br></pre></td></tr></table></figure><h3 id="MySQL事务实现原理"><a href="#MySQL事务实现原理" class="headerlink" title="MySQL事务实现原理"></a>MySQL事务实现原理</h3><h4 id="单条SQL的事务机制"><a href="#单条SQL的事务机制" class="headerlink" title="单条SQL的事务机制"></a>单条SQL的事务机制</h4><p>任意一条写<code>SQL</code>的执行都会记录三个日志：<code>undo-log、redo-log、bin-log</code>。</p><ul><li><code>undo-log</code>：主要记录<code>SQL</code>的撤销日志，比如目前是<code>insert</code>语句，就记录一条<code>delete</code>日志。</li><li><code>redo-log</code>：记录当前<code>SQL</code>归属事务的状态，以及记录修改内容和修改页的位置。</li><li><code>bin-log</code>：记录每条<code>SQL</code>操作日志，只要是用于数据的主从复制与数据恢复&#x2F;备份。</li></ul><blockquote><p><code>redo-log</code>是一种<code>WAL(Write-ahead logging)</code>预写式日志，在数据发生更改之前会先记录日志，也就是在<code>SQL</code>执行前会先记录一条<code>prepare</code>状态的日志，然后再执行数据的写操作。</p></blockquote><p>​<code>MySQL</code>是基于磁盘的，但磁盘的写入速度相较内存而言会较慢，因此<code>MySQL-InnoDB</code>引擎中不会直接将数据写入到磁盘文件中，而是会先写到<code>BufferPool</code>缓冲区中，当<code>SQL</code>被成功写入到缓冲区后，紧接着会将<code>redo-log</code>日志中相应的记录改为<code>commit</code>状态，然后再由<code>MySQL</code>刷盘机制去做具体的落盘操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 先记录一条状态为 prepare 的日志</span></span><br><span class="line"><span class="comment">-- 然后执行SQL，在缓冲区中更改对应的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `zz_users` <span class="keyword">VALUES</span>(<span class="number">5</span>,&quot;黑竹&quot;,&quot;男&quot;,&quot;9999&quot;,&quot;2022-09-24 23:48:29&quot;);</span><br><span class="line"><span class="comment">-- 写入缓冲区成功后，将日志记录改为 commit状态</span></span><br><span class="line"><span class="comment">-- 返回 [Affected rows: 1]，MySQL后台线程执行刷盘动作</span></span><br></pre></td></tr></table></figure><h2 id="四、MySQL锁机制"><a href="#四、MySQL锁机制" class="headerlink" title="四、MySQL锁机制"></a>四、MySQL锁机制</h2><p><code>MySQL</code>的锁机制与索引机制类似，都是由存储引擎负责实现的</p><p><strong>以锁粒度的维度划分：</strong></p><ul><li>①表锁：<ul><li>全局锁：加上全局锁之后，整个数据库只能允许读，不允许做任何写操作。</li><li>元数据锁 &#x2F; <code>MDL</code>锁：基于表的元数据加锁，加锁后整张表不允许其他事务操作。</li><li>意向锁：这个是<code>InnoDB</code>中为了支持多粒度的锁，为了兼容行锁、表锁而设计的。</li><li>自增锁 &#x2F; <code>AUTO-INC</code>锁：这个是为了提升自增ID的并发插入性能而设计的。</li></ul></li><li>②页面锁</li><li>③行锁：<ul><li>记录锁 &#x2F; <code>Record</code>锁：也就是行锁，一条记录和一行数据是同一个意思。</li><li>间隙锁 &#x2F; <code>Gap</code>锁：<code>InnoDB</code>中解决幻读问题的一种锁机制。</li><li>临建锁 &#x2F; <code>Next-Key</code>锁：间隙锁的升级版，同时具备记录锁+间隙锁的功能。</li></ul></li></ul><p>以互斥性的维度划分：</p><ul><li>共享锁 &#x2F; <code>S</code>锁 Shared Lock：不同事务之间不会相互排斥、可以同时获取的锁。</li><li>排他锁 &#x2F; <code>X</code>锁 Exclusive Lock：不同事务之间会相互排斥、同时只能允许一个事务获取的锁。</li><li>共享排他锁 &#x2F; <code>SX</code>锁：<code>MySQL5.7</code>版本中新引入的锁，主要是解决<code>SMO</code>带来的问题。</li></ul><p>以操作类型的维度划分：</p><ul><li>读锁：查询数据时使用的锁。</li><li>写锁：执行插入、删除、修改、<code>DDL</code>语句时使用的锁。</li></ul><p>以加锁方式的维度划分：</p><ul><li>显示锁：编写<code>SQL</code>语句时，手动指定加锁的粒度。</li><li>隐式锁：执行<code>SQL</code>语句时，根据隔离级别自动为<code>SQL</code>操作加锁。</li></ul><p>以思想的维度划分：</p><ul><li>乐观锁：每次执行前认为自己会成功，因此先尝试执行，失败时再获取锁。</li><li>悲观锁：每次执行前都认为自己无法成功，因此会先获取锁，然后再执行。</li></ul><p><strong>共享锁</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- MySQL8.0之后也优化了写法，如下：</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 窗口1：</span></span><br><span class="line"><span class="comment">-- 开启一个事务</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="comment">-- 获取共享锁并查询 ID=1 的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `zz_users` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br></pre></td></tr></table></figure><p><strong>排他锁</strong></p><p>​排他锁并不是只能用于写操作，对于一个读操作，咱们也可以手动的指定为获取排他锁，当一个事务在读数据时，获取了排他锁，那当其他事务来读、写同一数据时，都会被排斥，比如事务<code>T1</code>对<code>ID=88</code>的这条数据加了一个排他锁，此时<code>T2</code>来加排他锁读取这条数据，<code>T3</code>来修改这条数据，都会被<code>T1</code>排斥。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> UPTATE;</span><br></pre></td></tr></table></figure><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><blockquote><p>一张表只能存在一个同一类型的表锁。</p></blockquote><p><code>InnoDB</code>是一个支持多粒度锁的存储引擎，它的锁机制是基于聚簇索引实现的，当<code>SQL</code>执行时，如果能在聚簇索引命中数据，则加的是行锁，如无法命中聚簇索引的数据则加的是表锁，比如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `zz_users` <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>这条<code>SQL</code>就无法命中聚簇索引，此时自然加的就是表级别的排他锁，但是这个表级锁，并不是真正意义上的表锁，是一个“伪表锁”，但作用是相同的，锁了整张表。</p><p><strong>元数据锁(Meta Data Lock)</strong></p><blockquote><p>更改表结构时使用</p></blockquote><p><strong>意向锁（Intention Lock）</strong></p><p>​当事务<code>T2</code>尝试获取一个表级锁时，就会先看一下表上是否有意向锁，如果有的话再判断一下与自身是否冲突，比如表上存在一个意向共享锁，目前<code>T2</code>要获取的是表级别的读锁，那自然不冲突可以获取。但反之，如果<code>T2</code>要获取一个表记的写锁时，就会出现冲突，<code>T2</code>事务则会陷入阻塞，直至<code>T1</code>释放了锁（事务结束）为止。</p><p><strong>自增锁（AUTO-INC Lock）</strong></p><p><strong>自增锁主要负责维护并发事务下自增列的顺序</strong></p><ul><li><code>innodb_autoinc_lock_mode = 0</code>：传统模式。</li><li><code>innodb_autoinc_lock_mode = 1</code>：连续模式（<code>MySQL8.0</code>以前的默认模式）。</li><li><code>innodb_autoinc_lock_mode = 2</code>：交错模式（<code>MySQL8.0</code>之后的默认模式）。</li></ul><p><code>MySQL</code>中可能出现的三种插入类型：</p><ul><li>普通插入：指通过<code>INSERT INTO table_name(...) VALUES(...)</code>这种方式插入。</li><li>批量插入：指通过<code>INSERT ... SELECT ...</code>这种方式批量插入查询出的数据。</li><li>混合插入：指通过<code>INSERT INTO table_name(id,...) VALUES(1,...),(NULL,...),(3,...)</code>这种方式插入，其中一部分指定<code>ID</code>，一部分不指定。</li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p><strong>记录锁（Record Lock）</strong></p><blockquote><p>实际上就是行锁</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取行级别的 共享锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `zz_users` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 获取行级别的 排他锁</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `zz_users` <span class="keyword">where</span> user_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p><strong>间隙锁（Gap Lock）</strong></p><blockquote><p>主要是用来解决幻读问题的</p></blockquote><p><strong>乐观锁</strong></p><p>每次执行都认为只会有自身一条线程操作，因此无需拿锁直接执行。</p><p>在<code>MySQL</code>中则可以通过<code>version</code>版本号+<code>CAS</code>的形式实现乐观锁，也就是在表中多设计一个<code>version</code>字段，然后在<code>SQL</code>修改时以如下形式操作：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> ... <span class="keyword">SET</span> version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> ... <span class="keyword">WHERE</span> ... <span class="keyword">AND</span> version <span class="operator">=</span> version;</span><br></pre></td></tr></table></figure><p><strong>乐观锁更加适用于读大于写的业务场景，频繁写库的业务则并不适合加乐观锁</strong></p><p><strong>悲观锁</strong></p><p>在每次执行前必须获取到锁，然后才能继续往下执行，而数据库中的排他锁，就是一种典型的悲观锁类型。</p><h3 id="五、MySQL-MVCC机制"><a href="#五、MySQL-MVCC机制" class="headerlink" title="五、MySQL-MVCC机制"></a>五、MySQL-MVCC机制</h3><p>  <code>MVCC</code>机制的全称为<code>Multi-Version Concurrency Control</code>，即&#x3D;&#x3D;多版本并发控制技术&#x3D;&#x3D;，主要是为了提升数据库并发性能而设计的，其中采用更好的方式处理了读-写并发冲突，做到即使有读写冲突时，也可以不加锁解决，从而确保了任何时刻的读操作都是非阻塞的。&#x3D;&#x3D;只有InnoDB实现了MVCC机制&#x3D;&#x3D;</p><h3 id="1、MySQL-MVCC多版本并发控制"><a href="#1、MySQL-MVCC多版本并发控制" class="headerlink" title="1、MySQL-MVCC多版本并发控制"></a>1、MySQL-MVCC多版本并发控制</h3><p> <code>MySQL</code>中的多版本并发控制，也和上面给出的例子类似，毕竟回想一下，脏读、不可重复读、幻读问题都是由于多个事务并发读写导致的，但这些问题都是基于最新版本的数据并发操作才会出现，那如果读、写的事务操作的不是同一个版本呢？比如写操作走新版本，读操作走老版本，这样是不是无论执行写操作的事务干了啥，都不会影响读的事务？答案是<code>Yes</code>。</p><blockquote><p>不过要稍微记住，<code>MySQL</code>中仅在<code>RC</code>读已提交级别、<code>RR</code>可重复读级别才会使用<code>MVCC</code>机制，<code>Why</code>？</p></blockquote><p>因为如果是<code>RU</code>读未提交级别，既然都允许存在脏读问题、允许一个事务读取另一个事务未提交的数据，那自然可以直接读最新版本的数据，因此无需<code>MVCC</code>介入。</p><p>同时如若是<code>Serializable</code>串行化级别，因为会将所有的并发事务串行化处理，也就是不论事务是读操作，亦或是写操作，都会被排好队一个个执行，这都不存在所谓的多线程并发问题了，自然也无需<code>MVCC</code>介入。</p><h3 id="2、MySQL-MVCC机制实现原理"><a href="#2、MySQL-MVCC机制实现原理" class="headerlink" title="2、MySQL-MVCC机制实现原理"></a>2、MySQL-MVCC机制实现原理</h3><p><code>MVCC</code>机制主要通过隐藏字段、<code>Undo-log</code>日志、<code>ReadView</code>这三个东西实现的。</p><p><strong>隐藏主键-ROW_ID(6bytes)</strong></p><p>对于<code>InnoDB</code>引擎的表而言，由于其表数据是按照聚簇索引的格式存储，因此通常都会选择主键作为聚簇索引列，然后基于主键字段构建索引树，但如若表中未定义主键，则会选择一个具备唯一非空属性的字段，作为聚簇索引的字段来构建树。</p><blockquote><p>当两者都不存在时，<code>InnoDB</code>就会隐式定义一个顺序递增的列<code>ROW_ID</code>来作为聚簇索引列。</p></blockquote><h3 id="六、MySQL死锁"><a href="#六、MySQL死锁" class="headerlink" title="六、MySQL死锁"></a>六、MySQL死锁</h3><p>​1、锁超时机制</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_lock_wait_timeout&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_lock_wait_timeout <span class="operator">|</span> <span class="number">50</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------+-------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、死锁检测算法 wait-for graph</p><p><code>wait-for graph</code>算法被启用后，会要求<code>MySQL</code>收集两个信息：</p><ul><li>锁的信息链表：目前持有每个锁的事务是谁。</li><li>事务等待链表：阻塞的事务要等待的锁是谁。</li></ul><blockquote><p>但出现死锁问题时，<code>MySQL</code>会选择哪个事务回滚呢？之前分析过，当一个事务在执行<code>SQL</code>更改数据时，都会记录在<code>Undo-log</code>日志中，<code>Undo</code>量越小的事务，代表它对数据的更改越少，同时回滚的代价最低，因此会选择<code>Undo</code>量最小的事务回滚（如若两个事务的<code>Undo</code>量相同，会选择回滚触发死锁的事务）。</p></blockquote><p>3、如何避免死锁产生？</p><p>因为死锁的检测过程较为耗时，所以尽量不要等死锁出现后再去解除，而是尽量调整业务避免死锁的产生，一般来说可以从如下方面考虑：</p><ul><li>合理的设计索引结构，使业务<code>SQL</code>在执行时能通过索引定位到具体的几行数据，减小锁的粒度。</li><li>业务允许的情况下，也可以将隔离级别调低，因为级别越低，锁的限制会越小。</li><li>调整业务<code>SQL</code>的逻辑顺序，较大、耗时较长的事务尽量放在特定时间去执行（如凌晨对账…）。</li><li>尽可能的拆分业务的粒度，一个业务组成的大事务，尽量拆成多个小事务，缩短一个事务持有锁的时间。</li><li>如果没有强制性要求，就尽量不要手动在事务中获取排他锁，否则会造成一些不必要的锁出现，增大产生死锁的几率。</li><li>……..</li></ul><h3 id="2-1、锁的内存结构"><a href="#2-1、锁的内存结构" class="headerlink" title="2.1、锁的内存结构"></a>2.1、锁的内存结构</h3><p>在<code>Java</code>中，<code>Synchronized</code>锁是基于<code>Monitor</code>实现的，而<code>ReetrantLock</code>又是基于<code>AQS</code>实现的，那<code>MySQL</code>的锁是基于啥实现的呢？想要搞清楚这点，得先弄明白锁的内存结构，先看图：</p><img src="锁结构-1324618.webp" alt="锁结构" style="zoom:67%;"><p> <code>InnoDB</code>引擎中，每个锁对象在内存中的结构如上，其中记录的信息也比较多，先全部理清楚后再聊聊锁的实现。</p><h4 id="2-1-1、锁的事务信息"><a href="#2-1-1、锁的事务信息" class="headerlink" title="2.1.1、锁的事务信息"></a>2.1.1、锁的事务信息</h4><p>其中记录着当前的锁结构是由哪个事务生成的，记录的是指针，指向一个具体的事务。</p><h4 id="2-1-2、索引的信息"><a href="#2-1-2、索引的信息" class="headerlink" title="2.1.2、索引的信息"></a>2.1.2、索引的信息</h4><p>这个是行锁的特有信息，对于行锁来说，需要记录一下加锁的行数据属于哪个索引、哪个节点，记录的也是指针。</p><h4 id="2-1-3、锁粒度信息"><a href="#2-1-3、锁粒度信息" class="headerlink" title="2.1.3、锁粒度信息"></a>2.1.3、锁粒度信息</h4><p>这个略微有些复杂，对于不同粒度的锁，其中存储的信息也并不同，如果是表锁，其中就记录了一下是对哪张表加的锁，以及表的一些其他信息。</p><p>但如果锁粒度是行锁，其中记录的信息更多，有三个较为重要的：</p><ul><li><code>Space ID</code>：加锁的行数据，所在的表空间<code>ID</code>。</li><li><code>Page Number</code>：加锁的行数据，所在的页号。</li><li><code>n_bits</code>：使用的比特位，对于一页数据中，加了多少个锁（后续结合讲）。</li></ul><h4 id="2-1-4、锁类型信息"><a href="#2-1-4、锁类型信息" class="headerlink" title="2.1.4、锁类型信息"></a>2.1.4、锁类型信息</h4><p>对于锁结构的类型，在内部实现了复用，采用一个<code>32bit</code>的<code>type_mode</code>来表示，这个<code>32bit</code>的值可以拆为<code>lock_mode、lock_type、rec_lock_type</code>三部分，如下：</p><img src="锁结构类型-1324622.webp" alt="锁结构" style="zoom:67%;"><p><code>lock_mode</code>：表示锁的模式，使用低四位。</p><ul><li><code>0000/0</code>：表示当前锁结构是共享意向锁，即<code>IS</code>锁。</li><li><code>0001/1</code>：表示当前锁结构是排他意向锁，即<code>IX</code>锁。</li><li><code>0010/2</code>：表示当前锁结构是共享锁，即<code>S</code>锁。</li><li><code>0011/3</code>：表示当前锁结构是排他锁，即<code>X</code>锁。</li><li><code>0100/4</code>：表示当前锁结构是自增锁，即<code>AUTO-INC</code>锁。</li></ul><p><code>lock_type</code>：表示锁的类型，使用低位中的<code>5~8</code>位。</p><ul><li><code>LOCK_TABLE</code>：当第<code>5</code>个比特位是<code>1</code>时，表示目前是表级锁。</li><li><code>LOCK_REC</code>：当第<code>6</code>个比特位是<code>1</code>时，表示目前是行级锁。</li></ul><p><code>rec_lock_type</code>：表示行锁的具体类型，使用其余位。</p><ul><li><code>LOCK_ORDINARY</code>：当高<code>23</code>位全零时，表示目前是临键锁。</li><li><code>LOCK_GAP</code>：当第<code>10</code>位是<code>1</code>时，表示目前是间隙锁。</li><li><code>LOCK_REC_NOT_GAP</code>：当第<code>11</code>位是<code>1</code>时，表示目前是记录锁。</li><li><code>LOCK_INSERT_INTENTION</code>：当第<code>12</code>位是<code>1</code>时，表示目前是插入意向锁。</li><li><code>.....</code>：内部还有一些其他的锁类型，会使用其他位。</li></ul><p><code>is_waiting</code>：表示目前锁处于等待状态还是持有状态，使用低位中的第<code>9</code>位。</p><ul><li><code>0</code>：表示<code>is_waiting=false</code>，即当前锁无需阻塞等待，是持有状态。</li><li><code>1</code>：表示<code>is_waiting=true</code>，即当前锁需要阻塞，是等待状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Saas多租户数据库隔离</title>
      <link href="/2023/11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB/"/>
      <url>/2023/11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="SaaS-多租户【数据库隔离】"><a href="#SaaS-多租户【数据库隔离】" class="headerlink" title="SaaS 多租户【数据库隔离】"></a>SaaS 多租户【数据库隔离】</h1><p>本章节，讲解 SaaS 租户的 DATASOURCE 模式，实现数据库级别的隔离。</p><p>注意，需要前置阅读 <a href="https://doc.iocoder.cn/saas-tenant">《SaaS 多租户【字段隔离】》</a> 文档。</p><h2 id="0-极速体验"><a href="#0-极速体验" class="headerlink" title="#0. 极速体验"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_0-%E6%9E%81%E9%80%9F%E4%BD%93%E9%AA%8C">#</a>0. 极速体验</h2><p>① 克隆 <a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro">https://gitee.com/zhijiantianya/ruoyi-vue-pro (opens new window)</a>仓库，并切换到 <code>feature/dev-yunai</code> 分支。</p><p>② 创建 <code>ruoyi-vue-pro-master</code>、<code>ruoyi-vue-pro-tenant-a</code>、<code>ruoyi-vue-pro-tenant-b</code> 三个数据库。</p><p>③ 下载 <a href="https://doc.iocoder.cn/file/%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%A4%9Adb.zip"><code>多租户多db.zip</code></a> 并解压，将 SQL 导入到对应的数据库中。</p><p>友情提示：</p><p>随着版本的迭代，SQL 脚本可能过期。如果碰到问题，可以在星球给我反馈下。</p><p>④ 启动前端和后端项目，即可愉快的体验了。</p><h2 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="#1. 实现原理"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_1-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">#</a>1. 实现原理</h2><p>DATASOURCE 模式，基于 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter">dynamic-datasource (opens new window)</a>进行拓展实现。</p><p>核心：每次对数据库操作时，动态切换到该租户所在的数据源，然后执行 SQL 语句。</p><h2 id="2-功能演示"><a href="#2-功能演示" class="headerlink" title="#2. 功能演示"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_2-%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA">#</a>2. 功能演示</h2><p><strong>我们来新增一个租户，使用 DATASOURCE 模式。</strong></p><p>① 点击 [基础设施 -&gt; 数据源配置] 菜单，点击 [新增] 按钮，新增一个名字为 <code>tenant-a</code> 数据源。</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/%E6%96%B0%E5%A2%9E%E6%95%B0%E6%8D%AE%E6%BA%90.png" alt="新增数据源"></p><p>然后，手动将如下表拷贝到 <code>ruoyi-vue-pro</code> 主库中的如下表，拷贝到 <code>ruoyi-vue-pro-tenant-a</code> 库中。如下图所示：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/%E6%8B%B7%E8%B4%9D%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="拷贝表结构到数据源"></p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">system_dept</span><br><span class="line">system_login_log</span><br><span class="line">system_notice</span><br><span class="line">system_notify_message</span><br><span class="line">system_operate_log</span><br><span class="line">system_post</span><br><span class="line">system_role</span><br><span class="line">system_role_menu</span><br><span class="line">system_social_user</span><br><span class="line">system_social_user_bind</span><br><span class="line">system_user_post</span><br><span class="line">system_user_role</span><br><span class="line">system_users</span><br></pre></td></tr></table></figure><p>友情提示：</p><p>随着版本的迭代，可能需要拷贝更多的表。如果碰到问题，可以在星球给我反馈下。</p><p>② 点击 [基础设施 -&gt; 租户管理] 菜单，点击 [新增] 按钮，新增一个名字为 <code>土豆租户</code> 的租户，并使用 <code>tenant-a</code> 数据源。如下图所示：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/%E6%96%B0%E5%A2%9E%E7%A7%9F%E6%88%B7.png" alt="新增租户"></p><p>此时，在 <code>ruoyi-vue-pro-tenant-a</code> 库中，可以查询到对应的租户管理员、角色等信息。如下图所示：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%88%B7.png" alt="查询用户"></p><p>③ 退出系统，登录刚创建的租户。</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2.png" alt="登录界面"></p><p>至此，我们已经完成了租户的创建。</p><p>补充说明：</p><p>后续在使用时，建议把拷贝到其它租户数据库的表，从 <code>ruoyi-vue-pro</code> 主库中进行删除。</p><p>目的是，主库只保留所有租户共享的全局表。例如说，菜单表、定时任表等等。</p><h2 id="3-创建表"><a href="#3-创建表" class="headerlink" title="#3. 创建表"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_3-%E5%88%9B%E5%BB%BA%E8%A1%A8">#</a>3. 创建表</h2><p>在使用 DATASOURCE 模式时，数据库可以分为两种：主库、租户库。</p><h3 id="3-1-主库"><a href="#3-1-主库" class="headerlink" title="#3.1 主库"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_3-1-%E4%B8%BB%E5%BA%93">#</a>3.1 主库</h3><p>① 存放所有租户共享的表。例如说：菜单表、定时任务表等等。如下图所示：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/%E4%B8%BB%E5%BA%93.png" alt="主库"></p><p>② 对应 <code>master</code> 数据源，配置在 <code>application-&#123;env&#125;.yaml</code> 配置文件。如下图所示：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/master%E6%95%B0%E6%8D%AE%E6%BA%90.png" alt=" 数据源"></p><p>③ 每个主库对应的 Mapper，必须添加 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/blob/master/core/src/main/java/com/baomidou/dynamic/datasource/annotation/Master.java"><code>@Master</code> (opens new window)</a>注解。例如说：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/Master%E6%B3%A8%E8%A7%A3.png" alt=" 注解"></p><h3 id="3-2-租户库"><a href="#3-2-租户库" class="headerlink" title="#3.2 租户库"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_3-2-%E7%A7%9F%E6%88%B7%E5%BA%93">#</a>3.2 租户库</h3><p>① 存放每个租户的表。例如说：用户表、角色表等等。</p><p>② 在 [基础设施 -&gt; 数据源配置] 菜单中，配置数据源。</p><p>③ 每个主库对应的 Mapper，必须添加 <a href="https://doc.iocoder.cn/saas-tenant/dynamic/TODO"><code>@TenantDS</code></a> 注解。例如说：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/TenantDS%E6%B3%A8%E8%A7%A3.png" alt=" 注解"></p><h3 id="3-3-租户字段"><a href="#3-3-租户字段" class="headerlink" title="#3.3 租户字段"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_3-3-%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5">#</a>3.3 租户字段</h3><p>① 考虑到拓展性，在使用 DATASOURCE 模式时，默认会叠加 COLUMN 模式，即还有 <code>tenant_id</code> 租户字段：</p><ul><li>在 <code>INSERT</code> 操作时，会自动记录租户编号到 <code>tenant_id</code> 字段。</li><li>在 <code>SELECT</code> 操作时，会自动添加 <code>WHERE tenant_id = ?</code> 查询条件。</li></ul><p>如果你不需要，可以直接删除 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/db/TenantDatabaseInterceptor.java">TenantDatabaseInterceptor (opens new window)</a>类，以及它的 Bean 自动配置。</p><p>拓展性，指的是部分【大】租户独立数据库，部分【小】租户共享数据。</p><p>② 也因为叠加了 COLUMN 模式，<strong>主库</strong>的表需要根据情况添加 <code>tenant_id</code> 字段。</p><ul><li>情况一：不需要添加 <code>tenant_id</code> 字段。例如说：菜单表、定时任务表等等。注意，需要把表名添加到 <code>yudao.tenant.ignore-tables</code> 配置项中。</li><li>情况二：需要 <code>tenant_id</code> 字段。例如说：访问日志表、异常日志表等等。目的，排查是哪个租户的系统级别的日志。</li></ul><h2 id="4-多数据源事务"><a href="#4-多数据源事务" class="headerlink" title="#4. 多数据源事务"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_4-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E4%BA%8B%E5%8A%A1">#</a>4. 多数据源事务</h2><p>使用 DATASOURCE 模式后，可能一个操作涉及到多个数据源。例如说：创建租户时，即需要操作主库，也需要操作租户库。</p><p>考虑到多数据的数据一致性，我们会采用事务的方式，而使用 Spring 事务时，会存在多数据库无法切换的问题。不了解的胖友，可以阅读 <a href="https://zhuanlan.zhihu.com/p/410915221">《MyBatis Plus 的多数据源 <code>@DS</code> 切换不起作用了，谁的锅 》 (opens new window)</a>文章。</p><p>多数据源的事务方案，是一个老生常谈的问题。比较主流的，有如下两种，都是相对重量级的方案：</p><ol><li>使用 <a href="https://cloud.tencent.com/developer/article/1436662">Atomikos (opens new window)</a>实现 JTA 分布式事务，配置复杂，性能较差。</li><li>使用 <a href="https://www.iocoder.cn/Seata/install/">Seata (opens new window)</a>实现分布式事务，使用简单，性能不错，但是需要额外引入 Seata Server 服务。</li></ol><h3 id="4-1-本地事务"><a href="#4-1-本地事务" class="headerlink" title="#4.1 本地事务"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_4-1-%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1">#</a>4.1 本地事务</h3><p>考虑到项目是单体架构，不适合采用重量级的事务，因此采用 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter">dynamic-datasource (opens new window)</a>提供的 <strong>“本地事务”</strong> 轻量级方案。</p><p>它的实现原理是：自定义 <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/blob/master/core/src/main/java/com/baomidou/dynamic/datasource/annotation/DSTransactional.java"><code>@DSTransactional</code> (opens new window)</a>事务注解，替代 Spring <code>@Transactional</code> 事务注解。</p><ul><li>在逻辑执行成功时，循环提交每个数据源的事务。</li><li>在逻辑执行失败时，循环回滚每个数据源的事务。</li></ul><p>但是它存在一个风险点，如果数据库发生异常（例如说宕机），那么本地事务就可能会存在数据不一致的问题。例如说：</p><ul><li>① 主库的事务提交</li><li>② 租户库发生异常，租户的事务提交失败</li><li>结果：主库的数据已经提交，而租户库的数据没有提交，就会导致数据不一致。</li></ul><p><strong>因此，如果你的系统对数据一致性要求很高，那么请使用 Seata 方案。</strong></p><h3 id="4-2-使用示例"><a href="#4-2-使用示例" class="headerlink" title="#4.2 使用示例"></a><a href="https://doc.iocoder.cn/saas-tenant/dynamic/#_4-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B">#</a>4.2 使用示例</h3><p>在最外层的 Service 方法上，添加 <code>@DSTransactional</code> 注解。例如说，创建租户的 Service 方法：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E7%8B%AC%E7%AB%8B%E6%95%B0%E6%8D%AE%E6%BA%90/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B.png" alt="使用示例"></p><p>注意，里面不能嵌套有 Spring 自带的事务，就是上图中【黄圈】的 Service 方法不能使用 Spring <code>@Transactional</code> 注解，否则会导致数据源无法切换。</p><p>如果【黄圈】的 Service 自身还需要事务，那么可以使用 <code>@DSTransactional</code> 注解。</p>]]></content>
      
      
      <categories>
          
          <category> Saas多租户 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Saas多租户字段隔离</title>
      <link href="/2023/11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/"/>
      <url>/2023/11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="SaaS-多租户【字段隔离】"><a href="#SaaS-多租户【字段隔离】" class="headerlink" title="SaaS 多租户【字段隔离】"></a>SaaS 多租户【字段隔离】</h1><p>本章节，将介绍多租户的基础知识、以及怎样使用多租户的功能。</p><p>相关的视频教程：</p><ul><li><a href="https://t.zsxq.com/06ufyFAeM">01、如何实现多租户的 DB 封装？(opens new window)</a></li><li><a href="https://t.zsxq.com/067eQfAQN">02、如何实现多租户的 Redis 封装？(opens new window)</a></li><li><a href="https://t.zsxq.com/06Nnm6QBE">03、如何实现多租户的 Web 与 Security 封装？(opens new window)</a></li><li><a href="https://t.zsxq.com/06AYJUR3V">04、如何实现多租户的 Job 封装？(opens new window)</a></li><li><a href="https://t.zsxq.com/06aq3nuNF">05、如何实现多租户的 MQ 与 Async 封装？(opens new window)</a></li><li><a href="https://t.zsxq.com/06vFQVJIe">06、如何实现多租户的 AOP 与 Util 封装？(opens new window)</a></li><li><a href="https://t.zsxq.com/063bqRrNZ">07、如何实现多租户的管理？(opens new window)</a></li><li><a href="https://t.zsxq.com/06rBI66yV">08、如何实现多租户的套餐？(opens new window)</a></li></ul><h2 id="1-多租户是什么？"><a href="#1-多租户是什么？" class="headerlink" title="#1. 多租户是什么？"></a><a href="https://doc.iocoder.cn/saas-tenant/#_1-%E5%A4%9A%E7%A7%9F%E6%88%B7%E6%98%AF%E4%BB%80%E4%B9%88">#</a>1. 多租户是什么？</h2><p>多租户，简单来说是指<strong>一个</strong>业务系统，可以为<strong>多个</strong>组织服务，并且组织之间的数据是<strong>隔离</strong>的。</p><p>例如说，在服务上部署了一个 <a href="https://github.com/YunaiV/ruoyi-vue-pro"><code>ruoyi-vue-pro</code> (opens new window)</a>系统，可以支持多个不同的公司使用。这里的<strong>一个公司就是一个租户</strong>，每个用户必然属于某个租户。因此，用户也只能看见自己租户下面的内容，其它租户的内容对他是不可见的。</p><h2 id="2-数据隔离方案"><a href="#2-数据隔离方案" class="headerlink" title="#2. 数据隔离方案"></a><a href="https://doc.iocoder.cn/saas-tenant/#_2-%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB%E6%96%B9%E6%A1%88">#</a>2. 数据隔离方案</h2><p>多租户的数据隔离方案，可以分成分成三种：</p><ol><li>DATASOURCE 模式：独立数据库</li><li>SCHEMA 模式：共享数据库，独立 Schema</li><li>COLUMN 模式：共享数据库，共享 Schema，共享数据表</li></ol><h3 id="2-1-DATASOURCE-模式"><a href="#2-1-DATASOURCE-模式" class="headerlink" title="#2.1 DATASOURCE 模式"></a><a href="https://doc.iocoder.cn/saas-tenant/#_2-1-datasource-%E6%A8%A1%E5%BC%8F">#</a>2.1 DATASOURCE 模式</h3><p>一个租户一个数据库，这种方案的用户数据隔离级别最高，安全性最好，但成本也高。</p><img src="11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/DATASOURCE%E6%A8%A1%E5%BC%8F.png" class title="DATASOURCE 模式"><ul><li>优点：为不同的租户提供独立的数据库，有助于简化数据模型的扩展设计，满足不同租户的独特需求；如果出现故障，恢复数据比较简单。</li><li>缺点：增大了数据库的安装数量，随之带来维护成本和购置成本的增加。</li></ul><h3 id="2-2-SCHEMA-模式"><a href="#2-2-SCHEMA-模式" class="headerlink" title="#2.2 SCHEMA 模式"></a><a href="https://doc.iocoder.cn/saas-tenant/#_2-2-schema-%E6%A8%A1%E5%BC%8F">#</a>2.2 SCHEMA 模式</h3><p>多个或所有租户共享数据库，但一个租户一个表。</p><img src="11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/SCHEMA%E6%A8%A1%E5%BC%8F.png" class title="SCHEMA 模式"><ul><li>优点：为安全性要求较高的租户提供了一定程度的逻辑数据隔离，并不是完全隔离；每个数据库可以支持更多的租户数量。</li><li>缺点：如果出现故障，数据恢复比较困难，因为恢复数据库将牵扯到其他租户的数据； 如果需要跨租户统计数据，存在一定困难。</li></ul><h3 id="2-3-COLUMN-模式"><a href="#2-3-COLUMN-模式" class="headerlink" title="#2.3 COLUMN 模式"></a><a href="https://doc.iocoder.cn/saas-tenant/#_2-3-column-%E6%A8%A1%E5%BC%8F">#</a>2.3 COLUMN 模式</h3><p>共享数据库，共享数据架构。租户共享同一个数据库、同一个表，但在表中通过 <code>tenant_id</code> 字段区分租户的数据。这是共享程度最高、隔离级别最低的模式。</p><img src="11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/COLUMN%E6%A8%A1%E5%BC%8F.png" class title="COLUMN 模式"><ul><li>优点：维护和购置成本最低，允许每个数据库支持的租户数量最多。</li><li>缺点：隔离级别最低，安全性最低，需要在设计开发时加大对安全的开发量；数据备份和恢复最困难，需要逐表逐条备份和还原。</li></ul><h3 id="2-4-方案选择"><a href="#2-4-方案选择" class="headerlink" title="#2.4 方案选择"></a><a href="https://doc.iocoder.cn/saas-tenant/#_2-4-%E6%96%B9%E6%A1%88%E9%80%89%E6%8B%A9">#</a>2.4 方案选择</h3><img src="11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/%E6%A8%A1%E5%BC%8F%E9%80%89%E6%8B%A9.png" class title="模式选择"><ul><li>一般情况下，可以考虑采用 COLUMN 模式，开发、运维简单，以最少的服务器为最多的租户提供服务。</li><li>租户规模比较大，或者一些租户对安全性要求较高，可以考虑采用 DATASOURCE 模式，当然它也相对复杂的多。</li><li>不推荐采用 SCHEMA 模式，因为它的优点并不明显，而且它的缺点也很明显，同时对复杂 SQL 支持一般。</li></ul><p>提问：项目支持哪些模式？</p><p>目前支持最主流的 DATASOURCE 和 COLUMN 两种模式。而 SCHEMA 模式不推荐使用，所以暂时不考虑实现。</p><p>考虑到让大家更好的理解 DATASOURCE 和 COLUMN 模式，拆成了两篇文章：</p><ul><li><a href="https://doc.iocoder.cn/saas-tenant">《SaaS 多租户【字段隔离】》</a>：讲解 COLUMN 模式</li><li><a href="https://doc.iocoder.cn/saas-tenant/dynamic">《SaaS 多租户【数据库隔离】》</a>：讲解 DATASOURCE 模式</li></ul><h2 id="3-多租户的开关"><a href="#3-多租户的开关" class="headerlink" title="#3. 多租户的开关"></a><a href="https://doc.iocoder.cn/saas-tenant/#_3-%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%9A%84%E5%BC%80%E5%85%B3">#</a>3. 多租户的开关</h2><p>系统有两个配置项，设置为 <code>true</code> 时开启多租户，设置为 <code>false</code> 时关闭多租户。</p><p>注意，两者需要保持一致，否则会报错！</p><table><thead><tr><th>配置项</th><th>说明</th><th>配置文件</th></tr></thead><tbody><tr><td><code>yudao.server.tenant</code></td><td>后端开关</td><td><img src="11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/01.png" class title="示例"></td></tr><tr><td><code>VUE_APP_TENANT_ENABLE</code></td><td>前端开关</td><td><img src="11/27/Saas%E7%A7%9F%E6%88%B7/SaaS%E5%A4%9A%E7%A7%9F%E6%88%B7%E5%AD%97%E6%AE%B5%E9%9A%94%E7%A6%BB/02.png" class title="示例"></td></tr></tbody></table><p>疑问：为什么要设置两个配置项？</p><p>前端登录界面需要使用到多租户的配置项，从后端加载配置项的话，体验会比较差。</p><h2 id="4-多租户的业务功能"><a href="#4-多租户的业务功能" class="headerlink" title="#4. 多租户的业务功能"></a><a href="https://doc.iocoder.cn/saas-tenant/#_4-%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD">#</a>4. 多租户的业务功能</h2><p>多租户主要有两个业务功能：</p><table><thead><tr><th>业务功能</th><th>说明</th><th>界面</th><th>代码</th></tr></thead><tbody><tr><td>租户管理</td><td>配置系统租户，创建对应的租户管理员</td><td><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/03.png" alt="租户管理"></td><td><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/tenant/TenantServiceImpl.java">后端 (opens new window)</a><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-ui-admin/src/views/system/tenant/index.vue">前端(opens new window)</a></td></tr><tr><td>租户套餐</td><td>配置租户套餐，自定每个租户的菜单、操作、按钮的权限</td><td><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/04.png" alt="租户套餐"></td><td><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/tenant/TenantPackageServiceImpl.java">后端 (opens new window)</a><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-ui-admin/src/views/system/tenantPackage/index.vue">前端(opens new window)</a></td></tr></tbody></table><p><strong>下面，我们来新增一个租户，它使用 COLUMN 模式。</strong></p><p>① 点击 [租户套餐] 菜单，点击 [新增] 按钮，填写租户的信息。</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/05.png" alt="新增租户"></p><p>② 点击 [确认] 按钮，完成租户的创建，它会自动创建对应的租户管理员、角色等信息。</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/06.png" alt="租户的管理员、角色"></p><p>③ 退出系统，登录刚创建的租户。</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/07.png" alt="登录界面"></p><p>至此，我们已经完成了租户的创建。</p><h2 id="5-多租户的技术组件"><a href="#5-多租户的技术组件" class="headerlink" title="#5. 多租户的技术组件"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-%E5%A4%9A%E7%A7%9F%E6%88%B7%E7%9A%84%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6">#</a>5. 多租户的技术组件</h2><p>技术组件 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/"><code>yudao-spring-boot-starter-biz-tenant</code> (opens new window)</a>，实现透明化的多租户能力，针对 Web、Security、DB、Redis、AOP、Job、MQ、Async 等多个层面进行封装。</p><h3 id="5-1-租户上下文"><a href="#5-1-租户上下文" class="headerlink" title="#5.1 租户上下文"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-1-%E7%A7%9F%E6%88%B7%E4%B8%8A%E4%B8%8B%E6%96%87">#</a>5.1 租户上下文</h3><p><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/context/TenantContextHolder.java">TenantContextHolder (opens new window)</a>是租户上下文，通过 ThreadLocal 实现租户编号的共享与传递。</p><p>通过调用 TenantContextHolder 的 <code>#getTenantId()</code> <strong>静态</strong>方法，获得当前的租户编号。绝绝绝大多数情况下，并不需要。</p><h3 id="5-2-Web-层【重要】"><a href="#5-2-Web-层【重要】" class="headerlink" title="#5.2 Web 层【重要】"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-2-web-%E5%B1%82%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a>5.2 Web 层【重要】</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/web"><code>web</code> (opens new window)</a>包。</p></blockquote><p>默认情况下，前端的每个请求 Header <strong>必须</strong>带上 <code>tenant-id</code>，值为租户编号，即 <code>system_tenant</code> 表的主键编号。</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/08.png" alt="请求示例"></p><p>如果不带该请求头，会报“租户的请求未传递，请进行排查”错误提示。</p><p>😜 通过 <code>yudao.tenant.ignore-urls</code> 配置项，可以设置哪些 URL 无需带该请求头。例如说：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/09.png" alt=" 配置项"></p><h3 id="5-3-Security-层"><a href="#5-3-Security-层" class="headerlink" title="#5.3 Security 层"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-3-security-%E5%B1%82">#</a>5.3 Security 层</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/security"><code>security</code> (opens new window)</a>包。</p></blockquote><p>主要是校验登录的用户，校验是否有权限访问该租户，避免越权问题。</p><h3 id="5-4-DB-层【重要】"><a href="#5-4-DB-层【重要】" class="headerlink" title="#5.4 DB 层【重要】"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-4-db-%E5%B1%82%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a>5.4 DB 层【重要】</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/db"><code>db</code> (opens new window)</a>包。</p></blockquote><p>COLUMN 模式，基于 MyBatis Plus 自带的<a href="https://baomidou.com/pages/aef2f2/">多租户 (opens new window)</a>功能实现。</p><p>核心：每次对数据库操作时，它会<strong>自动</strong>拼接 <code>WHERE tenant_id = ?</code> 条件来进行租户的过滤，并且基本支持所有的 SQL 场景。</p><p>如下是具体方式：</p><p>① <strong>需要</strong>开启多租户的表，必须添加 <code>tenant_id</code> 字段。例如说 <code>system_users</code>、<code>system_role</code> 等表。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `system_role` (</span><br><span class="line">   `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;角色ID&#x27;</span>,</span><br><span class="line">   `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="type">CHARACTER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;角色名称&#x27;</span>,</span><br><span class="line">   `tenant_id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;租户编号&#x27;</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> COMMENT<span class="operator">=</span><span class="string">&#x27;角色信息表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>并且该表对应的 DO 需要使用到 <code>tenantId</code> 属性时，建议继承 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/db/TenantBaseDO.java">TenantBaseDO (opens new window)</a>类。</p><p>② <strong>无需</strong>开启多租户的表，需要添加表名到 <code>yudao.tenant.ignore-tables</code> 配置项目。例如说：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/10.png" alt=" 配置项"></p><p>如果不配置的话，MyBatis Plus 会自动拼接 <code>WHERE tenant_id = ?</code> 条件，导致报 <code>tenant_id</code> 字段不存在的错误。</p><h3 id="5-5-Redis-层【重要】"><a href="#5-5-Redis-层【重要】" class="headerlink" title="#5.5 Redis 层【重要】"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-5-redis-%E5%B1%82%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a>5.5 Redis 层【重要】</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/redis"><code>redis</code> (opens new window)</a>包。</p></blockquote><p>由于 Redis 不同于 DB 有 <code>tenant_id</code> 字段，无法通过类似 <code>WHERE tenant_id</code> &#x3D; ? 的方式过滤，所以需要通过在 Redis Key 上增加 <code>:t&#123;tenantId&#125;</code> 后缀的方式，进行租户之间的隔离。</p><p>例如说，假设 Redis Key 是 <code>user:%d</code>，示例是 <code>user:1024</code>；对应到多租户 1 的 Redis Key 是 <code>user:t1:1024</code>。</p><p>为什么 Redis Key 要多租户隔离呢？</p><ul><li>① 在使用 DATASOURCE 模式时，不同库的相同表的 id 可能相同，例如说 A 库的用户，和 B 库的用户都是 1024，直接缓存会存在 Redis Key 的冲突。</li><li>② 在所有模式下，跨租户可能存在相同的需要唯一的数据，例如说用户的手机号，直接缓存会存在 Redis Key 的冲突。</li></ul><h4 id="使用方式一：基于-Spring-Cache-Redis【推荐】"><a href="#使用方式一：基于-Spring-Cache-Redis【推荐】" class="headerlink" title="#使用方式一：基于 Spring Cache + Redis【推荐】"></a><a href="https://doc.iocoder.cn/saas-tenant/#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E4%B8%80-%E5%9F%BA%E4%BA%8E-spring-cache-redis%E3%80%90%E6%8E%A8%E8%8D%90%E3%80%91">#</a>使用方式一：基于 Spring Cache + Redis【推荐】</h4><p>只需要一步，在方法上添加 Spring Cache 注解，例如说 <code>@Cachable</code>、<code>@CachePut</code>、<code>@CacheEvict</code>。</p><p>具体的实现原理，可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/redis/TenantRedisCacheManager.java">TenantRedisCacheManager (opens new window)</a>的源码。</p><p>注意！！！默认配置下，Spring Cache 都开启 Redis Key 的多租户隔离。如果不需要，可以将 Key 添加到 <code>yudao.tenant.ignore-cache</code> 配置项中。如下图所示：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/%E5%BF%BD%E7%95%A5%E5%A4%9A%E7%A7%9F%E6%88%B7RedisKey.png" alt=" 配置项"></p><h4 id="使用方式二：基于-RedisTemplate-TenantRedisKeyDefine"><a href="#使用方式二：基于-RedisTemplate-TenantRedisKeyDefine" class="headerlink" title="#使用方式二：基于 RedisTemplate + TenantRedisKeyDefine"></a><a href="https://doc.iocoder.cn/saas-tenant/#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E4%BA%8C-%E5%9F%BA%E4%BA%8E-redistemplate-tenantrediskeydefine">#</a>使用方式二：基于 RedisTemplate + TenantRedisKeyDefine</h4><p>暂时没有合适的封装，需要在自己 format Redis Key 的时候，手动将 <code>:t&#123;tenantId&#125;</code> 后缀拼接上。</p><p>这也是为什么，我推荐你使用 Spring Cache + Redis 的原因！</p><h3 id="5-6-AOP【重要】"><a href="#5-6-AOP【重要】" class="headerlink" title="#5.6 AOP【重要】"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-6-aop%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a>5.6 AOP【重要】</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/aop"><code>aop</code> (opens new window)</a>包。</p></blockquote><p>① 声明 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/aop/TenantIgnore.java"><code>@TenantIgnore</code> (opens new window)</a>注解在方法上，标记指定方法不进行租户的自动过滤，避免<strong>自动</strong>拼接 <code>WHERE tenant_id = ?</code> 条件等等。</p><p>例如说：<a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleServiceImpl.java">RoleServiceImpl (opens new window)</a>的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/permission/RoleServiceImpl.java#L83-L100"><code>#initLocalCache()</code> (opens new window)</a>方法，加载<strong>所有</strong>租户的角色到内存进行缓存，如果不声明 <code>@TenantIgnore</code> 注解，会导致租户的自动过滤，只加载了某个租户的角色。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RoleServiceImpl.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">RoleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="meta">@Lazy</span> <span class="comment">// 注入自己，所以延迟加载</span></span><br><span class="line">    <span class="keyword">private</span> RoleService self;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="meta">@TenantIgnore</span> <span class="comment">// 忽略自动多租户，全局初始化缓存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initLocalCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... 从数据库中，加载角色</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedDelay = SCHEDULER_PERIOD, initialDelay = SCHEDULER_PERIOD)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">schedulePeriodicRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">        self.initLocalCache(); <span class="comment">// &lt;x&gt; 通过 self 引用到 Spring 代理对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一点要格外注意，由于 <code>@TenantIgnore</code> 注解是基于 Spring AOP 实现，如果是<strong>方法内部的调用</strong>，避免使用 <code>this</code> 导致不生效，可以采用上述示例的 <code>&lt;x&gt;</code> 处的 <code>self</code> 方式。</p><p>② 使用 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/util/TenantUtils.java">TenantUtils (opens new window)</a>的 <code>#execute(Long tenantId, Runnable runnable)</code> 方法，模拟指定租户( <code>tenantId</code> )，执行某段业务逻辑( <code>runnable</code> )。</p><p>例如说：在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-system/yudao-module-system-biz/src/main/java/cn/iocoder/yudao/module/system/service/tenant/TenantServiceImpl.java">TenantServiceImpl (opens new window)</a>的 <code>#createTenant(...)</code> 方法，在创建完租户时，需要模拟该租户，进行用户和角色的创建。如下图所示：</p><p><img src="https://doc.iocoder.cn/img/Saas%E5%A4%9A%E7%A7%9F%E6%88%B7/11.png" alt="TenantUtils 模拟租户"></p><h3 id="5-7-Job【重要】"><a href="#5-7-Job【重要】" class="headerlink" title="#5.7 Job【重要】"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-7-job%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91">#</a>5.7 Job【重要】</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/job"><code>job</code> (opens new window)</a>包。</p></blockquote><p>声明 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/job/TenantJob.java"><code>@TenantJob</code> (opens new window)</a>注解在 Job 类上，实现<strong>并行</strong>遍历每个租户，执行定时任务的逻辑。</p><h3 id="5-8-MQ"><a href="#5-8-MQ" class="headerlink" title="#5.8 MQ"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-8-mq">#</a>5.8 MQ</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/tree/master/yudao-framework/yudao-spring-boot-starter-biz-tenant/src/main/java/cn/iocoder/yudao/framework/tenant/core/mq"><code>mq</code> (opens new window)</a>包。</p></blockquote><p>通过租户对 MQ 层面的封装，实现租户上下文，可以继续传递到 MQ 消费的逻辑中，避免丢失的问题。实现原理是：</p><ul><li>发送消息时，MQ 会将租户上下文的租户编号，记录到 Message 消息头 <code>tenant-id</code> 上。</li><li>消费消息时，MQ 会将 Message 消息头 <code>tenant-id</code>，设置到租户上下文的租户编号。</li></ul><h3 id="5-9-Async"><a href="#5-9-Async" class="headerlink" title="#5.9 Async"></a><a href="https://doc.iocoder.cn/saas-tenant/#_5-9-async">#</a>5.9 Async</h3><blockquote><p>实现可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-framework/yudao-spring-boot-starter-job/src/main/java/cn/iocoder/yudao/framework/quartz/config/YudaoAsyncAutoConfiguration.java"><code>YudaoAsyncAutoConfiguration</code> (opens new window)</a>类。</p></blockquote><p>通过使用阿里开源的 <a href="https://github.com/alibaba/transmittable-thread-local">TransmittableThreadLocal (opens new window)</a>组件，实现 Spring Async 执行异步逻辑时，租户上下文可以继续传递，避免丢失的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Saas多租户 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础</title>
      <link href="/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>​常见的有：数组、队列、链表和栈</p><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><p>​当一个数组中大部分元素为0，或者同一个值的数组时，可以使用稀疏数组保存该数据</p><p>稀疏数组的处理方法是：</p><p>​1）记录数组一共有几行几列，有多少个不同的值</p><p>​2）把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小数组的规模</p><img src="image-20221103202221408.png" alt="image-20221103202221408" style="zoom: 67%;"><p>​二维数组转稀疏数组的思路</p><p>1.遍历原始二维数组，读取有效数据个数sum</p><p>2.根据sum的值创建稀疏数组 int [sum +1] [3]</p><p>3.将二维数组的有效数据依次填到稀疏数组</p><p>​稀疏数组转二维数组的思路</p><p>1.读取稀疏数组第一行数据，得到原二维数组的行和列，还原二维数组，比如上面的chessArr2 &#x3D; int[6] [7]</p><p>2.再读取稀疏数组后几行的数据，依次还原到对应的二维数组的位置</p><p>代码实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个原始的二维数组 11*11</span></span><br><span class="line">        <span class="comment">//0：表示没有棋子 1：表示黑子 2：表示蓝子</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr1[<span class="number">3</span>][<span class="number">4</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//输出原始二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二维数组转换为稀疏数组思路</span></span><br><span class="line">        <span class="comment">//1.先遍历二维数组，得到非0数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;非0的个数：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建对应的稀疏数组int[sum+1][3]</span></span><br><span class="line">        <span class="type">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="title class_">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历二维数组，将非0的值存放到sparseArr中</span></span><br><span class="line">        <span class="comment">//count变量，count用来计二维数组中非0值的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的稀疏数组为:&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//稀疏数组恢复成原始数组</span></span><br><span class="line">        <span class="comment">//1.读取稀疏数组第一行，创建原始二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] chessArr2 = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//2.再读取稀疏数组后几行数据，填到原始二维数组对应位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>,data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h2><pre><code> 常见的有：二维数组、多维数组、广义表、数结构、图结构</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>会签或签</title>
      <link href="/2023/11/27/activiti/%E4%BC%9A%E7%AD%BE%E6%88%96%E7%AD%BE/"/>
      <url>/2023/11/27/activiti/%E4%BC%9A%E7%AD%BE%E6%88%96%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="工作流（Flowable）会签、或签"><a href="#工作流（Flowable）会签、或签" class="headerlink" title="工作流（Flowable）会签、或签"></a>工作流（Flowable）会签、或签</h1><p>项目基于 Flowable 实现了工作流的功能。本章节，我们将介绍工作流的相关功能。</p><p>以请假流程为例，讲解系统支持的两种表单方式的工作流：</p><ol><li>流程表单：在线配置动态表单，无需建表与开发</li><li>业务表单：业务需建立独立的数据库表，并开发对应的表单、详情界面</li></ol><p>整个过程包括：</p><ol><li>定义流程：【管理员】新建流程、设计流程模型、并设置用户任务的审批人，最终发布流程</li><li>发起流程：【员工】选择流程，并发起流程实例</li><li>审批流程：【审批人】接收到流程任务，审批结果为通过或不通过</li></ol><img src="54.png" alt="示例流程" style="zoom:67%;"><ul><li><a href="https://t.zsxq.com/04aqfIiY3">01、如何集成 Flowable 框架？(opens new window)</a></li><li><a href="https://t.zsxq.com/04nun2RRz">02、如何实现动态的流程表单？(opens new window)</a></li><li><a href="https://t.zsxq.com/04uneeaUb">03、如何实现流程表单的保存？(opens new window)</a></li><li><a href="https://t.zsxq.com/04jiMrjAm">04、如何实现流程表单的展示？(opens new window)</a></li><li><a href="https://t.zsxq.com/04iynUF6e">05、如何实现流程模型的新建？(opens new window)</a></li><li><a href="https://t.zsxq.com/04rNVbEQB">06、如何实现流程模型的流程图的设计？(opens new window)</a></li><li><a href="https://t.zsxq.com/042neybYz">07、如何实现流程模型的流程图的预览？(opens new window)</a></li><li><a href="https://t.zsxq.com/04uburRvZ">08、如何实现流程模型的分配规则？(opens new window)</a></li><li><a href="https://t.zsxq.com/04jUBMjyF">09、如何实现流程模型的发布？(opens new window)</a></li><li><a href="https://t.zsxq.com/04MF6URvz">10、如何实现流程定义的查询？(opens new window)</a></li><li><a href="https://t.zsxq.com/04jyvNfqj">11、如何实现流程的发起？(opens new window)</a></li><li><a href="https://t.zsxq.com/046UFqRzz">12、如何实现我的流程列表？(opens new window)</a></li><li><a href="https://t.zsxq.com/04aM72rzv">13、如何实现流程的取消？(opens new window)</a></li><li><a href="https://t.zsxq.com/04rNvFI2f">14、如何实现流程的任务分配？(opens new window)</a></li><li><a href="https://t.zsxq.com/04yFUVZvF">15、如何实现会签、或签任务？(opens new window)</a></li><li><a href="https://t.zsxq.com/04QZzjAme">16、如何实现我的待办任务列表？(opens new window)</a></li><li><a href="https://t.zsxq.com/04uj6AQJE">17、如何实现我的已办任务列表？(opens new window)</a></li><li><a href="https://t.zsxq.com/04Q7UbqBM">18、如何实现任务的审批通过？(opens new window)</a></li><li><a href="https://t.zsxq.com/04BQvJM7y">19、如何实现任务的审批不通过？(opens new window)</a></li><li><a href="https://t.zsxq.com/04Ie2v7m2">20、如何实现流程的审批记录？(opens new window)</a></li><li><a href="https://t.zsxq.com/04R72rzzN">21、如何实现流程的流程图的高亮？(opens new window)</a></li><li><a href="https://t.zsxq.com/04eyRRJ2f">22、如何实现工作流的短信通知？(opens new window)</a></li><li><a href="https://t.zsxq.com/04rFUjIei">23、如何实现 OA 请假的发起？(opens new window)</a></li><li><a href="https://t.zsxq.com/04fMJiufQ">24、如何实现 OA 请假的审批？(opens new window)</a></li></ul><h2 id="0-如何开启-bpm-模块？"><a href="#0-如何开启-bpm-模块？" class="headerlink" title="#0. 如何开启 bpm 模块？"></a><a href="https://doc.iocoder.cn/bpm/#_0-%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF-bpm-%E6%A8%A1%E5%9D%97">#</a>0. 如何开启 bpm 模块？</h2><p><code>yudao-module-bpm</code> 模块默认未启用，需要手动开启。步骤如下：</p><p>① 第一步，修改根目录的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/pom.xml"><code>pom.xml</code> (opens new window)</a>文件，取消 <code>yudao-module-bpm</code> 模块的注释。</p><img src="-1.png" alt="引入  模块" style="zoom:67%;"><p>② 第二步，修改 <code>yudao-server</code> 的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-server/pom.xml"><code>pom.xml</code> (opens new window)</a>文件，取消 <code>yudao-module-bpm-biz</code> 依赖的注释，并进行 IDEA 的 Maven 刷新。</p><img src="0.png" alt="引入  依赖" style="zoom:67%;"><p>③ 第三步，点击 <a href="https://doc.iocoder.cn/file/bpm.sql"><code>bpm.sql</code></a> 下载，然后导入到数据库中。</p><p>友情提示：↑↑↑ bpm.sql 是可以点击下载的！ ↑↑↑</p><img src="SQL导入.png" alt="导入 " style="zoom:67%;"><p>④ 第四步，重启项目，看到 <code>Property Source flowable-liquibase-override refreshed</code> 说明开启成功。</p><p>另外，启动过程中，Flowable 会自动创建 <code>ACT_</code> 和 <code>FLW_</code> 开头的表。</p><p>如果启动中报 <a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro/issues/I57FYM">MySQL “Specified key was too long; max key length is 1000 bytes” (opens new window)</a>错误，可以将 MySQL 的缺省存储引擎设置为 innodb，即 <code>default-storage-engine=innodb</code> 配置项。</p><h2 id="1-请假流程【流程表单】"><a href="#1-请假流程【流程表单】" class="headerlink" title="#1. 请假流程【流程表单】"></a><a href="https://doc.iocoder.cn/bpm/#_1-%E8%AF%B7%E5%81%87%E6%B5%81%E7%A8%8B%E3%80%90%E6%B5%81%E7%A8%8B%E8%A1%A8%E5%8D%95%E3%80%91">#</a>1. 请假流程【流程表单】</h2><h3 id="1-1-第一步：定义流程"><a href="#1-1-第一步：定义流程" class="headerlink" title="#1.1 第一步：定义流程"></a><a href="https://doc.iocoder.cn/bpm/#_1-1-%E7%AC%AC%E4%B8%80%E6%AD%A5-%E5%AE%9A%E4%B9%89%E6%B5%81%E7%A8%8B">#</a>1.1 第一步：定义流程</h3><p>登录账号 admin、密码 admin123 的用户，扮演【管理员】的角色，进行流程的定义。</p><p>① 访问 [工作流程 -&gt; 流程管理 -&gt; 流程模型] 菜单，点击 [新建流程] 按钮，填写流程标识、流程名称。如下图所示：</p><img src="1.png" alt="新建流程" style="zoom:67%;"><ul><li>流程标识：对应 BPMN 流程文件 XML 的 <code>id</code> 属性，不能重复，新建后不可修改。</li><li>流程名称：对应 BPMN 流程文件 XML 的 <code>name</code> 属性。</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是一个 BPMN XML 的示例，主要看 id 和 name 属性 --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bpmn2:definitions</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:bpmn2</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="attr">xmlns:bpmndi</span>=<span class="string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="attr">id</span>=<span class="string">&quot;diagram_Process_1647305370393&quot;</span> <span class="attr">targetNamespace</span>=<span class="string">&quot;http://activiti.org/bpmn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmn2:process</span> <span class="attr">id</span>=<span class="string">&quot;common-form&quot;</span> <span class="attr">name</span>=<span class="string">&quot;通用表单流程&quot;</span> <span class="attr">isExecutable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bpmndi:BPMNDiagram</span> <span class="attr">id</span>=<span class="string">&quot;BPMNDiagram_1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bpmndi:BPMNPlane</span> <span class="attr">id</span>=<span class="string">&quot;common-form_di&quot;</span> <span class="attr">bpmnElement</span>=<span class="string">&quot;common-form&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bpmndi:BPMNDiagram</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bpmn2:definitions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>② 访问 [工作流程 -&gt; 流程管理 -&gt; 流程表单] 菜单，点击 [新增] 按钮，新增一个名字为 leave-form 的表单。如下图所示：</p><img src="3.png" alt="流程表单新增" style="zoom:67%;"><p>流程表单的实现？</p><p>基于 <a href="https://github.com/JakHuang/form-generator">https://github.com/JakHuang/form-generator (opens new window)</a>项目实现的动态表单。</p><p>回到 [工作流程 -&gt; 流程管理 -&gt; 流程模型] 菜单，点击 [修改流程] 按钮，配置表单类型为流程表单，选择名字为 leave-form 的流程表单。如下图所示：</p><img src="4.png" alt="修改流程" style="zoom:67%;"><p>③ 点击 [设计流程] 按钮，在线设计请假流程模型，包含两个用户任务：领导审批、HR 审批。如下图所示：</p><img src="5.png" alt="设计流程" style="zoom:67%;"><p>设计流程的实现？</p><p>基于 <a href="https://github.com/miyuesc/bpmn-process-designer">https://github.com/miyuesc/bpmn-process-designer (opens new window)</a>项目实现，它的底层是 <a href="https://github.com/bpmn-io">bpmn-js (opens new window)</a>。</p><p>④ 点击 [分配规则] 按钮，设置用户任务的审批人。其中，规则类型用于分配用户任务的审批人，目前有 7 种规则：角色、部门成员、部门负责人、岗位、用户、用户组、自定义脚本，基本可以满足绝大多数场景，是不是非常良心。</p><ul><li><p>设置【领导审批】的规则类型为自定义脚本 + 流程发起人的一级领导，如下图所示： </p><img src="6-a.png" alt="分配规则 - 领导审批" style="zoom:67%;"></li><li><p>设置【HR 审批】的规则类型为岗位 + 人力资源，如下图所示： </p><img src="6-b.png" alt="分配规则 - HR 审批" style="zoom:67%;"></li></ul><p>规则类型的实现？</p><p>可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-biz/src/main/java/cn/iocoder/yudao/module/bpm/framework/flowable/core/behavior/BpmUserTaskActivityBehavior.java">BpmUserTaskActivityBehavior (opens new window)</a>代码，目前暂时支持分配一个审批人。</p><p>⑤ 点击 [发布流程] 按钮，把定义的流程模型部署出去。部署成功后，就可以发起该流程了。如下图所示：</p><img src="7.png" alt="发布路程" style="zoom:67%;"><p>修改流程后，需要重新发布流程吗？</p><p>需要，<strong>必须重新发布</strong>才能生效。每次流程发布后，会生成一个新的流程定义，版本号从 v1 开始递增。</p><p>发布成功后，会部署新版本的流程定义，旧版本的流程定义将被挂起。当然，已经发起的流程不会受到影响，还是走老的流程定义。</p><h3 id="1-2-第二步：发起流程"><a href="#1-2-第二步：发起流程" class="headerlink" title="#1.2 第二步：发起流程"></a><a href="https://doc.iocoder.cn/bpm/#_1-2-%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E5%8F%91%E8%B5%B7%E6%B5%81%E7%A8%8B">#</a>1.2 第二步：发起流程</h3><p>登录账号 admin、密码 admin123 的用户，扮演【员工】的角色，进行流程的发起。</p><p>① 访问 [工作流程 -&gt; 任务管理 -&gt; 我的流程] 菜单，点击 [发起流程] 按钮，可以看到可以选择的流程定义的列表。</p><img src="33.png" alt="流程定义的列表" style="zoom:67%;"><p>② 选择名字为通用表单的流程定义，发起请假流程。填写请假表单信息如下：</p><img src="10.png" alt="发起流程" style="zoom:67%;"><p>③ 点击提交成功后，可在我的流程中，可看到该流程的状态、结果。</p><img src="11.png" alt="我的流程" style="zoom:67%;"><p>④ 点击 [详情] 按钮，可以查看申请的表单信息、审批记录、流程跟踪图。</p><img src="12.png" alt="详情" style="zoom:67%;"><h3 id="1-2-第三步：审批流程（领导审批）"><a href="#1-2-第三步：审批流程（领导审批）" class="headerlink" title="#1.2 第三步：审批流程（领导审批）"></a><a href="https://doc.iocoder.cn/bpm/#_1-2-%E7%AC%AC%E4%B8%89%E6%AD%A5-%E5%AE%A1%E6%89%B9%E6%B5%81%E7%A8%8B-%E9%A2%86%E5%AF%BC%E5%AE%A1%E6%89%B9">#</a>1.2 第三步：审批流程（领导审批）</h3><p>登录账号 test、密码 test123 的用户，扮演【审批人】的角色，进行请假流程的【领导审批】任务。</p><p>① 访问 [工作流程 -&gt; 任务管理 -&gt; 待办任务] 菜单，可以查询到需要审批的任务。</p><img src="13.png" alt="待办任务" style="zoom:67%;"><p>② 点击 [审批] 按钮，填写审批建议，并点击 [通过] 按钮，这样任务的审批就完成了。</p><img src="14.png" alt="部门领导审批" style="zoom:67%;"><p>③ 访问 [工作流程 -&gt; 任务管理 -&gt; 已办任务] 菜单，可以查询到已经审批的任务。</p><img src="34.png" alt="已办任务" style="zoom:67%;"><hr><p>此时，使用【员工】的角色，访问 [工作流程 -&gt; 任务管理 -&gt; 我的流程] 菜单，可以看到流程流转到了【HR 审批】任务。</p><img src="15.png" alt="部门领导审批后我的流程" style="zoom:67%;"><h3 id="1-3-第三步：审批流程（HR-审批）"><a href="#1-3-第三步：审批流程（HR-审批）" class="headerlink" title="#1.3 第三步：审批流程（HR 审批）"></a><a href="https://doc.iocoder.cn/bpm/#_1-3-%E7%AC%AC%E4%B8%89%E6%AD%A5-%E5%AE%A1%E6%89%B9%E6%B5%81%E7%A8%8B-hr-%E5%AE%A1%E6%89%B9">#</a>1.3 第三步：审批流程（HR 审批）</h3><p>登录账号 hrmgr、密码 hr123 的用户，扮演【审批人】的角色，进行请假流程的【HR 审批】任务。</p><p>① 访问 [工作流程 -&gt; 任务管理 -&gt; 待办任务] 菜单，点击 [审批] 按钮，填写审批建议，并点击 [通过] 按钮。</p><hr><p>此时，使用【员工】的角色，访问 [工作流程 -&gt; 任务管理 -&gt; 我的流程] 菜单，可以看到流程处理结束，最终审批通过。</p><img src="18.png" alt="请假流程最终状态" style="zoom:67%;"><h2 id="2-请假流程【业务表单】"><a href="#2-请假流程【业务表单】" class="headerlink" title="#2. 请假流程【业务表单】"></a><a href="https://doc.iocoder.cn/bpm/#_2-%E8%AF%B7%E5%81%87%E6%B5%81%E7%A8%8B%E3%80%90%E4%B8%9A%E5%8A%A1%E8%A1%A8%E5%8D%95%E3%80%91">#</a>2. 请假流程【业务表单】</h2><p>根据业务需要，业务通过建立独立的数据库表（业务表）记录申请信息，而流程引擎只负责推动流程的前进或者结束。两者需要进行<strong>双向</strong>的关联：</p><ul><li>每一条业务表记录，通过它的流程实例的编号( <code>process_instance_id</code> )指向对应的流程实例</li><li>每一个流程实例，通过它的业务键( <code>BUSINESS_KEY_</code> ) 指向对应的业务表记录。</li></ul><p>以项目中提供的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-biz/src/main/java/cn/iocoder/yudao/module/bpm/service/oa/BpmOALeaveServiceImpl.java">OALeave (opens new window)</a>请假举例子，它的业务表 <code>bpm_oa_leave</code> 和流程引擎的流程实例的关系如下图：</p><img src="19.png" alt="请假单数据库表" style="zoom:67%;"><p>也因为业务建立了独立的业务表，所以必须开发业务表对应的列表、表单、详情页面。不过，审核相关的功能是无需重新开发的，原因是业务表已经关联对应的流程实例，流程引擎审批流程实例即可。</p><p>下面，我们以项目中的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-biz/src/main/java/cn/iocoder/yudao/module/bpm/service/oa/BpmOALeaveServiceImpl.java">OALeave (opens new window)</a>为例子，详细讲解下业务表单的开发与使用的过程。</p><h3 id="2-0-第零步：业务开发"><a href="#2-0-第零步：业务开发" class="headerlink" title="#2.0 第零步：业务开发"></a><a href="https://doc.iocoder.cn/bpm/#_2-0-%E7%AC%AC%E9%9B%B6%E6%AD%A5-%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91">#</a>2.0 第零步：业务开发</h3><p>① 新建业务表 <code>bpm_oa_leave</code>，建表语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `bpm_oa_leave` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;请假表单主键&#x27;</span>,</span><br><span class="line">  `user_id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;申请人的用户编号&#x27;</span>,</span><br><span class="line">  `type` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请假类型&#x27;</span>,</span><br><span class="line">  `reason` <span class="type">varchar</span>(<span class="number">200</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请假原因&#x27;</span>,</span><br><span class="line">  `start_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;开始时间&#x27;</span>,</span><br><span class="line">  `end_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;结束时间&#x27;</span>,</span><br><span class="line">  `<span class="keyword">day</span>` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请假天数&#x27;</span>,</span><br><span class="line">  `<span class="keyword">result</span>` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请假结果&#x27;</span>,</span><br><span class="line">  `process_instance_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;流程实例的编号&#x27;</span>,</span><br><span class="line">  `creator` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;创建者&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `updater` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;更新者&#x27;</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  `deleted` bit(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> b<span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;是否删除&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;租户编号&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">26</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci COMMENT<span class="operator">=</span><span class="string">&#x27;OA 请假申请表&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>process_instance_id</code> 字段，关联流程引擎的流程实例对应的 <code>ACT_HI_PROCINST</code> 表的 <code>PROC_INST_ID_</code> 字段</li><li><code>result</code> 字段，请假结果，需要通过 Listener 监听回调结果，稍后来看看</li></ul><p>② 实现业务表的【后端】业务逻辑，具体代码可以看看如下两个类：</p><ul><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-biz/src/main/java/cn/iocoder/yudao/module/bpm/controller/admin/oa/BpmOALeaveController.java">BpmOALeaveController(opens new window)</a></li><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-biz/src/main/java/cn/iocoder/yudao/module/bpm/service/oa/BpmOALeaveServiceImpl.java">BpmOALeaveServiceImpl(opens new window)</a></li></ul><p>重点是看流程发起的逻辑，它定义了 <code>/bpm/oa/leave/create</code> 给业务的表单界面调用，UML 时序图如下：</p><img src="35.png" alt="请假单数据库表" style="zoom:67%;"><p>具体的实现代码比较简单，如下图所示：</p><img src="36.png" alt="BpmOALeaveServiceImpl 创建流程的逻辑" style="zoom:67%;"><ul><li><code>PROCESS_KEY</code> 静态变量：是业务对应的流程模型的编号，稍后会进行创建编号为 oa_leave 的流程模型。</li><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-api/src/main/java/cn/iocoder/yudao/module/bpm/api/task/BpmProcessInstanceApi.java">BpmProcessInstanceApi (opens new window)</a>定义了 <code>#createProcessInstance(...)</code> 方法，用于创建流程实例，业务无需关心底层是 Activiti 还是 Flowable 引擎，甚至未来可能的 Camunda 引擎。</li></ul><p>③ 实现业务表的【前端】业务逻辑，具体代码可以看看如下三个页面：</p><ul><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-ui-admin/src/views/bpm/oa/leave/create.vue"><code>leave/create.vue</code>(opens new window)</a></li><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-ui-admin/src/views/bpm/oa/leave/detail.vue"><code>leave/detail.vue</code>(opens new window)</a></li><li><a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-ui-admin/src/views/bpm/oa/leave/index.vue"><code>leave/index.vue</code>(opens new window)</a></li></ul><p>另外，在 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-ui-admin/src/router/index.js"><code>router/index.js</code> (opens new window)</a>中定义 <code>create.vue</code> 和 <code>detail.vue</code> 的路由，配置如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/bpm&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">    <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;noredirect&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;oa/leave/create&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/views/bpm/oa/leave/create&#x27;</span>], resolve),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;发起 OA 请假&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123;<span class="attr">title</span>: <span class="string">&#x27;发起 OA 请假&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;form&#x27;</span>, <span class="attr">activeMenu</span>: <span class="string">&#x27;/bpm/oa/leave&#x27;</span>&#125;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;oa/leave/detail&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/views/bpm/oa/leave/detail&#x27;</span>], resolve),</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;查看 OA 请假&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123;<span class="attr">title</span>: <span class="string">&#x27;查看 OA 请假&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;view&#x27;</span>, <span class="attr">activeMenu</span>: <span class="string">&#x27;/bpm/oa/leave&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要做独立的 <code>create.vue</code> 和 <code>index.vue</code> 页面？</p><ul><li>创建流程时，需要跳转到 <code>create.vue</code> 页面，填写业务表的信息，才能提交流程。</li><li>审批流程时，需要跳转到 <code>detail.vue</code> 页面，查看业务表的信息。</li></ul><p>④ 实现业务表的【后端】监听逻辑，具体可见 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-biz/src/main/java/cn/iocoder/yudao/module/bpm/service/oa/listener/BpmOALeaveResultListener.java">BpmOALeaveResultListener (opens new window)</a>监听器。它实现流程引擎定义的 <a href="https://github.com/YunaiV/ruoyi-vue-pro/blob/master/yudao-module-bpm/yudao-module-bpm-biz/src/main/java/cn/iocoder/yudao/module/bpm/framework/bpm/core/event/BpmProcessInstanceResultEventListener.java">BpmProcessInstanceResultEventListener (opens new window)</a>抽象类，在流程实例结束时，回调通知它<strong>最终的</strong>结果是通过还是不通过。代码如下图：</p><img src="37.png" alt="BpmOALeaveServiceImpl 创建流程的逻辑" style="zoom:67%;"><hr><p>至此，我们了解了 OALeave 使用业务表单所涉及到的开发，下面我们来定义对应的流程、发起该流程、并审批该流程。</p><h3 id="2-1-第一步：定义流程"><a href="#2-1-第一步：定义流程" class="headerlink" title="#2.1 第一步：定义流程"></a><a href="https://doc.iocoder.cn/bpm/#_2-1-%E7%AC%AC%E4%B8%80%E6%AD%A5-%E5%AE%9A%E4%B9%89%E6%B5%81%E7%A8%8B">#</a>2.1 第一步：定义流程</h3><p>登录账号 admin、密码 admin123 的用户，扮演【管理员】的角色，进行流程的定义。</p><p>① 访问 [工作流程 -&gt; 流程管理 -&gt; 流程模型] 菜单，点击 [新建流程] 按钮，填写流程标识、流程名称。如下图所示：</p><img src="41.png" alt="新建流程" style="zoom:67%;"><p>注意，流程标识需要填 oa_leave。因为在 BpmOALeaveServiceImpl 类中，规定了对应的流程标识为 oa_leave。</p><p>② 点击 [修改流程] 按钮，配置表单类型为业务表单，填写表单提交路由为 <code>/bpm/oa/leave/create</code>（用于发起流程时，跳转的业务表单的路由）、表单查看路由为 <code>/bpm/oa/leave/detail</code>（用于在流程详情中，点击查看表单的路由）。如下图所示：</p><img src="21.png" alt="修改流程" style="zoom:67%;"><p>③ 点击 [设计流程] 按钮，在线设计请假流程模型，包含两个用户任务：领导审批、HR 审批。如下图所示：</p><img src="23.png" alt="设计流程" style="zoom:67%;"><p>可以点击 <a href="https://doc.iocoder.cn/img/%E5%B7%A5%E4%BD%9C%E6%B5%81/oa_leave_bpmn.XML"><code>oa_leave_bpmn.XML</code></a> 进行下载，然后点击 [打开文件] 按钮，进行导入。</p><p>④ 点击 [分配规则] 按钮，设置用户任务的审批人。</p><ul><li>设置【领导审批】的规则类型为自定义脚本 + 流程发起人的一级领导，如下图所示： </li><li><img src="6-a-20231130212043435.png" alt="分配规则 - 领导审批" style="zoom:67%;"></li><li>设置【HR 审批】的规则类型为岗位 + 人力资源，如下图所示： </li><li><img src="6-b-20231130212053376.png" alt="分配规则 - HR 审批" style="zoom:67%;"></li></ul><p>⑤ 点击 [发布流程] 按钮，把定义的流程模型部署出去。部署成功后，就可以发起该流程了。</p><h3 id="2-1-第二步：发起流程"><a href="#2-1-第二步：发起流程" class="headerlink" title="#2.1 第二步：发起流程"></a><a href="https://doc.iocoder.cn/bpm/#_2-1-%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E5%8F%91%E8%B5%B7%E6%B5%81%E7%A8%8B">#</a>2.1 第二步：发起流程</h3><p>登录账号 admin、密码 admin123 的用户，扮演【员工】的角色，进行流程的发起。</p><p>① 发起业务表单请假流程，两种路径：</p><ol><li><p>访问 [工作流程 -&gt; 任务管理 -&gt; 我的流程] 菜单，点击 [发起流程] 按钮，会跳转到流程模型 oa_leave 配置的表单提交路由。</p><p>&lt;img src&#x3D;”会签或签&#x2F;25.png” alt&#x3D;”路径一：我的流程 - style&#x3D;”zoom:67%;” &gt; 发起流程” &#x2F;&gt;</p></li><li><p>访问 [工作流程 -&gt; 请假查询] 菜单，点击 [发起请假] 按钮。</p><p>&lt;img src&#x3D;”会签或签&#x2F;26.png” alt&#x3D;”路径二：请假查询 - style&#x3D;”zoom:67%;” &gt; 发起请假” &#x2F;&gt;</p></li></ol><p>② 填写一个小于等于 3 天的请假，只会走【领导审批】任务；填写一个大于 3 天的请假，在走完【领导审批】任务后，会额外走【HR 审批】任务。</p><p>后续的流程，和「1. 请假流程【流程表单】」是基本一致的，这里就不重复赘述，当然你还是要试着跑一跑，了解整个的过程。</p><h3 id="2-3-第三步：审批流程（领导审批）"><a href="#2-3-第三步：审批流程（领导审批）" class="headerlink" title="#2.3 第三步：审批流程（领导审批）"></a><a href="https://doc.iocoder.cn/bpm/#_2-3-%E7%AC%AC%E4%B8%89%E6%AD%A5-%E5%AE%A1%E6%89%B9%E6%B5%81%E7%A8%8B-%E9%A2%86%E5%AF%BC%E5%AE%A1%E6%89%B9">#</a>2.3 第三步：审批流程（领导审批）</h3><p>略~自己跑</p><h3 id="2-4-第三步：审批流程（HR-审批）"><a href="#2-4-第三步：审批流程（HR-审批）" class="headerlink" title="#2.4 第三步：审批流程（HR 审批）"></a><a href="https://doc.iocoder.cn/bpm/#_2-4-%E7%AC%AC%E4%B8%89%E6%AD%A5-%E5%AE%A1%E6%89%B9%E6%B5%81%E7%A8%8B-hr-%E5%AE%A1%E6%89%B9">#</a>2.4 第三步：审批流程（HR 审批）</h3><p>略~自己跑</p><h2 id="2-流程通知"><a href="#2-流程通知" class="headerlink" title="#2. 流程通知"></a><a href="https://doc.iocoder.cn/bpm/#_2-%E6%B5%81%E7%A8%8B%E9%80%9A%E7%9F%A5">#</a>2. 流程通知</h2><p>流程在发生变化时，会发送通知给相关的人。目前有三个场景会有通知，通过短信的方式。</p><img src="53.png" alt="短信通知" style="zoom:67%;"><h2 id="3-流程图示例"><a href="#3-流程图示例" class="headerlink" title="#3. 流程图示例"></a><a href="https://doc.iocoder.cn/bpm/#_3-%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%A4%BA%E4%BE%8B">#</a>3. 流程图示例</h2><h3 id="3-1-会签"><a href="#3-1-会签" class="headerlink" title="#3.1 会签"></a><a href="https://doc.iocoder.cn/bpm/#_3-1-%E4%BC%9A%E7%AD%BE">#</a>3.1 会签</h3><p>定义：指同一个审批节点设置多个人，如 ABC 三人，三人会同时收到审批，需全部同意之后，审批才可到下一审批节点。</p><p>配置方式如下图所示：</p><img src="60.png" alt="会签示例" style="zoom:67%;"><p>重点是【完成条件】为 <code>$&#123; nrOfCompletedInstances== nrOfInstances &#125;</code>。</p><h3 id="3-2-或签"><a href="#3-2-或签" class="headerlink" title="#3.2 或签"></a><a href="https://doc.iocoder.cn/bpm/#_3-2-%E6%88%96%E7%AD%BE">#</a>3.2 或签</h3><p>定义：指同一个审批节点设置多个人，如ABC三人，三人会同时收到审批，只要其中任意一人审批即可到下一审批节点。</p><p>配置方式如下图所示：</p><img src="61.png" alt="或签示例" style="zoom:67%;"><p>重点是【完成条件】为 <code>$&#123; nrOfCompletedInstances== 1 &#125;</code>。</p><h2 id="4-如何使用-Activiti？"><a href="#4-如何使用-Activiti？" class="headerlink" title="#4. 如何使用 Activiti？"></a><a href="https://doc.iocoder.cn/bpm/#_4-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-activiti">#</a>4. 如何使用 Activiti？</h2><p>Activiti 和 Flowable 提供的 Java API 是基本一致的，例如说 Flowable 的 <code>org.flowable.engine.RepositoryService</code> 对应 Activiti 的 <code>org.activiti.engine .RepositoryService</code>。所以，我们可以修改 <code>import</code> 的包路径来替换。</p><p>另外，在项目的老版本，我们也提供了 Activiti 实现，你可以具体参考下：</p><ul><li><a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro/tree/v1.6.2/yudao-framework/yudao-spring-boot-starter-activiti"><code>yudao-spring-boot-starter-activiti</code>(opens new window)</a></li><li><a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro/tree/v1.6.2/yudao-module-bpm/yudao-module-bpm-biz-activiti"><code>yudao-module-bpm-biz-activiti</code>(opens new window)</a></li></ul><img src="52.png" alt="项目结构" style="zoom:67%;"><h2 id="4-迭代计划"><a href="#4-迭代计划" class="headerlink" title="#4. 迭代计划"></a><a href="https://doc.iocoder.cn/bpm/#_4-%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92">#</a>4. 迭代计划</h2><p>工作流的基本功能已经开发完成，当然还是有很多功能需要进行建设。已经整理在 <a href="https://gitee.com/zhijiantianya/ruoyi-vue-pro/issues/I4UPEU">https://gitee.com/zhijiantianya/ruoyi-vue-pro/issues/I4UPEU (opens new window)</a>链接中，你也可以提一些功能的想法。</p><p>如果您有参与工作流开发的想法，可以添加我的微信 <strong>wangwenbin10</strong> ！</p><p>艿艿会带着你做技术方案，Code Review 你的每一行代码的实现。相信在这个过程中，你会收获不错的技术成长！</p>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/"/>
      <url>/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>1）队列是一个有序列表，可以用数组或链表实现</p><p>2）遵循先入先出的原则。即先存入队列的数据，要先取出。后存入的要后取出</p><p>3）示意图，使用数组模拟</p><img src="image-20221107161952381.png" alt="image-20221107161952381" style="zoom: 67%;"><h4 id="数组模拟队列的思路"><a href="#数组模拟队列的思路" class="headerlink" title="数组模拟队列的思路"></a>数组模拟队列的思路</h4><p>1、队列本身是有序列表，若使用数组的结构来存储队列中的数据，其中maxSize是该队列的最大容量</p><p>2、因为队列的输入、输出是分别从前后端来处理，因此需要两个变量front和rear来记录队列前后端的下标，front会随着数据的输出而改变，rear会随着数据的输入而改变</p><p>当我们将数据存入队列时称为“addQueue”,addQueue的处理需要有两个步骤：思路分析</p><p>​1）将尾指针往后移：rear+1，当front&#x3D;&#x3D;rear时，为空</p><p>​2）若尾指针rear小于队列的最大下表MaxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear&#x3D;&#x3D;MaxSize-1，队列满</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组模拟队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/11/7 16:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>:</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">//该数组用于存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;</span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列的数据，出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示队列的头数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>工作流介绍</title>
      <link href="/2023/11/27/activiti/activiti/"/>
      <url>/2023/11/27/activiti/activiti/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>工作流。通过计算机对业务流程自动化执行管理，主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现”。</p><h2 id="Activiti7"><a href="#Activiti7" class="headerlink" title="Activiti7"></a>Activiti7</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Activiti是一个工作流引擎，Activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由Activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。</p><p>在使用activiti之前，首先需要编写<code>activiti.cfg.xml</code>配置文件。并且引入相关依赖。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--activiti的核心包--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activiti-bpmn-converter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activiti-json-converter&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activiti-bpmn-layout&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;6.0.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.activiti.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;activiti-cloud-services-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;7-201710-EA&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;aspectj&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.4&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.1.40&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;5.0.7.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.7.21&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.7.25&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;commons-io&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;commons-io&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.16.18&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h2 id="activiti-cfg-xml"><a href="#activiti-cfg-xml" class="headerlink" title="activiti.cfg.xml"></a>activiti.cfg.xml</h2><p>activiti的引擎配置文件，包括：<code>ProcessEngineConfiguration</code>的定义、数据源定义、事务管理器等。其实就是一个Spring配置文件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">                            http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--dbcp连接池--&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/activiti&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;3&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--在默认方式下,bean的id固定为processEngineConfiguration--&gt;</span><br><span class="line">    &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;</span><br><span class="line">        &lt;!--配置数据库相关信息--&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">            activiti数据库表处理策略</span><br><span class="line">                false(默认值)：检查数据库的版本和依赖库的版本，如果不匹配就抛出异常</span><br><span class="line">                true：构建流程引擎时，执行检查，如果需要就执行更新。如果表不存在，就创建。</span><br><span class="line">                create-drop：构建流程引擎时创建数据库报表，关闭流程引擎时就删除这些表。</span><br><span class="line">                drop-create：先删除表再创建表。</span><br><span class="line">                create：构建流程引擎时创建数据库表，关闭流程引擎时不删除这些表</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;asyncExecutorActivate&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;mailServerHost&quot; value=&quot;mail.my-corp.com&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;mailServerPort&quot; value=&quot;5025&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>Activiti流程框架，在前期主要需要了解的就是数据库表的创建、流程的部署、流程的启动和各个阶段任务的完成。</p><h2 id="流程引擎配置类"><a href="#流程引擎配置类" class="headerlink" title="流程引擎配置类"></a>流程引擎配置类</h2><p>流程引擎配置类（<code>ProcessEngineConfiguration</code>），通过 <code>ProcessEngineConfiguration</code>可以创建工作流引擎 ProceccEngine。</p><h2 id="工作流引擎的创建"><a href="#工作流引擎的创建" class="headerlink" title="工作流引擎的创建"></a>工作流引擎的创建</h2><p>工作流引擎的创建主要有两种方式：默认创建方式和一般创建方式</p><h3 id="默认创建方式"><a href="#默认创建方式" class="headerlink" title="默认创建方式"></a>默认创建方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">System.out.println(processEngine);</span><br></pre></td></tr></table></figure><h3 id="一般创建方式"><a href="#一般创建方式" class="headerlink" title="一般创建方式"></a>一般创建方式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用自定义方式创建</span><br><span class="line">ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;);</span><br><span class="line">//获取流程引擎对象:通过 ProcessEngineConfiguration 创建 ProcessEngine,此时会创建数据库</span><br><span class="line">ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();</span><br></pre></td></tr></table></figure><p>当创建好工作流引擎后，对应的数据库中会自动生成25张数据库表。</p><p><code>ACT_GE_PROPERTY</code>中会先展示下一次流程的ID（<code>next.dbid</code>），并且在下一次流程部署的时候，对下一次流程的ID进行赋值。</p><h2 id="Activiti表说明"><a href="#Activiti表说明" class="headerlink" title="Activiti表说明"></a>Activiti表说明</h2><p>这里以表名的前缀进行说明：</p><h2 id="Service服务接口"><a href="#Service服务接口" class="headerlink" title="Service服务接口"></a>Service服务接口</h2><p>Activiti中还有许多的Service服务接口。这些Service 是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们可以使用这些接口操作服务对应的数据表。扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247494250&idx=2&sn=957a5eb085292fb716d5b7db6f8a8628&chksm=e80e5c1cdf79d50adce9e6266562ad1e283a5997b7f3b21f3c394d20819080c2f34aea7b8eaa&scene=21#wechat_redirect">最全的java面试题库</a></p><h3 id="Service创建方式"><a href="#Service创建方式" class="headerlink" title="Service创建方式"></a>Service创建方式</h3><p>通过<code>ProcessEngine</code>创建Service方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtimeservice runtimeService = processEngine.getRuntimeService();</span><br><span class="line">RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">TaskService taskService = processEngine.getTaskService();</span><br></pre></td></tr></table></figure><h3 id="Service总览"><a href="#Service总览" class="headerlink" title="Service总览"></a>Service总览</h3><ul><li><strong>RepositoryService</strong></li></ul><p>Activiti 的资源管理类，提供了管理和控制流程发布包和流程定义的操作。使用工作流建模工具设计的业务流程图需要使用此service将流程定义文件的内容部署到计算机。除了部署流程定义以外，还可以查询引擎中的发布包和流程定义。</p><p>暂停或激活发布包，对应全部和特定流程定义。暂停意味着它们不能再执行任何操作了，激活是对应的反向操作。获得多种资源，像是包含在发布包里的文件，或引擎自动生成的流程图。获得流程定义的pojo版本，可以用来通过java解析流程，而不必通过xml。</p><ul><li><strong>Runtimeservice</strong></li></ul><p>Activiti的流程运行管理类。可以从这个服务类中获取很多关于流程执行相关的信息</p><ul><li><strong>Taskservice</strong></li></ul><p>Activiti的任务管理类。可以从这个类中获取任务的信息。</p><ul><li><strong>Historyservice</strong></li></ul><p>Activiti的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置)，比如流程实例启动时间，任务的参与者，完成任务的时间，每个流程实例的执行路径，等等。这个服务主要通过查询功能来获得这些数据。</p><ul><li><strong>ManagementService</strong></li></ul><p>Activiti的引擎管理类，提供了对Activiti流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于Activiti 系统的日常维护。</p><h2 id="流程图符号说明"><a href="#流程图符号说明" class="headerlink" title="流程图符号说明"></a>流程图符号说明</h2><img src="11/27/activiti/activiti/640.png" class title="图片"><h3 id="BPMN插件"><a href="#BPMN插件" class="headerlink" title="BPMN插件"></a>BPMN插件</h3><p>使用IDEA进行开发，建议下载一个插件。actiBPM插件，直接搜索下载。</p><h3 id="流程符号、画流程图"><a href="#流程符号、画流程图" class="headerlink" title="流程符号、画流程图"></a>流程符号、画流程图</h3><p>流程符号：事件Event，活动Activity，网关Gateway，流向</p><p>使用流程设计器画出流程图</p><ul><li>创建bpmn文件，在流程设计器使用流程符号来表达流程，指定流程的key，指定任务负责人</li><li>生成png文件</li><li>创建的bpmn文件要放在resourse下的bpmn文件夹下。</li></ul><img src="11/27/activiti/activiti/640-20231130211833149.png" class title="图片"><img src="640-20231130211838133.png" alt="图片" style="zoom:67%;"><p>注意： 当前任务流程的ID不能是数字开头。</p><img src="640-20231130211850057.png" alt="图片" style="zoom:67%;"><p>找到本地的文件，选择notepad打开</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;</span><br><span class="line">&lt;definitions xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot; xmlns:activiti=&quot;http://activiti.org/bpmn&quot; xmlns:bpmndi=&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot; xmlns:omgdc=&quot;http://www.omg.org/spec/DD/20100524/DC&quot; xmlns:omgdi=&quot;http://www.omg.org/spec/DD/20100524/DI&quot; xmlns:tns=&quot;http://www.activiti.org/test&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; id=&quot;m1611283406582&quot; name=&quot;&quot; targetNamespace=&quot;http://www.activiti.org/test&quot; typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;</span><br><span class="line">  &lt;process id=&quot;myEvection&quot; isClosed=&quot;false&quot; isExecutable=&quot;true&quot; name=&quot;出差申请&quot; processType=&quot;None&quot;&gt;</span><br><span class="line">    &lt;startEvent id=&quot;_2&quot; name=&quot;StartEvent&quot;/&gt;</span><br><span class="line">    &lt;userTask activiti:assignee=&quot;zhangsan&quot; activiti:exclusive=&quot;true&quot; id=&quot;_3&quot; name=&quot;创建出差申请&quot;/&gt;</span><br><span class="line">    &lt;userTask activiti:assignee=&quot;jerry&quot; activiti:exclusive=&quot;true&quot; id=&quot;_4&quot; name=&quot;经理审批&quot;/&gt;</span><br><span class="line">    &lt;userTask activiti:assignee=&quot;jack&quot; activiti:exclusive=&quot;true&quot; id=&quot;_5&quot; name=&quot;总经理审批&quot;/&gt;</span><br><span class="line">    &lt;userTask activiti:assignee=&quot;rose&quot; activiti:exclusive=&quot;true&quot; id=&quot;_6&quot; name=&quot;财务审批&quot;/&gt;</span><br><span class="line">    &lt;endEvent id=&quot;_7&quot; name=&quot;EndEvent&quot;/&gt;</span><br><span class="line">    &lt;sequenceFlow id=&quot;_8&quot; sourceRef=&quot;_2&quot; targetRef=&quot;_3&quot;/&gt;</span><br><span class="line">    &lt;sequenceFlow id=&quot;_9&quot; sourceRef=&quot;_3&quot; targetRef=&quot;_4&quot;/&gt;</span><br><span class="line">    &lt;sequenceFlow id=&quot;_10&quot; sourceRef=&quot;_4&quot; targetRef=&quot;_5&quot;/&gt;</span><br><span class="line">    &lt;sequenceFlow id=&quot;_11&quot; sourceRef=&quot;_5&quot; targetRef=&quot;_6&quot;/&gt;</span><br><span class="line">    &lt;sequenceFlow id=&quot;_12&quot; sourceRef=&quot;_6&quot; targetRef=&quot;_7&quot;/&gt;</span><br><span class="line">  &lt;/process&gt;</span><br><span class="line">  &lt;bpmndi:BPMNDiagram documentation=&quot;background=#FFFFFF;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0&quot; id=&quot;Diagram-_1&quot; name=&quot;New Diagram&quot;&gt;</span><br><span class="line">    &lt;bpmndi:BPMNPlane bpmnElement=&quot;myEvection&quot;&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=&quot;_2&quot; id=&quot;Shape-_2&quot;&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=&quot;32.0&quot; width=&quot;32.0&quot; x=&quot;185.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;32.0&quot; width=&quot;32.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=&quot;_3&quot; id=&quot;Shape-_3&quot;&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;160.0&quot; y=&quot;85.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=&quot;_4&quot; id=&quot;Shape-_4&quot;&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;160.0&quot; y=&quot;185.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=&quot;_5&quot; id=&quot;Shape-_5&quot;&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;160.0&quot; y=&quot;285.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=&quot;_6&quot; id=&quot;Shape-_6&quot;&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;160.0&quot; y=&quot;390.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;55.0&quot; width=&quot;85.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNShape bpmnElement=&quot;_7&quot; id=&quot;Shape-_7&quot;&gt;</span><br><span class="line">        &lt;omgdc:Bounds height=&quot;32.0&quot; width=&quot;32.0&quot; x=&quot;185.0&quot; y=&quot;475.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;32.0&quot; width=&quot;32.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNShape&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=&quot;_12&quot; id=&quot;BPMNEdge__12&quot; sourceElement=&quot;_6&quot; targetElement=&quot;_7&quot;&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;201.0&quot; y=&quot;445.0&quot;/&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;201.0&quot; y=&quot;475.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;0.0&quot; width=&quot;0.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=&quot;_8&quot; id=&quot;BPMNEdge__8&quot; sourceElement=&quot;_2&quot; targetElement=&quot;_3&quot;&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;201.0&quot; y=&quot;32.0&quot;/&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;201.0&quot; y=&quot;85.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;0.0&quot; width=&quot;0.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=&quot;_9&quot; id=&quot;BPMNEdge__9&quot; sourceElement=&quot;_3&quot; targetElement=&quot;_4&quot;&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;202.5&quot; y=&quot;140.0&quot;/&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;202.5&quot; y=&quot;185.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;0.0&quot; width=&quot;0.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=&quot;_11&quot; id=&quot;BPMNEdge__11&quot; sourceElement=&quot;_5&quot; targetElement=&quot;_6&quot;&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;202.5&quot; y=&quot;340.0&quot;/&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;202.5&quot; y=&quot;390.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;0.0&quot; width=&quot;0.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">      &lt;bpmndi:BPMNEdge bpmnElement=&quot;_10&quot; id=&quot;BPMNEdge__10&quot; sourceElement=&quot;_4&quot; targetElement=&quot;_5&quot;&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;202.5&quot; y=&quot;240.0&quot;/&gt;</span><br><span class="line">        &lt;omgdi:waypoint x=&quot;202.5&quot; y=&quot;285.0&quot;/&gt;</span><br><span class="line">        &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">          &lt;omgdc:Bounds height=&quot;0.0&quot; width=&quot;0.0&quot; x=&quot;0.0&quot; y=&quot;0.0&quot;/&gt;</span><br><span class="line">        &lt;/bpmndi:BPMNLabel&gt;</span><br><span class="line">      &lt;/bpmndi:BPMNEdge&gt;</span><br><span class="line">    &lt;/bpmndi:BPMNPlane&gt;</span><br><span class="line">  &lt;/bpmndi:BPMNDiagram&gt;</span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure><h2 id="流程的操作"><a href="#流程的操作" class="headerlink" title="流程的操作"></a>流程的操作</h2><h3 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h3><p>使用 Activiti 提供的 API 把流程图的内容写入到数据库中</p><p>属于资源操作类，使用 <code>RepositoryService</code></p><ul><li>单文件部署：把bpmn文件和png文件逐个处理</li><li>压缩包部署：把bpmn文件和png文件打成压缩包来处理</li><li>部署操作表：<code>act_re_deployment</code>、<code>act_re_procdef</code>、<code>act_ge_bytearray</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 流程部署</span><br><span class="line"> */</span><br><span class="line">public void deployment() &#123;</span><br><span class="line">    // 创建 ProcessEngine</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    // 获取 RepositoryService</span><br><span class="line">    RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">    // 使用 service 进行流程的部署,定义一个流程的名字,把bpmn和png部署到数据中</span><br><span class="line">    Deployment deployment = repositoryService.createDeployment()</span><br><span class="line">            .name(&quot;出差申请流程&quot;) //流程图标的名字</span><br><span class="line">            .addClasspathResource(&quot;bpmn/evection.bpmn&quot;) //bpmn文件</span><br><span class="line">            .addClasspathResource(&quot;bpmn/evection.png&quot;) //bpmn文件生成的图片</span><br><span class="line">            .deploy();</span><br><span class="line">    // 输出部署信息</span><br><span class="line">    System.out.println(&quot;流程部署ID:&quot; + deployment.getId());</span><br><span class="line">    System.out.println(&quot;流程部署名字:&quot; + deployment.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候我们会有多个流程，需要创建多个bpmn流程文件，这个时候想要同时部署，我们可以对bpmn文件进行打包压缩，使用Zip包进行批量的部署</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用Zip包进行批量的部署</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void deployProcessByZip() &#123;</span><br><span class="line">    // 获取流程引擎</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    // 获取 RepositoryService</span><br><span class="line">    RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">    // 流程部署</span><br><span class="line">    // 读取资源包文件，构造成 InputStream</span><br><span class="line">    InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(&quot;bpmn/evection.zip&quot;);</span><br><span class="line">    // 使用 InputStream 构造 ZipInputStream</span><br><span class="line">    ZipInputStream zipInputStream = new ZipInputStream(inputStream);</span><br><span class="line">    // 使用压缩包的流，进行流程的部署</span><br><span class="line">    Deployment deploy = repositoryService.createDeployment()</span><br><span class="line">            .addZipInputStream(zipInputStream)</span><br><span class="line">            .deploy();</span><br><span class="line">    // 输出</span><br><span class="line">    System.out.println(&quot;流程部署的ID：&quot; + deploy.getId());</span><br><span class="line">    System.out.println(&quot;流程部署的名称：&quot; + deploy.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作的数据库表：</p><ul><li>act_ge_bytearray</li><li>act_ge_property</li><li>act_re_deployment</li><li>act_re_procdef</li></ul><h3 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h3><p>流程部署完成以后，需要启动流程实例。使用 <code>RuntimeService</code> 根据流程定义的 key进行启动。</p><p>核心代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动流程</span><br><span class="line"> */</span><br><span class="line">public void starProcess() &#123;</span><br><span class="line">    // 创建 ProcessEngine</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    // 获取 RunTimeService</span><br><span class="line">    RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">    // 根据流程定义的ID启动流程</span><br><span class="line">    ProcessInstance instance = runtimeService.startProcessInstanceByKey(&quot;myEvection&quot;);</span><br><span class="line">    // 输出内容</span><br><span class="line">    System.out.println(&quot;流程定义ID:&quot; + instance.getProcessDefinitionId());</span><br><span class="line">    System.out.println(&quot;流程实例的ID:&quot; + instance.getId());</span><br><span class="line">    System.out.println(&quot;当前活动的ID:&quot; + instance.getActivityId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务查询"><a href="#任务查询" class="headerlink" title="任务查询"></a>任务查询</h3><p>使用 <code>TaskService</code> ，根据流程定义的 key ，任务负责人来进行查询</p><p>核心代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 查询个人待执行的任务</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void findPersonalTaskList() &#123;</span><br><span class="line">    // 获取流程引擎</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    // 获取TaskService</span><br><span class="line">    TaskService taskService = processEngine.getTaskService();</span><br><span class="line">    // 根据流程的key和任务的负责人去查询任务</span><br><span class="line">    List&lt;Task&gt; taskList = taskService.createTaskQuery()</span><br><span class="line">            .processDefinitionKey(&quot;myEvection&quot;)  // 流程的key</span><br><span class="line">            .includeProcessVariables()</span><br><span class="line">            .taskAssignee(&quot;zhangsan&quot;)           // 要查询的负责人</span><br><span class="line">            .list();</span><br><span class="line">    // 输出</span><br><span class="line">    for (Task task : taskList) &#123;</span><br><span class="line">        System.out.println(&quot;流程实例的ID：&quot; + task.getProcessInstanceId());</span><br><span class="line">        System.out.println(&quot;任务的ID：&quot; + task.getId());</span><br><span class="line">        System.out.println(&quot;任务的负责人：&quot; + task.getAssignee());</span><br><span class="line">        System.out.println(&quot;任务的名称：&quot; + task.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务完成"><a href="#任务完成" class="headerlink" title="任务完成"></a>任务完成</h3><p>使用 <code>TaskService</code> ，用任务 ID 直接完成任务。</p><p>核心代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 完成个人任务</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void completTask() &#123;</span><br><span class="line">    String key = &quot;testCandidiate&quot;;</span><br><span class="line">    String assignee = &quot;张三1&quot;; //任务的负责人</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    TaskService taskService = processEngine.getTaskService();</span><br><span class="line">    Task task = taskService.createTaskQuery()</span><br><span class="line">            .processDefinitionKey(key)</span><br><span class="line">            .taskAssignee(assignee)</span><br><span class="line">            .singleResult();</span><br><span class="line">    if (task != null) &#123;</span><br><span class="line">        taskService.complete(task.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关于流程实例的挂起和激活"><a href="#关于流程实例的挂起和激活" class="headerlink" title="关于流程实例的挂起和激活"></a>关于流程实例的挂起和激活</h3><p>全部流程实例的挂起和激活</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 全部流程实例的挂起和激活</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void suspendAllProcessInstance() &#123;</span><br><span class="line">    // 1.获取流程引擎</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    // 2.获取 RepositoryService</span><br><span class="line">    RepositoryService repositoryService = processEngine.getRepositoryService();</span><br><span class="line">    // 3.查询流程定义</span><br><span class="line">    ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()</span><br><span class="line">            .processDefinitionKey(&quot;myEvection&quot;)</span><br><span class="line">            .singleResult();</span><br><span class="line">    // 4.获取当前流程定义的实例是否都是挂起状态</span><br><span class="line">    boolean flag = processDefinition.isSuspended();</span><br><span class="line">    // 5.获取流程定义的ID</span><br><span class="line">    String id = processDefinition.getId();</span><br><span class="line">    // 6.判断是否挂起状态。是:改为激活;否:改为挂起</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        // 改为激活. 参数1:流程定义的ID,参数2:是否激活,参数3:激活时间</span><br><span class="line">        repositoryService.activateProcessDefinitionById(id, true, null);</span><br><span class="line">        System.out.println(&quot;流程定义ID：&quot; + id + &quot;已激活&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 改为挂起. 参数1:流程定义的ID;参数2:是否挂起;参数3:挂起时间</span><br><span class="line">        repositoryService.suspendProcessDefinitionById(id, true, null);</span><br><span class="line">        System.out.println(&quot;流程定义ID：&quot; + id + &quot;已挂起&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单个流程实例的挂起和激活</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 单个流程实例的挂起和激活</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void suspendSingleProcessInstance() &#123;</span><br><span class="line">    // 1.获取流程引擎</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    // 2.获取 RuntimeService</span><br><span class="line">    RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">    // 3.通过 RuntimeService 获取流程实例对象</span><br><span class="line">    ProcessInstance instance = runtimeService.createProcessInstanceQuery()</span><br><span class="line">            .processInstanceId(&quot;17501&quot;)</span><br><span class="line">            .singleResult();</span><br><span class="line">    // 4.得到当前流程实例的暂停状态</span><br><span class="line">    boolean flag = instance.isSuspended();</span><br><span class="line">    // 5.获取流程实例的ID</span><br><span class="line">    String instanceId = instance.getId();</span><br><span class="line">    // 6.判断是否暂停。是:改为激活;否:改为暂停</span><br><span class="line">    if (flag) &#123;</span><br><span class="line">        runtimeService.activateProcessInstanceById(instanceId);</span><br><span class="line">        System.out.println(&quot;流程实例ID：&quot; + instanceId + &quot;已激活&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        runtimeService.suspendProcessInstanceById(instanceId);</span><br><span class="line">        System.out.println(&quot;流程实例ID：&quot; + instanceId + &quot;已暂停&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 流程实例在挂起的状态下是无法进行下一步操作的。扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247494250&idx=2&sn=957a5eb085292fb716d5b7db6f8a8628&chksm=e80e5c1cdf79d50adce9e6266562ad1e283a5997b7f3b21f3c394d20819080c2f34aea7b8eaa&scene=21#wechat_redirect">最全的java面试题库</a></p><h2 id="流程变量"><a href="#流程变量" class="headerlink" title="流程变量"></a>流程变量</h2><p>我们在使用流程变量的时候。如果我们将一个对象存储到一个流程变量中，那么这个对象需要实现Serializable接口。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 出差申请中的流程变量对象</span><br><span class="line"> */</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@Data</span><br><span class="line">public class Evection implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private Long id;                //主键ID</span><br><span class="line">    private Integer days;            //出差天数</span><br><span class="line">    private String evectionName;    //出差单名字</span><br><span class="line">    private Date startTime;         //出差开始时间</span><br><span class="line">    private Date endTime;           //出差结束时间</span><br><span class="line">    private String address;         //目的地</span><br><span class="line">    private String reason;          //出差原因</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>流程变量的作用域</strong></p><ul><li>整个流程实例、任务、执行实例。</li><li>默认：整个流程实例。</li></ul><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>在属性上使用UEL表达式 <code>$&#123;assignee&#125;</code>，<code>assignee</code>就是一个流程变量的名称。</p><p>在连线上使用UEL表达式 <code>$&#123;days&lt;=3&#125;</code>，days就是一个流程变量名称，返回结果为true或者false。</p><img src="640-20231130211859212.png" alt="图片" style="zoom:67%;"><p>Activiti有很多种方式设置流程变量，这里简单介绍两种：</p><p><strong>启动流程时设置流程变量</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 启动流程</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void startProcess() &#123;</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    RuntimeService runtimeService = processEngine.getRuntimeService();</span><br><span class="line">    // 流程变量map</span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    // 设置流程变量</span><br><span class="line">    Evection evection = new Evection();</span><br><span class="line">    evection.setDays(2);</span><br><span class="line">    // 把流程变量的pojo放入map</span><br><span class="line">    map.put(&quot;evection&quot;, evection);</span><br><span class="line">    map.put(&quot;assignee0&quot;, &quot;张三&quot;);</span><br><span class="line">    map.put(&quot;assignee1&quot;, &quot;李经理&quot;);</span><br><span class="line">    map.put(&quot;assignee2&quot;, &quot;王财务&quot;);</span><br><span class="line">    map.put(&quot;assignee3&quot;, &quot;赵总经理&quot;);</span><br><span class="line">    runtimeService.startProcessInstanceByKey(&quot;myProcess_1&quot;, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务办理时设置</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 完成任务</span><br><span class="line"> */</span><br><span class="line">@Test</span><br><span class="line">public void completTask() &#123;</span><br><span class="line">    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();</span><br><span class="line">    TaskService taskService = processEngine.getTaskService();</span><br><span class="line">    Evection evection = new Evection();</span><br><span class="line">    evection.setDays(2);</span><br><span class="line">    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;evection&quot;, evection);</span><br><span class="line">    Task task = taskService.createTaskQuery()</span><br><span class="line">            .processDefinitionKey(&quot;myProcess_2&quot;)</span><br><span class="line">            .taskAssignee(&quot;王财务0&quot;)</span><br><span class="line">            .singleResult();</span><br><span class="line">    if (task != null) &#123;</span><br><span class="line">        String taskId = task.getId();</span><br><span class="line">        // 完成任务</span><br><span class="line">        taskService.complete(taskId, map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>用来控制流程的走向</p><h3 id="排他网关——ExclusiveGateway"><a href="#排他网关——ExclusiveGateway" class="headerlink" title="排他网关——ExclusiveGateway"></a>排他网关——ExclusiveGateway</h3><p>用来在流程中实现决策，当流程执行到这个网关，所有的分支都会判断条件是否为true，如果为true，则执行该分支。</p><blockquote><p>注意： 排他网关只会选择一个作为true的分支执行，如果有两个分支都为true，排他网关会选择ID值比较小的一条分支去执行。</p></blockquote><p>如果从排他网关出去的流程所有的条件都不满足，则会抛出异常。扩展：<a href="http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247494250&idx=2&sn=957a5eb085292fb716d5b7db6f8a8628&chksm=e80e5c1cdf79d50adce9e6266562ad1e283a5997b7f3b21f3c394d20819080c2f34aea7b8eaa&scene=21#wechat_redirect">最全的java面试题库</a></p><h3 id="并行网关——ParallelGateway"><a href="#并行网关——ParallelGateway" class="headerlink" title="并行网关——ParallelGateway"></a>并行网关——ParallelGateway</h3><p>并行网关，允许流程分成多条分支，也可以把多分支汇聚到一起，并行网关的功能是基于进入和外出顺序流的：</p><ul><li><strong>fork分支</strong>：并行后的所有外出顺序流，为每个顺序流都创建一个并发分支</li><li><strong>join汇聚</strong>：所有到达并行网关，在此等待的分支，直到所有进入顺序流的分支都到达以后，流程就会通过汇聚网关。</li></ul><blockquote><p>注意： 如果同一个并行网关有多个进入和多个外出顺序流，它就同时具有分支和汇聚功能，这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支。</p></blockquote><p>与其他网关的主要区别是：并行网关不会解析条件，即使顺序流中定义了条件，也会被忽略。</p><p>并行网关需要所有分支的全部运行完了，才会汇聚，继续向下执行。</p><h3 id="包含网关——InclusiveGateway"><a href="#包含网关——InclusiveGateway" class="headerlink" title="包含网关——InclusiveGateway"></a>包含网关——InclusiveGateway</h3><p>包含网关可以看成是排他网关和并行网关的结合体，和排他网关一样，可以在外出顺序流上定义条件，包含网关会解析它们，但是主要的区别是：包含网关可以选择多于一条顺序流，这和并行网关一样。</p><p>包含网关的功能是基于进入和外出顺序流的。</p><ul><li><strong>分支</strong>：所有外出顺序流的条件都会被解析，结果为true的顺序流会以并行方式继续执行，会为每一个顺序流创建一个分支。</li><li><strong>汇聚</strong>：所有并行分支到达包含网关，会进入等待状态，直到每个包含流程token的进入顺序流的分支都到达。这是和并行网关最大的不同。</li></ul><h3 id="事件网关——EventGateway"><a href="#事件网关——EventGateway" class="headerlink" title="事件网关——EventGateway"></a>事件网关——EventGateway</h3><h5 id="Activiti和Spring的整合开发"><a href="#Activiti和Spring的整合开发" class="headerlink" title="Activiti和Spring的整合开发"></a>Activiti和Spring的整合开发</h5><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span><br><span class="line">         http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--工作流引擎配置对象--&gt;</span><br><span class="line">    &lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt;</span><br><span class="line">        &lt;!--数据源--&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">        &lt;!--使用Spring的事务管理器--&gt;</span><br><span class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        数据库策略:</span><br><span class="line">            false:默认值。activiti在启动时，会对比数据库表中保存的版本。如果没有表或者版本不匹配，将抛出     异常。</span><br><span class="line">            true:activiti会对数据库中所有表进行更新操作，如果表不存在，则会自动创建。</span><br><span class="line">            create_drop:在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）。</span><br><span class="line">            drop-create:在activiti启动时删除原来的旧表，然后再创建新表（不需要手动关闭引擎）。</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;property name=&quot;databaseSchemaUpdate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置数据源--&gt;</span><br><span class="line">    &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/actspring&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxActive&quot; value=&quot;3&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;maxIdle&quot; value=&quot;1&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 流程引擎对象 --&gt;</span><br><span class="line">    &lt;bean id=&quot;processEngine&quot; class=&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;processEngineConfiguration&quot; ref=&quot;processEngineConfiguration&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--资源服务--&gt;</span><br><span class="line">    &lt;bean id=&quot;repositoryService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRepositoryService&quot;/&gt;</span><br><span class="line">    &lt;!--流程管理--&gt;</span><br><span class="line">    &lt;bean id=&quot;runtimeService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getRuntimeService&quot;/&gt;</span><br><span class="line">    &lt;!--任务管理--&gt;</span><br><span class="line">    &lt;bean id=&quot;taskService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getTaskService&quot;/&gt;</span><br><span class="line">    &lt;!--历史管理--&gt;</span><br><span class="line">    &lt;bean id=&quot;historyService&quot; factory-bean=&quot;processEngine&quot; factory-method=&quot;getHistoryService&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--事务管理器--&gt;</span><br><span class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--通知--&gt;</span><br><span class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!--传播行为--&gt;</span><br><span class="line">            &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/tx:attributes&gt;</span><br><span class="line">    &lt;/tx:advice&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h5 id="Activiti和SpringBoot的整合开发"><a href="#Activiti和SpringBoot的整合开发" class="headerlink" title="Activiti和SpringBoot的整合开发"></a>Activiti和SpringBoot的整合开发</h5><p>配置文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: actspringboot</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:3306/actspring?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;autoReconnect=true&amp;serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">  activiti:</span><br><span class="line">    # false:默认值。activiti在启动时，会对比数据库表中保存的版本。如果没有表或者版本不匹配，将抛出异常</span><br><span class="line">    # true:activiti会对数据库中所有表进行更新操作，如果表不存在，则会自动创建</span><br><span class="line">    # create_drop:在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）</span><br><span class="line">    # drop-create:在activiti启动时删除原来的旧表，然后再创建新表（不需要手动关闭引擎）</span><br><span class="line">    # 线上一般使用false,开发中使用true</span><br><span class="line">    database-schema-update: true</span><br><span class="line">    # 自动部署验证设置:true-开启（默认）、false-关闭</span><br><span class="line">    check-process-definitions: false</span><br><span class="line">    # 开启历史表</span><br><span class="line">    db-history-used: true</span><br><span class="line">    # 历史记录存储等级</span><br><span class="line">    history-level: full</span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作流 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OAuth2.0</title>
      <link href="/2023/11/27/Spring%20Security/OAuth2.0/"/>
      <url>/2023/11/27/Spring%20Security/OAuth2.0/</url>
      
        <content type="html"><![CDATA[<h1 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h1><blockquote><p>（1）Third-party application：第三方应用程序，客户端</p><p>（2）HTTP Service：HTTP服务提供商，本文中简称”服务提供商”</p><p>（3） Resource Owner：资源所有者，用户</p><p>（4）User Agent：用户代理，本文指浏览器</p><p>（5）Authorization Server：认证服务器，专门用来处理认证的服务器</p><p>（6）Resource Server：资源服务器，存放用户生成的资源的服务器</p></blockquote><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><img src="6a92a862da97a4692c755c7e186dfd07.jpg" alt="6a92a862da97a4692c755c7e186dfd07" style="zoom:67%;"><blockquote><p>（A）用户打开客户端以后，客户端要求用户给予授权。</p><p>（B）用户同意给予客户端授权。</p><p>（C）客户端使用上一步获得的授权，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p></blockquote><h3 id="OAuth2-0四种授权方式"><a href="#OAuth2-0四种授权方式" class="headerlink" title="OAuth2.0四种授权方式"></a>OAuth2.0四种授权方式</h3><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><img src="8a16a81fbba3d6ba1002921bf6b4feff.jpg" alt="8a16a81fbba3d6ba1002921bf6b4feff" style="zoom:67%;"><blockquote><p>（A）用户访问客户端，后者将前者导向认证服务器。</p><p>（B）用户选择是否给予客户端授权。</p><p>（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），同时附上一个授权码。</p><p>（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。</p><p>（E）认证服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。</p></blockquote><p>下面是上面这些步骤所需要的参数。</p><p>A步骤中，客户端申请认证的URI，包含以下参数：</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><p>例子：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: server.example.com</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><p>C步骤中，服务器回应客户端的URI，包含以下参数：</p><ul><li>code：表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。</li><li>state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。</li></ul><p>下面是一个例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">HTTP/1.1 302 Found</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">          &amp;state=xyz</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><p>D步骤中，客户端向认证服务器申请令牌的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li><li>client_id：表示客户端ID，必选项。</li></ul><p>下面是一个例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">POST /token HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: server.example.com</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt; grant_type=authorization_code&amp;code=SplxlOBeZQQYbYS6WxSbIA</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><p>E步骤中，认证服务器发送的HTTP回复，包含以下参数：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>下面是一个例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     HTTP/1.1 200 OK</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Content-Type: application/json;charset=UTF-8</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Cache-Control: no-store</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Pragma: no-cache</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt;      &#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;example&quot;</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;expires_in&quot;</span>:3600,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;example_parameter&quot;</span>:<span class="string">&quot;example_value&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     &#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向”服务商提供商”索要授权。</p><p>在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。</p><img src="1e7d96e9ed5ab025afd37c1ca97d1b39.jpg" alt="1e7d96e9ed5ab025afd37c1ca97d1b39" style="zoom:67%;"><p>它的步骤如下：</p><blockquote><p>（A）用户向客户端提供用户名和密码。</p><p>（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。</p><p>（C）认证服务器确认无误后，向客户端提供访问令牌。</p></blockquote><p>B步骤中，客户端发出的HTTP请求，包含以下参数：</p><ul><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p>例子</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     POST /token HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Host: server.example.com</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Content-Type: application/x-www-form-urlencoded</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt;      grant_type=password&amp;username=johndoe&amp;password=A3ddj3w</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><p>C步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     HTTP/1.1 200 OK</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Content-Type: application/json;charset=UTF-8</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Cache-Control: no-store</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     Pragma: no-cache</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">&gt;      &#123;</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;2YotnFZFEjr1zCsicMWpAA&quot;</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;example&quot;</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;expires_in&quot;</span>:3600,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;</span>,</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">       <span class="string">&quot;example_parameter&quot;</span>:<span class="string">&quot;example_value&quot;</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">     &#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span></span><br></pre></td></tr></table></figure><h4 id="授权方式的选择"><a href="#授权方式的选择" class="headerlink" title="授权方式的选择"></a>授权方式的选择</h4><img src="授权模式的选择.png" alt="授权模式的选择" style="zoom:67%;"><blockquote><p>问题一：什么场景下，使用客户端模式（Client Credentials）？</p></blockquote><p>如果令牌拥有者是<strong>机器</strong>的情况下，那就使用客户端模式。 例如说：</p><ul><li>开发了一个开放平台，提供给其它外部服务调用</li><li>开发了一个 RPC 服务，提供给其它内部服务调用</li></ul><p>实际的案例，我们接入微信公众号时，会使用 <code>appid</code> 和 <code>secret</code> 参数，<a href="https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html">获取 Access token (opens new window)</a>访问令牌。</p><blockquote><p>问题二：什么场景下，使用密码模式（Resource Owner Password Credentials）？</p></blockquote><p>接入的 Client 客户端，是属于<strong>自己</strong>的情况下，可以使用密码模式。 例如说：</p><ul><li>客户端是你自己公司的 App 或网页，然后授权服务也是你公司的</li></ul><p>不过，如果客户端是<strong>第三方</strong>的情况下，使用密码模式的话，该客户端是可以拿到用户的账号、密码，存在安全的风险，此时可以考虑使用授权码或简化模式。</p><blockquote><p>问题三：什么场景下，使用授权码模式（Authorization Code）？</p></blockquote><p>接入的 Client 客户端，是属于<strong>第三方</strong>的情况下，可以使用授权码模式。例如说：</p><ul><li>客户端是你自己公司的 App 或网页，作为第三方，接入 <a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html">微信 (opens new window)</a>、<a href="https://wiki.connect.qq.com/oauth2-0%E7%AE%80%E4%BB%8B">QQ (opens new window)</a>、<a href="https://open.dingtalk.com/document/mobile-app-guide/mobile-application-access">钉钉 (opens new window)</a>等等进行 OAuth 2.0 登录</li></ul><p>当然，如果客户端是<strong>自己</strong>的情况下，也可以采用授权码模式。例如说：</p><ul><li>客户端是腾讯旗下的各种游戏，可使用微信、QQ，接入 <a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html">微信 (opens new window)</a>、<a href="https://wiki.connect.qq.com/oauth2-0%E7%AE%80%E4%BB%8B">QQ (opens new window)</a>等等进行 OAuth 2.0 登录</li><li>客户端是公司内的各种管理后台（ERP、OA、CRM 等），跳转到统一的 SSO 单点登录，使用授权码模式进行授权</li></ul><img src="授权码模式的单点登录.png" alt="授权码模式的单点登录" style="zoom:67%;"><blockquote><p>问题四：什么场景下，使用简化模式（Implicit）？</p></blockquote><p>简化模式，<strong>简化</strong> 的是授权码模式的流程的 <strong>第二步</strong>，差异在于：</p><ul><li>授权码模式：授权完成后，获得的是 code 授权码，需要 Server Side 服务端使用该授权码，再向授权服务器获取 Access Token 访问令牌</li><li>简化模式：授权完成后，Client Side 客户端直接获得 Access Token 访问令牌</li></ul><p>暂时没有特别好的案例，感兴趣可以看看如下文档，也可以不看：</p><ul><li><a href="https://wiki.connect.qq.com/%E5%BC%80%E5%8F%91%E6%94%BB%E7%95%A5_client-side">《QQ OAuth 2.0 开发指定 —— 开发攻略_Client-side》(opens new window)</a></li><li><a href="http://developer.baidu.com/wiki/index.php?title=docs/oauth/implicit">《百度 OAuth —— Implicit Grant 授权》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OAuth2.0 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/11/27/Redis7/Redis/"/>
      <url>/2023/11/27/Redis7/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-NoSQL-数据库简介"><a href="#1-NoSQL-数据库简介" class="headerlink" title="1. NoSQL 数据库简介"></a>1. NoSQL 数据库简介</h2><h2 id="1-1-技术发展"><a href="#1-1-技术发展" class="headerlink" title="1. 1. 技术发展"></a>1. 1. 技术发展</h2><p>技术的分类</p><p>1 、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p><p>2 、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p><h6 id="3-、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch"><a href="#3-、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch" class="headerlink" title="3 、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch"></a>3 、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</h6><h2 id="1-1-1-Web-1-0-时代"><a href="#1-1-1-Web-1-0-时代" class="headerlink" title="1. 1. 1. Web 1. 0 时代"></a>1. 1. 1. Web 1. 0 时代</h2><p>Web 1. 0 的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p><h2 id="1-1-2-Web-2-0-时代"><a href="#1-1-2-Web-2-0-时代" class="headerlink" title="1. 1. 2. Web 2. 0 时代"></a>1. 1. 2. Web 2. 0 时代</h2><p>随着 Web 2. 0 的时代的到来，用户访问量大幅度提升，同时产生了大量的用户<br>数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p><h4 id="1-1-3-解决-CPU-及内存压力"><a href="#1-1-3-解决-CPU-及内存压力" class="headerlink" title="1. 1. 3. 解决 CPU 及内存压力"></a>1. 1. 3. 解决 CPU 及内存压力</h4><h4 id="1-1-4-解决-IO-压力"><a href="#1-1-4-解决-IO-压力" class="headerlink" title="1. 1. 4. 解决 IO 压力"></a>1. 1. 4. 解决 IO 压力</h4><h4 id="1-2-NoSQL-数据库"><a href="#1-2-NoSQL-数据库" class="headerlink" title="1. 2 .NoSQL 数据库"></a>1. 2 .NoSQL 数据库</h4><h4 id="1-2-1-NoSQL-数据库概述"><a href="#1-2-1-NoSQL-数据库概述" class="headerlink" title="1. 2. 1. NoSQL 数据库概述"></a>1. 2. 1. NoSQL 数据库概述</h4><p>NoSQL(NoSQL&#x3D; <strong>NotOnlySQL</strong> )，意即“不仅仅是 SQL”，泛指非关系型的数据库。</p><p>NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加<br>了数据库的扩展能力。</p><p> 不遵循SQL标准。</p><p> 不支持ACID。</p><p> 远超于SQL的性能。</p><h4 id="1-2-2-NoSQL-适用场景"><a href="#1-2-2-NoSQL-适用场景" class="headerlink" title="1. 2. 2. NoSQL 适用场景"></a>1. 2. 2. NoSQL 适用场景</h4><p> 对数据高并发的读写</p><p> 海量数据的读写</p><p> 对数据高可扩展性的</p><h4 id="1-2-3-NoSQL-不适用场景"><a href="#1-2-3-NoSQL-不适用场景" class="headerlink" title="1. 2. 3. NoSQL 不适用场景"></a>1. 2. 3. NoSQL 不适用场景</h4><p> 需要事务支持</p><p> 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p><p> （用不着 <strong>sql</strong> 的和用了 <strong>sql</strong> 也不行的情况，请考虑用 <strong>NoSql</strong> ）</p><h4 id="1-2-4-Memcache"><a href="#1-2-4-Memcache" class="headerlink" title="1. 2. 4. Memcache"></a>1. 2. 4. Memcache</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">很早出现的 NoSql数据库</span><br><span class="line">数据都在内存中，一般不持久化</span><br><span class="line">支持简单的 key-value模式，支持类型单一</span><br><span class="line">一般是作为缓存数据库辅助持久化的数据库</span><br></pre></td></tr></table></figure><h4 id="1-2-5-Redis"><a href="#1-2-5-Redis" class="headerlink" title="1. 2. 5. Redis"></a>1. 2. 5. Redis</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">几乎覆盖了 Memcached的绝大部分功能</span><br><span class="line">数据都在内存中，支持持久化，主要用作备份恢复</span><br><span class="line">除了支持简单的 key-value 模式，还支持多种数据结构的存储，比如list、set、hash、zset 等。</span><br><span class="line">一般是作为缓存数据库辅助持久化的数据库</span><br></pre></td></tr></table></figure><h4 id="1-2-6-MongoDB"><a href="#1-2-6-MongoDB" class="headerlink" title="1. 2. 6. MongoDB"></a>1. 2. 6. MongoDB</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高性能、开源、模式自由(schemafree)的文档型数据库</span><br><span class="line">数据都在内存中，如果内存不足，把不常用的数据保存到硬盘</span><br><span class="line">虽然是 key-value模式，但是对 value（尤其是 json）提供了丰富的查询功能</span><br><span class="line">支持二进制数据及大型对象</span><br><span class="line">可以根据数据的特点替代 RDBMS，成为独立的数据库。或者配合 RDBMS，存储特定的数据。</span><br></pre></td></tr></table></figure><h4 id="1-3-行式存储数据库（大数据时代）"><a href="#1-3-行式存储数据库（大数据时代）" class="headerlink" title="1. 3. 行式存储数据库（大数据时代）"></a>1. 3. 行式存储数据库（大数据时代）</h4><h4 id="1-3-1-行式数据库"><a href="#1-3-1-行式数据库" class="headerlink" title="1. 3. 1. 行式数据库"></a>1. 3. 1. 行式数据库</h4><h4 id="1-3-2-列式数据库"><a href="#1-3-2-列式数据库" class="headerlink" title="1. 3. 2. 列式数据库"></a>1. 3. 2. 列式数据库</h4><h5 id="1-3-2-1-Hbase"><a href="#1-3-2-1-Hbase" class="headerlink" title="1. 3. 2. 1 .Hbase"></a>1. 3. 2. 1 .Hbase</h5><p>HBase是 <strong>Hadoop</strong> 项目中的数据库。它用于需要对大量的数据进行随机、实时的读写<br>操作的场景中。</p><p>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过 <strong>10</strong> 亿行<br>数据，还可处理有数百万列元素的数据表。</p><h5 id="1-3-2-2-Cassandra-kəˈsaendrə"><a href="#1-3-2-2-Cassandra-kəˈsaendrə" class="headerlink" title="1. 3. 2. 2 .Cassandra[kəˈsændrə]"></a>1. 3. 2. 2 .Cassandra[kəˈsændrə]</h5><p>ApacheCassandra是一款免费的开源 NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集 <strong>(</strong> 数据量通常达到 <strong>PB</strong> 级别 <strong>)</strong> 。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p><p>计算机存储单位计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p><p>位bit(比特)(BinaryDigits)：存放一位二进制数，即 0 或 1 ，最小的存储单位。</p><p>字节byte： 8 个二进制位为一个字节(B)，最常用的单位。</p><p>1 KB(Kilobyte千字节)&#x3D; 1024 B，</p><p>1 MB(Megabyte兆字节简称“兆”)&#x3D; 1024 KB，</p><p>1 GB(Gigabyte吉字节又称“千兆”)&#x3D; 1024 MB，</p><p>1 TB(Trillionbyte万亿字节太字节)&#x3D; 1024 GB，其中 1024 &#x3D; 2 ^ 10 ( 2 的 10 次方)，</p><p>1 PB（Petabyte千万亿字节拍字节）&#x3D; 1024 TB，</p><p>1 EB（Exabyte百亿亿字节艾字节）&#x3D; 1024 PB，</p><p>1 ZB(Zettabyte十万亿亿字节泽字节)&#x3D; 1024 EB,</p><p>1 YB(Jottabyte一亿亿亿字节尧字节)&#x3D; 1024 ZB,</p><p>1 BB(Brontobyte一千亿亿亿字节)&#x3D; 1024 YB.</p><p>注：“兆”为百万级数量单位。</p><h4 id="1-4-图关系型数据库"><a href="#1-4-图关系型数据库" class="headerlink" title="1. 4. 图关系型数据库"></a>1. 4. 图关系型数据库</h4><p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n- 1 )&#x2F; 2 )</p><h4 id="1-5-DB-Engines-数据库排名"><a href="#1-5-DB-Engines-数据库排名" class="headerlink" title="1. 5 .DB-Engines 数据库排名"></a>1. 5 .DB-Engines 数据库排名</h4><p><a href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p><h2 id="2-Redis-概述安装"><a href="#2-Redis-概述安装" class="headerlink" title="2 .Redis 概述安装"></a>2 .Redis 概述安装</h2><p> Redis是一个开源的key-value存储系统。</p><p> 和Memcached类似，它支持存储的 value类型相对更多，包括string(字符串)、<br>list(链表)、set(集合)、zset(sortedset–有序集合)和 hash（哈希类型）。</p><p> 这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，<br>而且这些操作都是原子性的。</p><p> 在此基础上，Redis支持各种不同方式的排序。</p><p> 与memcached一样，为了保证效率，数据都是缓存在内存中。</p><p> 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记<br>录文件。</p><p> 并且在此基础上实现了 master-slave(主从)同步。</p><h4 id="2-1-应用场景"><a href="#2-1-应用场景" class="headerlink" title="2. 1. 应用场景"></a>2. 1. 应用场景</h4><h4 id="2-1-1-配合关系型数据库做高速缓存"><a href="#2-1-1-配合关系型数据库做高速缓存" class="headerlink" title="2. 1. 1. 配合关系型数据库做高速缓存"></a>2. 1. 1. 配合关系型数据库做高速缓存</h4><p> 高频次，热门访问的数据，降低数据库IO</p><p> 分布式架构，做session共享</p><h4 id="2-1-2-多样的数据结构存储持久化数据"><a href="#2-1-2-多样的数据结构存储持久化数据" class="headerlink" title="2. 1. 2. 多样的数据结构存储持久化数据"></a>2. 1. 2. 多样的数据结构存储持久化数据</h4><h4 id="2-2-Redis-安装"><a href="#2-2-Redis-安装" class="headerlink" title="2. 2 .Redis 安装"></a>2. 2 .Redis 安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis官方网站 Redis中文官方网站</span><br><span class="line">http://redis.io http://redis.cn/</span><br></pre></td></tr></table></figure><h4 id="2-2-1-安装版本"><a href="#2-2-1-安装版本" class="headerlink" title="2. 2. 1. 安装版本"></a>2. 2. 1. 安装版本</h4><p> 6. 2. 1 forLinux（redis- 6. 2. 1 .tar.gz）</p><p> 不用考虑在windows环境下对Redis的支持</p><h4 id="2-2-2-安装步骤"><a href="#2-2-2-安装步骤" class="headerlink" title="2. 2. 2. 安装步骤"></a>2. 2. 2. 安装步骤</h4><h4 id="2-2-2-1-准备工作：下载安装最新版的-gcc-编译器"><a href="#2-2-2-1-准备工作：下载安装最新版的-gcc-编译器" class="headerlink" title="2. 2. 2. 1. 准备工作：下载安装最新版的 gcc 编译器"></a>2. 2. 2. 1. 准备工作：下载安装最新版的 gcc 编译器</h4><p>安装C语言的编译环境</p><h6 id="yuminstallcentos-release-sclscl-utils-build"><a href="#yuminstallcentos-release-sclscl-utils-build" class="headerlink" title="yuminstallcentos-release-sclscl-utils-build"></a>yuminstallcentos-release-sclscl-utils-build</h6><p>yuminstall-ydevtoolset- 8 - toolchain</p><p>sclenabledevtoolset- 8 bash</p><p>测试gcc版本</p><p>gcc–version</p><h4 id="2-2-2-2-下载-redis-6-2-1-tar-gz-放-opt-目录"><a href="#2-2-2-2-下载-redis-6-2-1-tar-gz-放-opt-目录" class="headerlink" title="2. 2. 2. 2. 下载 redis- 6. 2. 1 .tar.gz 放&#x2F;opt 目录"></a>2. 2. 2. 2. 下载 redis- 6. 2. 1 .tar.gz 放&#x2F;opt 目录</h4><h4 id="2-2-2-3-解压命令：tar-zxvfredis-6-2-1-tar-gz"><a href="#2-2-2-3-解压命令：tar-zxvfredis-6-2-1-tar-gz" class="headerlink" title="2. 2. 2. 3. 解压命令：tar-zxvfredis- 6. 2. 1 .tar.gz"></a>2. 2. 2. 3. 解压命令：tar-zxvfredis- 6. 2. 1 .tar.gz</h4><h4 id="2-2-2-4-解压完成后进入目录：cdredis-6-2-1"><a href="#2-2-2-4-解压完成后进入目录：cdredis-6-2-1" class="headerlink" title="2. 2. 2. 4. 解压完成后进入目录：cdredis- 6. 2. 1"></a>2. 2. 2. 4. 解压完成后进入目录：cdredis- 6. 2. 1</h4><h4 id="2-2-2-5-在-redis-6-2-1-目录下再次执行-make-命令（只"><a href="#2-2-2-5-在-redis-6-2-1-目录下再次执行-make-命令（只" class="headerlink" title="2. 2. 2. 5. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只"></a>2. 2. 2. 5. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只</h4><h4 id="是编译好）"><a href="#是编译好）" class="headerlink" title="是编译好）"></a>是编译好）</h4><h4 id="2-2-2-6-如果没有准备好-C-语言编译环境，make-会报"><a href="#2-2-2-6-如果没有准备好-C-语言编译环境，make-会报" class="headerlink" title="2. 2. 2. 6. 如果没有准备好 C 语言编译环境，make 会报"></a>2. 2. 2. 6. 如果没有准备好 C 语言编译环境，make 会报</h4><h4 id="错—Jemalloc-jemalloc-h：没有那个文件"><a href="#错—Jemalloc-jemalloc-h：没有那个文件" class="headerlink" title="错—Jemalloc&#x2F;jemalloc.h：没有那个文件"></a>错—Jemalloc&#x2F;jemalloc.h：没有那个文件</h4><h4 id="2-2-2-7-解决方案：运行-makedistclean"><a href="#2-2-2-7-解决方案：运行-makedistclean" class="headerlink" title="2. 2. 2. 7. 解决方案：运行 makedistclean"></a>2. 2. 2. 7. 解决方案：运行 makedistclean</h4><h4 id="2-2-2-8-在-redis-6-2-1-目录下再次执行-make-命令（只"><a href="#2-2-2-8-在-redis-6-2-1-目录下再次执行-make-命令（只" class="headerlink" title="2. 2. 2. 8. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只"></a>2. 2. 2. 8. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只</h4><h4 id="是编译好）-1"><a href="#是编译好）-1" class="headerlink" title="是编译好）"></a>是编译好）</h4><h4 id="2-2-2-9-跳过-maketest继续执行-makeinstall"><a href="#2-2-2-9-跳过-maketest继续执行-makeinstall" class="headerlink" title="2. 2. 2. 9. 跳过 maketest继续执行:makeinstall"></a>2. 2. 2. 9. 跳过 maketest继续执行:makeinstall</h4><h4 id="2-2-3-安装目录：-usr-local-bin"><a href="#2-2-3-安装目录：-usr-local-bin" class="headerlink" title="2. 2. 3. 安装目录：&#x2F;usr&#x2F;local&#x2F;bin"></a>2. 2. 3. 安装目录：&#x2F;usr&#x2F;local&#x2F;bin</h4><p>查看默认安装目录：</p><p>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</p><p>redis-check-aof：修复有问题的AOF文件，rdb和 aof后面讲</p><p>redis-check-dump：修复有问题的dump.rdb文件</p><p>redis-sentinel：Redis集群使用</p><p>redis-server：Redis服务器启动命令</p><p>redis-cli：客户端，操作入口</p><h4 id="2-2-4-前台启动（不推荐）"><a href="#2-2-4-前台启动（不推荐）" class="headerlink" title="2. 2. 4. 前台启动（不推荐）"></a>2. 2. 4. 前台启动（不推荐）</h4><p>前台启动，命令行窗口不能关闭，否则服务器停止</p><h4 id="2-2-5-后台启动（推荐）"><a href="#2-2-5-后台启动（推荐）" class="headerlink" title="2. 2. 5. 后台启动（推荐）"></a>2. 2. 5. 后台启动（推荐）</h4><h5 id="2-2-5-1-备份-redis-conf"><a href="#2-2-5-1-备份-redis-conf" class="headerlink" title="2. 2. 5. 1. 备份 redis.conf"></a>2. 2. 5. 1. 备份 redis.conf</h5><p>拷贝一份redis.conf到其他目录</p><p>cp &#x2F;opt&#x2F;redis- 3. 2. 5 &#x2F;redis.conf &#x2F;myredis</p><h5 id="2-2-5-2-后台启动设置-daemonizeno-改成-yes"><a href="#2-2-5-2-后台启动设置-daemonizeno-改成-yes" class="headerlink" title="2. 2. 5. 2. 后台启动设置 daemonizeno 改成 yes"></a>2. 2. 5. 2. 后台启动设置 daemonizeno 改成 yes</h5><p>修改redis.conf( 128 行)文件将里面的daemonizeno改成yes，让服务在后台启动</p><h5 id="2-2-5-3-Redis-启动"><a href="#2-2-5-3-Redis-启动" class="headerlink" title="2. 2. 5. 3 .Redis 启动"></a>2. 2. 5. 3 .Redis 启动</h5><p>redis-server&#x2F;myredis&#x2F;redis.conf</p><h5 id="2-2-5-4-用客户端访问：-redis-cli"><a href="#2-2-5-4-用客户端访问：-redis-cli" class="headerlink" title="2. 2. 5. 4. 用客户端访问： redis-cli"></a>2. 2. 5. 4. 用客户端访问： redis-cli</h5><h5 id="2-2-5-5-多个端口可以：-redis-cli-p-6379"><a href="#2-2-5-5-多个端口可以：-redis-cli-p-6379" class="headerlink" title="2. 2. 5. 5. 多个端口可以： redis-cli-p 6379"></a>2. 2. 5. 5. 多个端口可以： redis-cli-p 6379</h5><h5 id="2-2-5-6-测试验证：-ping"><a href="#2-2-5-6-测试验证：-ping" class="headerlink" title="2. 2. 5. 6. 测试验证： ping"></a>2. 2. 5. 6. 测试验证： ping</h5><h5 id="2-2-5-7-Redis-关闭"><a href="#2-2-5-7-Redis-关闭" class="headerlink" title="2. 2. 5. 7 .Redis 关闭"></a>2. 2. 5. 7 .Redis 关闭</h5><p>单实例关闭：redis-clishutdown</p><p>也可以进入终端后再关闭</p><p>多实例关闭，指定端口关闭：redis-cli-p 6379 shutdown</p><h4 id="2-2-6-Redis-介绍相关知识"><a href="#2-2-6-Redis-介绍相关知识" class="headerlink" title="2. 2. 6. Redis 介绍相关知识"></a>2. 2. 6. Redis 介绍相关知识</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">端口 6379 从何而来</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alessia Merz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认 16 个数据库，类似数组下标从 0 开始，初始默认使</span><br><span class="line">用 0 号库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用命令select &lt;dbid&gt;来切换数据库。如:select 8</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">统一密码管理，所有库同样密码。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbsize查看当前数据库的key的数量</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushdb清空当前库</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushall通杀全部库</span><br></pre></td></tr></table></figure><p>Redis是单线程+多路IO复用技术</p><p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用<br>select和 poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则<br>阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启<br>动线程执行（比如使用线程池）</p><p>串行 vs 多线程+锁（memcached）vs 单线程+多路IO复用(Redis)</p><p>（与Memcache三点不同:支持多数据类型，支持持久化，单线程+多路IO复用）</p><h2 id="3-常用五大数据类型"><a href="#3-常用五大数据类型" class="headerlink" title="3. 常用五大数据类型"></a>3. 常用五大数据类型</h2><p>哪里去获得redis常见数据类型操作命令 <a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p><h3 id="3-1-Redis-键-key"><a href="#3-1-Redis-键-key" class="headerlink" title="3. 1 .Redis 键 (key)"></a>3. 1 .Redis 键 (key)</h3><p>keys<em>查看当前库所有 key (匹配：keys</em> 1 )</p><p>existskey判断某个key是否存在</p><p>typekey查看你的key是什么类型</p><p>delkey 删除指定的key数据</p><p>unlinkkey 根据value选择非阻塞删除</p><p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p><p>expirekey^1010 秒钟：为给定的key设置过期时间</p><p>ttlkey查看还有多少秒过期，- 1 表示永不过期，- 2 表示已过期</p><p>select命令切换数据库</p><p>dbsize查看当前数据库的key的数量</p><p>flushdb清空当前库</p><p>flushall通杀全部库</p><h4 id="3-2-Redis-字符串-String"><a href="#3-2-Redis-字符串-String" class="headerlink" title="3. 2 .Redis 字符串 (String)"></a>3. 2 .Redis 字符串 (String)</h4><h4 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3. 2. 1. 简介"></a>3. 2. 1. 简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个<br>key对应一个value。</p><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图<br>片或者序列化的对象。</p><p>String类型是Redis最基本的数据类型，一个Redis中字符串 value最多可以是 512 M</p><h4 id="3-2-2-常用命令"><a href="#3-2-2-常用命令" class="headerlink" title="3. 2. 2. 常用命令"></a>3. 2. 2. 常用命令</h4><p>set <key><value>添加键值对</value></key></p><p>*NX：当数据库中 key不存在时，可以将key-value添加数据库</p><p>*XX：当数据库中key存在时，可以将key-value添加数据库，与 NX参数互斥</p><p>*EX：key的超时秒数</p><p>*PX：key的超时毫秒数，与EX互斥</p><p>get <key>查询对应键值</key></p><p>append <key><value>将给定的<value>追加到原值的末尾</value></value></key></p><p>strlen <key>获得值的长度</key></p><p>setnx <key><value>只有在key不存在时 设置key的值</value></key></p><p>incr <key></key></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将key中储存的数字值增 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只能对数字值操作，如果为空，新增值为 1</span><br></pre></td></tr></table></figure><p>decr <key></key></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将key中储存的数字值减 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只能对数字值操作，如果为空，新增值为- 1</span><br></pre></td></tr></table></figure><p>incrby&#x2F;decrby <key>&lt;步长&gt;将key中储存的数字值增减。自定义步长。</key></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原子性</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所谓原子操作是指不会被线程调度机制打断的操作；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种操作一旦开始，就一直运行到结束，中间不会有任何contextswitch（切换到另</span><br><span class="line">一个线程）。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（ 1 ）在单线程中，能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中</span><br><span class="line">断只能发生于指令之间。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（ 2 ）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis单命令的原子性主要得益于Redis的单线程。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java中的i++是否是原子操作？不是</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 0 ;两个线程分别对i进行++ 100 次,值是多少？ 2 ~ 200</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 0</span><br><span class="line">i++</span><br><span class="line">i= 99</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i++</span><br><span class="line">i= 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i++</span><br><span class="line">i= 1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i++</span><br><span class="line">i= 100</span><br></pre></td></tr></table></figure><p>mset &lt;key 1 &gt;&lt;value 1 &gt;&lt;key 2 &gt;&lt;value 2 &gt; …..</p><p>同时设置一个或多个key-value对</p><p>mget &lt;key 1 &gt;&lt;key 2 &gt;&lt;key 3 &gt;…..</p><p>同时获取一个或多个value</p><p>msetnx&lt;key 1 &gt;&lt;value 1 &gt;&lt;key 2 &gt;&lt;value 2 &gt; …..</p><p>同时设置一个或多个key-value对，当且仅当所有给定key都不存在。</p><p>原子性，有一个失败则都失败</p><p>getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;</key></p><p>获得值的范围，类似java中的substring，前包，后包</p><p>setrange <key>&lt;起始位置&gt;<value></value></key></p><p>用<value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从 <strong>0</strong> 开始)。</key></value></p><p><strong>setex <key>&lt;** 过期时间 **&gt;<value></value></key></strong></p><p>设置键值的同时，设置过期时间，单位秒。</p><p>getset<key><value></value></key></p><p>以新换旧，设置了新值同时获得旧值。</p><h4 id="3-2-3-数据结构"><a href="#3-2-3-数据结构" class="headerlink" title="3. 2. 3. 数据结构"></a>3. 2. 3. 数据结构</h4><p>String的数据结构为简单动态字符串(SimpleDynamicString,缩写 SDS)。是可以<br>修改的字符串，内部结构实现上类似于Java的 ArrayList，采用预分配冗余空间的方<br>式来减少内存的频繁分配.</p><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度<br>len。当字符串长度小于 1 M时，扩容都是加倍现有的空间，如果超过 1 M，扩容时一<br>次只会多扩 1 M的空间。需要注意的是字符串最大长度为 512 M。</p><h4 id="3-3-Redis-列表-List"><a href="#3-3-Redis-列表-List" class="headerlink" title="3. 3 .Redis 列表 (List)"></a>3. 3 .Redis 列表 (List)</h4><h4 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3. 3. 1. 简介"></a>3. 3. 1. 简介</h4><p>单键多值</p><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头<br>部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节<br>点性能会较差。</p><h4 id="3-3-2-常用命令"><a href="#3-3-2-常用命令" class="headerlink" title="3. 3. 2. 常用命令"></a>3. 3. 2. 常用命令</h4><p>lpush&#x2F;rpush <key>&lt;value 1 &gt;&lt;value 2 &gt;&lt;value 3 &gt;….从左边&#x2F;右边插入一个或多个值。</key></p><p>lpop&#x2F;rpop <key>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</key></p><p>rpoplpush &lt;key 1 &gt;&lt;key 2 &gt;从&lt;key 1 &gt;列表右边吐出一个值，插到&lt;key 2 &gt;列表左边。</p><p>lrange<key><start><stop></stop></start></key></p><p>按照索引下标获得元素(从左到右)</p><p>lrangemylist 0 - 1 0 左边第一个，- 1 右边第一个，（ 0 - 1 表示获取所有）</p><p>lindex<key><index>按照索引下标获得元素(从左到右)</index></key></p><p>llen<key>获得列表长度</key></p><p>linsert<key> before<value><newvalue>在<value>的后面插入<newvalue>插入值</newvalue></value></newvalue></value></key></p><p>lrem<key><n><value>从左边删除 n个 value(从左到右)</value></n></key></p><p>lset<key><index><value>将列表 key下标为index的值替换成value</value></index></key></p><h4 id="3-3-3-数据结构"><a href="#3-3-3-数据结构" class="headerlink" title="3. 3. 3. 数据结构"></a>3. 3. 3. 数据结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List的数据结构为快速链表quickList。</span><br></pre></td></tr></table></figure><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即<br>是压缩列表。</p><p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p><p>当数据量比较多的时候才会改成quicklist。</p><p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只<br>是int类型的数据，结构上还需要两个额外的指针 prev和 next。</p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个 ziplist使用双向<br>指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h4 id="3-4-Redis-集合-Set"><a href="#3-4-Redis-集合-Set" class="headerlink" title="3. 4 .Redis 集合 (Set)"></a>3. 4 .Redis 集合 (Set)</h4><h4 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3. 4. 1. 简介"></a>3. 4. 1. 简介</h4><p>Redisset对外提供的功能与 list类似是一个列表的功能，特殊之处在于 set是可以自<br>动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的<br>选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list<br>所不能提供的。</p><p>Redis的Set是 string类型的无序集合。它底层其实是一个value为 null的 hash表，<br>所以添加，删除，查找的复杂度都是 <strong>O( 1 )</strong> 。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O( 1 )，数据增加，查找数据的<br>时间不变</p><h4 id="3-4-2-常用命令"><a href="#3-4-2-常用命令" class="headerlink" title="3. 4. 2. 常用命令"></a>3. 4. 2. 常用命令</h4><p>sadd<key>&lt;value 1 &gt;&lt;value 2 &gt;…..</key></p><p>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略</p><p>smembers<key>取出该集合的所有值。</key></p><p>sismember<key><value>判断集合<key>是否为含有该<value>值，有 1 ，没有 0</value></key></value></key></p><p>scard<key>返回该集合的元素个数。</key></p><p>srem<key>&lt;value 1 &gt;&lt;value 2 &gt;….删除集合中的某个元素。</key></p><p>spop<key>随机从该集合中吐出一个值。</key></p><p>srandmember<key><n>随机从该集合中取出 n个值。不会从集合中删除。</n></key></p><p>smove<source><destination>value把集合中一个值从一个集合移动到另一个集合</destination></p><p>sinter&lt;key 1 &gt;&lt;key 2 &gt;返回两个集合的交集元素。</p><p>sunion&lt;key 1 &gt;&lt;key 2 &gt;返回两个集合的并集元素。</p><p>sdiff&lt;key 1 &gt;&lt;key 2 &gt;返回两个集合的差集元素(key 1 中的，不包含key 2 中的)</p><h4 id="3-4-3-数据结构"><a href="#3-4-3-数据结构" class="headerlink" title="3. 4. 3. 数据结构"></a>3. 4. 3. 数据结构</h4><p>Set数据结构是 dict字典，字典是用哈希表实现的。</p><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的 value都指向同一个对<br>象。Redis的 set结构也是一样，它的内部也使用hash结构，所有的value都指向同一<br>个内部值。</p><h4 id="3-5-Redis-哈希-Hash"><a href="#3-5-Redis-哈希-Hash" class="headerlink" title="3. 5 .Redis 哈希 (Hash)"></a>3. 5 .Redis 哈希 (Hash)</h4><h4 id="3-5-1-简介"><a href="#3-5-1-简介" class="headerlink" title="3. 5. 1. 简介"></a>3. 5. 1. 简介</h4><p>Redishash是一个键值对集合。</p><p>Redishash是一个string类型的field和value的映射表，hash特别适合用于存储对<br>象。</p><p>类似Java里面的 Map&lt;String,Object&gt;</p><p>用户ID为查找的 key，存储的value用户对象包含姓名，年龄，生日等信息，如果用<br>普通的key&#x2F;value结构来存储</p><p>主要有以下 2 种存储方式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次修改用户的某个属性需要，先反序列化</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户 ID数据冗余</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">改好后再序列化回去。开销较大。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过key(用户 ID)+field( 属性标签 ) 就可以操作对应属性数据了，既不需要重复存储数</span><br><span class="line">据，也不会带来序列化和并发修改控制的问题</span><br></pre></td></tr></table></figure><h4 id="3-5-2-常用命令"><a href="#3-5-2-常用命令" class="headerlink" title="3. 5. 2. 常用命令"></a>3. 5. 2. 常用命令</h4><p>hset<key><field><value>给<key>集合中的 <field>键赋值<value></value></field></key></value></field></key></p><p>hget&lt;key 1 &gt;<field>从&lt;key 1 &gt;集合<field>取出value</field></field></p><p>hmset&lt;key 1 &gt;&lt;field 1 &gt;&lt;value 1 &gt;&lt;field 2 &gt;&lt;value 2 &gt;…批量设置 hash 的值</p><p>hexists&lt;key 1 &gt;<field>查看哈希表key中，给定域field是否存在。</field></p><p>hkeys<key>列出该 hash 集合的所有field</key></p><p>hvals<key>列出该 hash集合的所有 value</key></p><p>hincrby<key><field><increment>为哈希表key中的域field的值加上增量 1 - 1</increment></field></key></p><p>hsetnx<key><field><value>将哈希表key中的域field的值设置为value，当且仅当域field不<br>存在.</value></field></key></p><h4 id="3-5-3-数据结构"><a href="#3-5-3-数据结构" class="headerlink" title="3. 5. 3. 数据结构"></a>3. 5. 3. 数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当<br>field-value长度较短且个数较少时，使用ziplist，否则使用 hashtable。</p><h4 id="3-6-Redis-有序集合-Zset-sortedset"><a href="#3-6-Redis-有序集合-Zset-sortedset" class="headerlink" title="3. 6 .Redis 有序集合 Zset(sortedset)"></a>3. 6 .Redis 有序集合 Zset(sortedset)</h4><h4 id="3-6-1-简介"><a href="#3-6-1-简介" class="headerlink" title="3. 6. 1. 简介"></a>3. 6. 1. 简介</h4><p>Redis有序集合zset与普通集合 set非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个评分（ <strong>score</strong> ）,这个评分（score）被用<br>来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分<br>可以是重复了。</p><p>因为元素是有序的,所以你也可以很快的根据评分（score）或者次序（position）来获<br>取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成<br>员的智能列表。</p><h4 id="3-6-2-常用命令"><a href="#3-6-2-常用命令" class="headerlink" title="3. 6. 2. 常用命令"></a>3. 6. 2. 常用命令</h4><p>zadd <key>&lt;score 1 &gt;&lt;value 1 &gt;&lt;score 2 &gt;&lt;value 2 &gt;…</key></p><p>将一个或多个member元素及其score值加入到有序集key当中。</p><p><strong>zrange<key><start><stop></stop>[WITHSCORES]</start></key></strong></p><p>返回有序集key中，下标在<start><stop></stop>之间的元素</start></p><p>带WITHSCORES，可以让分数一起和值返回到结果集。</p><p>zrangebyscorekeyminmax[withscores][limitoffsetcount]</p><p>返回有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。<br>有序集成员按score值递增(从小到大)次序排列。</p><p>zrevrangebyscorekeymaxmin[withscores][limitoffsetcount]</p><p>同上，改为从大到小排列。</p><p>zincrby<key><increment><value> 为元素的score加上增量</value></increment></key></p><p>zrem <key><value>删除该集合下，指定值的元素</value></key></p><p>zcount<key><min><max>统计该集合，分数区间内的元素个数</max></min></key></p><p>zrank<key><value>返回该值在集合中的排名，从 0 开始。</value></key></p><p>案例：如何利用zset实现一个文章访问量的排行榜？</p><h4 id="3-6-3-数据结构"><a href="#3-6-3-数据结构" class="headerlink" title="3. 6. 3. 数据结构"></a>3. 6. 3. 数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于 Java的<br>数据结构Map&lt;String,Double&gt;，可以给每一个元素 value赋予一个权重 score，另一方<br>面它又类似于TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的<br>名次，还可以通过score的范围来获取元素的列表。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zset底层使用了两个数据结构</span><br></pre></td></tr></table></figure><p>（ 1 ）hash，hash的作用就是关联元素 value和权重 score，保障元素 value的唯<br>一性，可以通过元素value找到相应的score值。</p><p>（ 2 ）跳跃表，跳跃表的目的在于给元素value 排序，根据score的范围获取元素<br>列表。</p><h4 id="3-6-4-跳跃表（跳表）"><a href="#3-6-4-跳跃表（跳表）" class="headerlink" title="3. 6. 4. 跳跃表（跳表）"></a>3. 6. 4. 跳跃表（跳表）</h4><p>1 、简介</p><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名<br>等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、<br>删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis<br>采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><p>2 、实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对比有序链表和跳跃表，从链表中查询出 51</span><br></pre></td></tr></table></figure><p>（ 1 ） 有序链表</p><p>要查找值为 51 的元素，需要从第一个元素开始依次查找、比较才能找到。共<br>需要 6 次比较。</p><p>（ 2 ） 跳跃表</p><p>从第 2 层开始， 1 节点比 51 节点小，向后比较。</p><p>21 节点比 51 节点小，继续向后比较，后面就是 NULL了，所以从 21 节点向下到<br>第 1 层</p><p>在第 1 层， 41 节点比 51 节点小，继续向后， 61 节点比 51 节点大，所以从 41 向<br>下</p><p>在第 0 层， 51 节点为要查找的节点，节点被找到，共查找 4 次。</p><p>从此可以看出跳跃表比有序链表效率要高</p><h2 id="4-Redis-配置文件介绍"><a href="#4-Redis-配置文件介绍" class="headerlink" title="4. Redis 配置文件介绍"></a>4. Redis 配置文件介绍</h2><p>自定义目录：&#x2F;myredis&#x2F;redis.conf</p><h4 id="4-1-Units-单位"><a href="#4-1-Units-单位" class="headerlink" title="4. 1 .###Units 单位"></a>4. 1 .###Units 单位</h4><p>配置大小单位,开头定义了一些基本的度量单位，只支持 bytes，不支持bit</p><p>大小写不敏感</p><h4 id="4-2-INCLUDES-包含"><a href="#4-2-INCLUDES-包含" class="headerlink" title="4. 2 .###INCLUDES 包含"></a>4. 2 .###INCLUDES 包含</h4><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p><h4 id="4-3-网络相关配置"><a href="#4-3-网络相关配置" class="headerlink" title="4. 3 .### 网络相关配置"></a>4. 3 .### 网络相关配置</h4><h4 id="4-3-1-b-ind"><a href="#4-3-1-b-ind" class="headerlink" title="4. 3. 1. b ind"></a>4. 3. 1. b ind</h4><p>默认情况bind&#x3D; 127. 0. 0. 1 只能接受本机的访问请求</p><p>不写的情况下，无限制接受任何ip地址的访问</p><p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注<br>释掉</p><p>如果开启了protected-mode，那么在没有设定bindip且没有设密码的情况下，Redis<br>只允许接受本机的响应</p><p>保存配置，停止服务，重启启动查看进程，不再是本机访问了。</p><h4 id="4-3-2-p-rotected-mode"><a href="#4-3-2-p-rotected-mode" class="headerlink" title="4. 3. 2. p rotected- mode"></a>4. 3. 2. p rotected- mode</h4><p>将本机访问保护模式设置no</p><h4 id="4-3-3-P-ort"><a href="#4-3-3-P-ort" class="headerlink" title="4. 3. 3. P ort"></a>4. 3. 3. P ort</h4><p>端口号，默认 6379</p><h4 id="4-3-4-t-cp-backlog"><a href="#4-3-4-t-cp-backlog" class="headerlink" title="4. 3. 4. t cp-backlog"></a>4. 3. 4. t cp-backlog</h4><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握<br>手队列+已经完成三次握手队列。</p><p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p><p>注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值（ 128 ），所以需要<br>确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv 4 &#x2F;tcp_max_syn_backlog（ 128 ）<br>两个值来达到想要的效果</p><h4 id="4-3-5-t-imeout"><a href="#4-3-5-t-imeout" class="headerlink" title="4. 3. 5. t imeout"></a>4. 3. 5. t imeout</h4><p>一个空闲的客户端维持多少秒会关闭， 0 表示关闭该功能。即永不关闭。</p><h4 id="4-3-6-t-cp-keepalive"><a href="#4-3-6-t-cp-keepalive" class="headerlink" title="4. 3. 6. t cp-keepalive"></a>4. 3. 6. t cp-keepalive</h4><p>对访问客户端的一种心跳检测，每个n秒检测一次。</p><p>单位为秒，如果设置为 0 ，则不会进行 Keepalive检测，建议设置成 60</p><h4 id="4-4-GENERAL-通用"><a href="#4-4-GENERAL-通用" class="headerlink" title="4. 4 .###GENERAL 通用"></a>4. 4 .###GENERAL 通用</h4><h4 id="4-4-1-daemonize"><a href="#4-4-1-daemonize" class="headerlink" title="4. 4. 1. daemonize"></a>4. 4. 1. daemonize</h4><p>是否为后台进程，设置为yes</p><p>守护进程，后台启动</p><h4 id="4-4-2-pidfile"><a href="#4-4-2-pidfile" class="headerlink" title="4. 4. 2. pidfile"></a>4. 4. 2. pidfile</h4><p>存放pid文件的位置，每个实例会产生一个不同的 pid文件</p><h4 id="4-4-3-loglevel"><a href="#4-4-3-loglevel" class="headerlink" title="4. 4. 3. loglevel"></a>4. 4. 3. loglevel</h4><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默<br>认为 <strong>notice</strong></p><p>四个级别根据使用阶段来选择，生产环境选择notice或者warning</p><h4 id="4-4-4-logfile"><a href="#4-4-4-logfile" class="headerlink" title="4. 4. 4. logfile"></a>4. 4. 4. logfile</h4><p>日志文件名称</p><h4 id="4-4-5-d-atabases-16"><a href="#4-4-5-d-atabases-16" class="headerlink" title="4. 4. 5. d atabases 16"></a>4. 4. 5. d atabases 16</h4><p>设定库的数量默认 16 ，默认数据库为 0 ，可以使用 SELECT<dbid>命令在连接上指<br>定数据库id</dbid></p><h4 id="4-5-SECURITY-安全"><a href="#4-5-SECURITY-安全" class="headerlink" title="4. 5 .###SECURITY 安全"></a>4. 5 .###SECURITY 安全</h4><h4 id="4-5-1-设置密码"><a href="#4-5-1-设置密码" class="headerlink" title="4. 5. 1. 设置密码"></a>4. 5. 1. 设置密码</h4><p>访问密码的查看、设置和取消</p><p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p><p>永久设置，需要再配置文件中进行设置。</p><h4 id="4-6-LIMITS-限制"><a href="#4-6-LIMITS-限制" class="headerlink" title="4. 6 .####LIMITS 限制"></a>4. 6 .####LIMITS 限制</h4><h4 id="4-6-1-m-axclients"><a href="#4-6-1-m-axclients" class="headerlink" title="4. 6. 1. m axclients"></a>4. 6. 1. m axclients</h4><p> 设置redis同时可以与多少个客户端进行连接。</p><p> 默认情况下为 10000 个客户端。</p><p> 如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出<br>“maxnumberofclientsreached”以作回应。</p><h4 id="4-6-2-m-axmemory"><a href="#4-6-2-m-axmemory" class="headerlink" title="4. 6. 2. m axmemory"></a>4. 6. 2. m axmemory</h4><p> 建议必须设置，否则，将内存占满，造成服务器宕机</p><p> 设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部<br>数据，移除规则可以通过maxmemory-policy来指定。</p><p> 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，<br>那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH<br>等。</p><p> 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是<br>主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统<br>中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，<br>才不用考虑这个因素。</p><h4 id="4-6-3-m-axmemory-policy"><a href="#4-6-3-m-axmemory-policy" class="headerlink" title="4. 6. 3. m axmemory-policy"></a>4. 6. 3. m axmemory-policy</h4><p> volatile-lru：使用LRU算法移除 key，只对设置了过期时间的键；（最近最少使<br>用）</p><p> allkeys-lru：在所有集合key中，使用LRU算法移除 key</p><p> volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</p><p> allkeys-random：在所有集合key中，移除随机的 key</p><p> volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的 key</p><p> noeviction：不进行移除。针对写操作，只是返回错误信息</p><h4 id="4-6-4-m-axmemory-samples"><a href="#4-6-4-m-axmemory-samples" class="headerlink" title="4. 6. 4. m axmemory-samples"></a>4. 6. 4. m axmemory-samples</h4><p> 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所<br>以你可以设置样本的大小，redis默认会检查这么多个 key并选择其中LRU的那<br>个。</p><p> 一般设置 3 到^7 的数字，数值越小样本越不准确，但性能消耗越小。</p><h2 id="5-Redis-的发布和订阅"><a href="#5-Redis-的发布和订阅" class="headerlink" title="5. Redis 的发布和订阅"></a>5. Redis 的发布和订阅</h2><h4 id="5-1-什么是发布和订阅"><a href="#5-1-什么是发布和订阅" class="headerlink" title="5. 1. 什么是发布和订阅"></a>5. 1. 什么是发布和订阅</h4><p>Redis发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者<br>(sub)接收消息。</p><p>Redis客户端可以订阅任意数量的频道。</p><h4 id="5-2-Redis-的发布和订阅"><a href="#5-2-Redis-的发布和订阅" class="headerlink" title="5. 2 .Redis 的发布和订阅"></a>5. 2 .Redis 的发布和订阅</h4><p>1 、客户端可以订阅频道如下图</p><p>2 、当给这个频道发布消息后，消息就会发送给订阅的客户端</p><h4 id="5-3-发布订阅命令行实现"><a href="#5-3-发布订阅命令行实现" class="headerlink" title="5. 3. 发布订阅命令行实现"></a>5. 3. 发布订阅命令行实现</h4><p>1 、打开一个客户端订阅channel 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBSCRIBEchannel 1</span><br></pre></td></tr></table></figure><p>2 、打开另一个客户端，给channel 1 发布消息hello</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publishchannel 1 hello</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回的 1 是订阅者数量</span><br></pre></td></tr></table></figure><p>3 、打开第一个客户端可以看到发送的消息</p><p>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布<br>的消息</p><h2 id="6-Redis-新数据类型"><a href="#6-Redis-新数据类型" class="headerlink" title="6. Redis 新数据类型"></a>6. Redis 新数据类型</h2><h4 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6. 1 .Bitmaps"></a>6. 1 .Bitmaps</h4><h4 id="6-1-1-简介"><a href="#6-1-1-简介" class="headerlink" title="6. 1. 1. 简介"></a>6. 1. 1. 简介</h4><p>现代计算机用二进制（位）作为信息的基础单位， 1 个字节等于 8 位，例如“abc”<br>字符串是由 3 个字节组成，但实际在计算机存储时将其用二进制表示，“abc”分别<br>对应的 ASCII码分别是 97 、 98 、 99 ，对应的二进制分别是 01100001 、 01100010<br>和 01100011 ，如下图</p><p>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：<br>（ 1 ） Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value），<br>但是它可以对字符串的位进行操作。<br>（ 2 ） Bitmaps单独提供了一套命令，所以在 Redis中使用 Bitmaps和使用<br>字符串的方法不太相同。可以把 Bitmaps想象成一个以位为单位的数<br>组，数组的每个单元只能存储 0 和 1 ，数组的下标在Bitmaps中叫做<br>偏移量。</p><h4 id="6-1-2-命令"><a href="#6-1-2-命令" class="headerlink" title="6. 1. 2. 命令"></a>6. 1. 2. 命令</h4><p>1 、setbit</p><p>（ 1 ）格式<br>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（ 0 或 1 ）</value></offset></key></p><p>*offset:偏移量从 0 开始</p><p>（ 2 ）实例<br>每个独立用户是否访问过网站存放在Bitmaps中，将访问的用户记做 1 ，没有<br>访问的用户记做 0 ，用偏移量作为用户的id。<br>设置键的第offset个位的值（从 0 算起），假设现在有 20 个用户，userid&#x3D; 1 ，<br>6 ， 11 ， 15 ， 19 的用户对网站进行了访问，那么当前 Bitmaps初始化结果如图</p><p>unique:users: 20201106 代表 2020 - 11 - 06 这天的独立访问用户的Bitmaps</p><p>注：<br>很多应用的用户 id以一个指定数字（例如 10000 ）开头，直接将用户 id和<br>Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做setbit操作时将<br>用户id减去这个指定数字。<br>在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会<br>比较慢，可能会造成 Redis的阻塞。</p><p>2 、getbit<br>（ 1 ）格式<br>getbit<key><offset>获取Bitmaps中某个偏移量的值</offset></key></p><p>获取键的第offset位的值（从 0 开始算）</p><p>（ 2 ）实例<br>获取id&#x3D; 8 的用户是否在 2020 - 11 - 06 这天访问过，返回 0 说明没有访问过：</p><p>注：因为 100 根本不存在，所以也是返回 0</p><p>3 、bitcount<br>统计字符串被设置为 1 的bit数。一般情况下，给定的整个字符串都会被进行计数，<br>通过指定额外的start或end参数，可以让计数只在特定的位上进行。start和end参<br>数的设置，都可以使用负数值：比如- 1 表示最后一个位，而- 2 表示倒数第二个位，<br>start、end是指 bit组的字节的下标数，二者皆包含。</p><p>（ 1 ）格式<br>bitcount<key>[startend]统计字符串从 start字节到 end字节比特值为 1 的数量</key></p><p>（ 2 ）实例<br>计算 2022 - 11 - 06 这天的独立访问用户数量</p><p>start和end代表起始和结束字节数，下面操作计算用户 id在第 1 个字节到第 3 个<br>字节之间的独立访问用户数，对应的用户 id是 11 ， 15 ， 19 。</p><p>举例：K 1 【 0100000101000000 0000000000100001 】，对应【 0 ， 1 ， 2 ， 3 】<br>bitcountK 112 ：统计下标 1 、 2 字节组中 bit&#x3D; 1 的个数，即 01000000 00000000</p><ul><li>-》bitcountK 112 - -》 1</li></ul><p>bitcountK 113 ：统计下标 1 、 2 字节组中 bit&#x3D; 1 的个数，即 01000000 00000000<br>00100001</p><ul><li>-》bitcountK 113 - -》 3</li></ul><p>bitcountK 10 - 2 ： 统计下标 0 到下标倒数第 2 ，字节组中 bit&#x3D; 1 的个数，即<br>01000001 01000000 00000000</p><ul><li>-》bitcountK 10 - 2 - -》 3</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</span><br></pre></td></tr></table></figure><p>4 、bitop<br>( 1 )格式<br>bitop and(or&#x2F;not&#x2F;xor)<destkey>[key…]</destkey></p><p>bitop是一个复合操作，它可以做多个Bitmaps的and（交集）、or（并集）、not<br>（非）、xor（异或）操作并将结果保存在destkey中。</p><p>( 2 )实例<br>2020 - 11 - 04 日访问网站的 userid&#x3D; 1 , 2 , 5 , 9 。<br>setbitunique:users: 2020110411<br>setbitunique:users: 2020110421<br>setbitunique:users: 2020110451<br>setbitunique:users: 2020110491</p><p>2020 - 11 - 03 日访问网站的 userid&#x3D; 0 , 1 , 4 , 9 。<br>setbitunique:users: 2020110301<br>setbitunique:users: 2020110311<br>setbitunique:users: 2020110341<br>setbitunique:users: 2020110391</p><p>计算出两天都访问过网站的用户数量<br>bitopandunique:users:and: 20201104 _ 03<br>unique:users: 20201103 unique:users: 20201104</p><p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种），可以使用<br>or求并集</p><h4 id="6-1-3-Bitmaps-与-set-对比"><a href="#6-1-3-Bitmaps-与-set-对比" class="headerlink" title="6. 1. 3. Bitmaps 与 set 对比"></a>6. 1. 3. Bitmaps 与 set 对比</h4><p>假设网站有 1 亿用户，每天独立访问的用户有 5 千万，如果每天用集合类型和<br>Bitmaps分别存储活跃用户可以得到表</p><h4 id="set和Bitmaps存储一天活跃用户对比"><a href="#set和Bitmaps存储一天活跃用户对比" class="headerlink" title="set和Bitmaps存储一天活跃用户对比"></a>set和Bitmaps存储一天活跃用户对比</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据</span><br><span class="line">类型 每个用户id占用空间 需要存储的用户量 全部内存量</span><br><span class="line">集合</span><br><span class="line">类型^64 位^5000000064 位*^50000000 =^400 MB</span><br><span class="line">Bitmaps 1 位 100000000 1 位* 100000000 = 12. 5 MB</span><br></pre></td></tr></table></figure><p>很明显，这种情况下使用Bitmaps能节省很多的内存空间，尤其是随着时间推<br>移节省的内存还是非常可观的</p><h4 id="set和Bitmaps存储独立用户空间对比"><a href="#set和Bitmaps存储独立用户空间对比" class="headerlink" title="set和Bitmaps存储独立用户空间对比"></a>set和Bitmaps存储独立用户空间对比</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型 一天 一个月 一年</span><br><span class="line">集合类型^400 MB^12 GB^144 GB</span><br><span class="line">Bitmaps 12. 5 MB 375 MB 4. 5 GB</span><br></pre></td></tr></table></figure><p>但 Bitmaps并不是万金油，假如该网站每天的独立访问用户很少，例如只有<br>10 万（大量的僵尸用户），那么两者的对比如下表所示，很显然，这时候使用<br>Bitmaps就不太合适了，因为基本上大部分位都是 0 。</p><h4 id="set和Bitmaps存储一天活跃用户对比（独立用户比较少）"><a href="#set和Bitmaps存储一天活跃用户对比（独立用户比较少）" class="headerlink" title="set和Bitmaps存储一天活跃用户对比（独立用户比较少）"></a>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类</span><br><span class="line">型 每个userid占用空间 需要存储的用户量 全部内存量</span><br><span class="line">集合类</span><br><span class="line">型^64 位^10000064 位*^100000 =^800 KB</span><br><span class="line">Bitmaps 1 位 100000000 1 位* 100000000 = 12. 5 MB</span><br></pre></td></tr></table></figure><h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6. 2 .HyperLogLog"></a>6. 2 .HyperLogLog</h3><h4 id="6-2-1-简介"><a href="#6-2-1-简介" class="headerlink" title="6. 2. 1. 简介"></a>6. 2. 1. 简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV<br>（PageView页面访问量）,可以使用 Redis的 incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立 IP数、搜索记录数等需要去重和<br>计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：<br>（ 1 ）数据存储在 MySQL表中，使用distinctcount计算不重复个数</p><p>（ 2 ）使用 Redis提供的 hash、set、bitmaps等数据结构来处理<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非<br>常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog<br>RedisHyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输<br>入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小<br>的。<br>在Redis里面，每个HyperLogLog键只需要花费 12 KB内存，就可以计算接<br>近 2 ^ 64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成<br>鲜明对比。<br>但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素<br>本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p><p>什么是基数?<br>比如数据集{ 1 , 3 , 5 , 7 , 5 , 7 , 8 }，那么这个数据集的基数集为{ 1 , 3 , 5 , 7 , 8 },<br>基数(不重复元素)为 5 。基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id="6-2-2-命令"><a href="#6-2-2-命令" class="headerlink" title="6. 2. 2. 命令"></a>6. 2. 2. 命令</h4><p>1 、pfadd<br>（ 1 ）格式<br>pfadd<key><element>[element…] 添加指定元素到HyperLogLog中</element></key></p><p>（ 2 ）实例</p><p>将所有元素添加到指定 HyperLogLog数据结构中。如果执行命令后 HLL估计<br>的近似基数发生变化，则返回 1 ，否则返回 0 。</p><p>2 、pfcount<br>（ 1 ）格式<br>pfcount<key>[key…]计算 HLL的近似基数，可以计算多个HLL，比如用 HLL存储<br>每天的UV，计算一周的 UV可以使用 7 天的UV合并计算即可</key></p><p>（ 2 ）实例</p><p>3 、pfmerge<br>（ 1 ）格式<br>pfmerge<destkey><sourcekey>[sourcekey…] 将一个或多个 HLL合并后的结果存<br>储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</sourcekey></destkey></p><p>（ 2 ）实例</p><h4 id="6-3-Geospatial"><a href="#6-3-Geospatial" class="headerlink" title="6. 3 .Geospatial"></a>6. 3 .Geospatial</h4><h4 id="6-3-1-简介"><a href="#6-3-1-简介" class="headerlink" title="6. 3. 1. 简介"></a>6. 3. 1. 简介</h4><p>Redis 3. 2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。<br>该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬<br>度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h4 id="6-3-2-命令"><a href="#6-3-2-命令" class="headerlink" title="6. 3. 2. 命令"></a>6. 3. 2. 命令</h4><p>1 、geoadd</p><p>（ 1 ）格式<br>geoadd<key><longitude><latitude><member>[longitudelatitudemember…] 添<br>加地理位置（经度，纬度，名称）</member></latitude></longitude></key></p><p>（ 2 ）实例<br>geoaddchina:city 121. 4731. 23 shanghai<br>geoadd china:city 106. 50 29. 53 chongqing 114. 05 22. 52 shenzhen 116. 38 39. 90<br>beijing</p><p>两极无法直接添加，一般会下载城市数据，直接通过Java程序一次性导入。<br>有效的经度从 - 180 度到 180 度。有效的纬度从 - 85. 05112878 度到<br>85. 05112878 度。<br>当坐标位置超出指定范围时，该命令将会返回一个错误。<br>已经添加的数据，是无法再次往里面添加的。<br>2 、geopos</p><p>（ 1 ）格式<br>geopos <key><member>[member…] 获得指定地区的坐标值</member></key></p><p>（ 2 ）实例</p><p>3 、geodist</p><p>（ 1 ）格式<br>geodist<key>&lt;member 1 &gt;&lt;member 2 &gt; [m|km|ft|mi] 获取两个位置之间的直线距<br>离</key></p><p>（ 2 ）实例<br>获取两个位置之间的直线距离</p><p>单位：<br>m表示单位为米[默认值]。</p><p>km表示单位为千米。<br>mi表示单位为英里。<br>ft表示单位为英尺。<br>如果用户没有显式地指定单位参数，那么GEODIST默认使用米作为单位</p><p>4 、georadius<br>（ 1 ）格式<br>georadius<key><longitude><latitude>radius m|km|ft|mi 以给定的经纬度为中心，<br>找出某一半径内的元素</latitude></longitude></key></p><p>经度纬度距离单位</p><p>（ 2 ）实例</p><h2 id="7-Redis-Jedis-测试"><a href="#7-Redis-Jedis-测试" class="headerlink" title="7. Redis_Jedis_测试"></a>7. Redis_Jedis_测试</h2><h4 id="7-1-Jedis-所需要的-jar-包"><a href="#7-1-Jedis-所需要的-jar-包" class="headerlink" title="7. 1 .Jedis 所需要的 jar 包"></a>7. 1 .Jedis 所需要的 jar 包</h4><dependency><groupId>redis.clients</groupId><artifactId>jedis</artifactId><version> 3. 2. 0 </version></dependency><h4 id="7-2-连接-Redis-注意事项"><a href="#7-2-连接-Redis-注意事项" class="headerlink" title="7. 2. 连接 Redis 注意事项"></a>7. 2. 连接 Redis 注意事项</h4><p>禁用Linux的防火墙：Linux(CentOS 7 )里执行命令</p><p><strong>systemctlstop&#x2F;disablefirewalld.service</strong></p><p>redis.conf中注释掉bind 127. 0. 0. 1 ,然后protected-modeno</p><h4 id="7-3-Jedis-常用操作"><a href="#7-3-Jedis-常用操作" class="headerlink" title="7. 3 .Jedis 常用操作"></a>7. 3 .Jedis 常用操作</h4><h4 id="7-3-1-创建动态的工程"><a href="#7-3-1-创建动态的工程" class="headerlink" title="7. 3. 1. 创建动态的工程"></a>7. 3. 1. 创建动态的工程</h4><h4 id="7-3-2-创建测试程序"><a href="#7-3-2-创建测试程序" class="headerlink" title="7. 3. 2. 创建测试程序"></a>7. 3. 2. 创建测试程序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">packagecom.atguigu.jedis;</span><br><span class="line">importredis.clients.jedis.Jedis;</span><br><span class="line">publicclassDemo 01 &#123;</span><br><span class="line">publicstaticvoidmain(String[]args)&#123;</span><br><span class="line">Jedisjedis=newJedis(&quot; 192. 168. 137. 3 &quot;, 6379 );</span><br><span class="line">Stringpong=jedis.ping();</span><br><span class="line">System.out.println(&quot;连接成功：&quot;+pong);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-测试相关数据类型"><a href="#7-4-测试相关数据类型" class="headerlink" title="7. 4. 测试相关数据类型"></a>7. 4. 测试相关数据类型</h4><h4 id="7-4-1-Jedis-API-Key"><a href="#7-4-1-Jedis-API-Key" class="headerlink" title="7. 4. 1. Jedis-API: Key"></a>7. 4. 1. Jedis-API: Key</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. set (&quot;k 1 &quot;,&quot;v 1 &quot;);</span><br><span class="line">jedis.set(&quot;k 2 &quot;,&quot;v 2 &quot;);</span><br><span class="line">jedis.set(&quot;k 3 &quot;,&quot;v 3 &quot;);</span><br><span class="line">Set&lt;String&gt;keys=jedis. keys (&quot;*&quot;);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line">for(Stringkey:keys)&#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis. exists (&quot;k 1 &quot;));</span><br><span class="line">System.out.println(jedis. ttl (&quot;k 1 &quot;));</span><br><span class="line">System.out.println(jedis. get (&quot;k 1 &quot;));</span><br></pre></td></tr></table></figure><h4 id="7-4-2-Jedis-API-String"><a href="#7-4-2-Jedis-API-String" class="headerlink" title="7. 4. 2. Jedis-API: String"></a>7. 4. 2. Jedis-API: String</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. mset (&quot;str 1 &quot;,&quot;v 1 &quot;,&quot;str 2 &quot;,&quot;v 2 &quot;,&quot;str 3 &quot;,&quot;v 3 &quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(jedis. mget (&quot;str 1 &quot;,&quot;str 2 &quot;,&quot;str 3 &quot;));</span><br></pre></td></tr></table></figure><h4 id="7-4-3-Jedis-API-List"><a href="#7-4-3-Jedis-API-List" class="headerlink" title="7. 4. 3. Jedis-API: List"></a>7. 4. 3. Jedis-API: List</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;list=jedis. lrange (&quot;mylist&quot;, 0 ,- 1 );</span><br><span class="line">for(Stringelement:list)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-4-Jedis-API-set"><a href="#7-4-4-Jedis-API-set" class="headerlink" title="7. 4. 4. Jedis-API: set"></a>7. 4. 4. Jedis-API: set</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 01 &quot;);</span><br><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 02 &quot;);</span><br><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 03 &quot;);</span><br><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 04 &quot;);</span><br><span class="line">Set&lt;String&gt;smembers=jedis. smembers (&quot;orders&quot;);</span><br><span class="line">for(Stringorder:smembers)&#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis. srem (&quot;orders&quot;,&quot;order 02 &quot;);</span><br></pre></td></tr></table></figure><h4 id="7-4-5-Jedis-API-hash"><a href="#7-4-5-Jedis-API-hash" class="headerlink" title="7. 4. 5. Jedis-API: hash"></a>7. 4. 5. Jedis-API: hash</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. hset (&quot;hash 1 &quot;,&quot;userName&quot;,&quot;lisi&quot;);</span><br><span class="line">System.out.println(jedis. hget (&quot;hash 1 &quot;,&quot;userName&quot;));</span><br><span class="line">Map&lt;String,String&gt;map=newHashMap&lt;String,String&gt;();</span><br><span class="line">map.put(&quot;telphone&quot;,&quot; 13810169999 &quot;);</span><br><span class="line">map.put(&quot;address&quot;,&quot;atguigu&quot;);</span><br><span class="line">map.put(&quot;email&quot;,&quot;abc@ 163 .com&quot;);</span><br><span class="line">jedis. hmset (&quot;hash 2 &quot;,map);</span><br><span class="line">List&lt;String&gt;result=jedis. hmget (&quot;hash 2 &quot;,&quot;telphone&quot;,&quot;email&quot;);</span><br><span class="line">for(Stringelement:result)&#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-6-Jedis-API-zset"><a href="#7-4-6-Jedis-API-zset" class="headerlink" title="7. 4. 6. Jedis-API: zset"></a>7. 4. 6. Jedis-API: zset</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. zadd (&quot;zset 01 &quot;, 100 d,&quot;z 3 &quot;);</span><br><span class="line">jedis.zadd(&quot;zset 01 &quot;, 90 d,&quot;l 4 &quot;);</span><br><span class="line">jedis.zadd(&quot;zset 01 &quot;, 80 d,&quot;w 5 &quot;);</span><br><span class="line">jedis.zadd(&quot;zset 01 &quot;, 70 d,&quot;z 6 &quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt;zrange=jedis. zrange (&quot;zset 01 &quot;, 0 ,- 1 );</span><br><span class="line">for(Stringe:zrange)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Redis-Jedis-实例"><a href="#8-Redis-Jedis-实例" class="headerlink" title="8. Redis_Jedis_实例"></a>8. Redis_Jedis_实例</h2><h4 id="8-1-完成一个手机验证码功能"><a href="#8-1-完成一个手机验证码功能" class="headerlink" title="8. 1. 完成一个手机验证码功能"></a>8. 1. 完成一个手机验证码功能</h4><p>要求：</p><p>1 、输入手机号，点击发送后随机生成 6 位数字码， 2 分钟有效</p><p>2 、输入验证码，点击验证，返回成功或失败</p><p>3 、每个手机号每天只能输入 3 次</p><h2 id="9-Redis-与-SpringBoot-整合"><a href="#9-Redis-与-SpringBoot-整合" class="headerlink" title="9. Redis 与 SpringBoot 整合"></a>9. Redis 与 SpringBoot 整合</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringBoot整合 Redis 非常简单，只需要按如下步骤整合即可</span><br></pre></td></tr></table></figure><h4 id="9-1-整合步骤"><a href="#9-1-整合步骤" class="headerlink" title="9. 1. 整合步骤"></a>9. 1. 整合步骤</h4><p>1 、在 pom.xml文件中引入 redis相关依赖</p><!--redis--><p>&lt; **dependency** &gt;</p><p>&lt; **groupId** &gt;org.springframework.boot&lt;&#x2F; **groupId** &gt;</p><p>&lt; **artifactId** &gt;spring-boot-starter-data-redis&lt;&#x2F; **artifactId** &gt;</p><p>&lt;&#x2F; **dependency** &gt;</p><!--spring 2 .X集成redis所需common-pool 2 - ->< **dependency** >< **groupId** >org.apache.commons</ **groupId** >< **artifactId** >commons-pool 2 </ **artifactId** >< **version** > 2. 6. 0 </ **version** ></ **dependency** >2 、application.properties配置redis配置#Redis服务器地址**spring.redis.host** = **192. 168. 140. 136**#Redis服务器连接端口**spring.redis.port** = **6379**#Redis数据库索引（默认为 0 ）**spring.redis.database** = **0**#连接超时时间（毫秒）**spring.redis.timeout** = **1800000**#连接池最大连接数（使用负值表示没有限制）**spring.redis.lettuce.pool.max-active** = **20**#最大阻塞等待时间(负数表示没限制)**spring.redis.lettuce.pool.max-wait** = **- 1**#连接池中的最大空闲连接**spring.redis.lettuce.pool.max-idle** = **5**#连接池中的最小空闲连接**spring.redis.lettuce.pool.min-idle** = **0**3 、添加redis配置类@EnableCaching@ConfigurationpublicclassRedisConfigextendsCachingConfigurerSupport{@BeanpublicRedisTemplate<String,Object>redisTemplate(RedisConnectionFactoryfactory){RedisTemplate<String,Object>template=newRedisTemplate<>();RedisSerializer<String>redisSerializer=newStringRedisSerializer();Jackson 2 JsonRedisSerializerjackson 2 JsonRedisSerializer=newJackson 2 JsonRedisSerializer(Object.class);ObjectMapperom=newObjectMapper();om.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);jackson 2 JsonRedisSerializer.setObjectMapper(om);template.setConnectionFactory(factory);//key序列化方式template.setKeySerializer(redisSerializer);//value序列化template.setValueSerializer(jackson 2 JsonRedisSerializer);//valuehashmap序列化template.setHashValueSerializer(jackson 2 JsonRedisSerializer);returntemplate;}@BeanpublicCacheManagercacheManager(RedisConnectionFactoryfactory){RedisSerializer<String>redisSerializer=newStringRedisSerializer();Jackson 2 JsonRedisSerializerjackson 2 JsonRedisSerializer=newJackson 2 JsonRedisSerializer(Object.class);//解决查询缓存转换异常的问题ObjectMapperom=newObjectMapper();om.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);jackson 2 JsonRedisSerializer.setObjectMapper(om);//配置序列化（解决乱码的问题）,过期时间 600 秒RedisCacheConfigurationconfig=RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofSeconds( 600 )).serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)).serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson 2 JsonRedisSerializer)).disableCachingNullValues();RedisCacheManagercacheManager=RedisCacheManager.builder(factory).cacheDefaults(config).build();returncacheManager;}}4 、测试一下RedisTestController中添加测试方法@RestController@RequestMapping("/redisTest")publicclassRedisTestController{@AutowiredprivateRedisTemplateredisTemplate;@GetMappingpublicStringtestRedis(){//设置值到 redisredisTemplate.opsForValue().set("name","lucy");//从 redis获取值Stringname=(String)redisTemplate.opsForValue().get("name");returnname;}}## 10. Redis_事务 _ 锁机制 _ 秒杀#### 10. 1 .Redis 的事务定义Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。Redis事务的主要作用就是串联多个命令防止别的命令插队。#### 10. 2 .Multi 、 Exec 、 discard从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。组队的过程中可以通过discard来放弃组队。案例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组队成功，提交成功</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组队阶段报错，提交失败</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组队成功，提交有成功有失败情况</span><br></pre></td></tr></table></figure><h4 id="10-3-事务的错误处理"><a href="#10-3-事务的错误处理" class="headerlink" title="10. 3. 事务的错误处理"></a>10. 3. 事务的错误处理</h4><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都<br>会执行，不会回滚。</p><h4 id="10-4-为什么要做成事务"><a href="#10-4-为什么要做成事务" class="headerlink" title="10. 4. 为什么要做成事务"></a>10. 4. 为什么要做成事务</h4><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p><h4 id="10-5-事务冲突的问题"><a href="#10-5-事务冲突的问题" class="headerlink" title="10. 5. 事务冲突的问题"></a>10. 5. 事务冲突的问题</h4><h4 id="10-5-1-例子"><a href="#10-5-1-例子" class="headerlink" title="10. 5. 1. 例子"></a>10. 5. 1. 例子</h4><p>一个请求想给金额减 8000</p><p>一个请求想给金额减 5000</p><p>一个请求想给金额减 1000</p><h4 id="10-5-2-悲观锁"><a href="#10-5-2-悲观锁" class="headerlink" title="10. 5. 2. 悲观锁"></a>10. 5. 2. 悲观锁</h4><p>悲观锁 <strong>(PessimisticLock)</strong> ,顾名思义，就是很悲观，每次去拿数据的时候都认为别人会<br>修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它<br>拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读<br>锁，写锁等，都是在做操作之前先上锁。</p><h4 id="10-5-3-乐观锁"><a href="#10-5-3-乐观锁" class="headerlink" title="10. 5. 3. 乐观锁"></a>10. 5. 3. 乐观锁</h4><p>乐观锁 <strong>(OptimisticLock),</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不<br>会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这<br>个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐<br>量。Redis就是利用这种 check-and-set机制实现事务的。</p><h4 id="10-5-4-WATCHkey-key…"><a href="#10-5-4-WATCHkey-key…" class="headerlink" title="10. 5. 4. WATCHkey[key…]"></a>10. 5. 4. WATCHkey[key…]</h4><p>在执行multi之前，先执行watchkey 1 [key 2 ],可以监视一个(或多个)key，如果在事务<br>执行之前这个 <strong>(</strong> 或这些 <strong>)key</strong> 被其他命令所改动，那么事务将被打断。</p><h4 id="10-5-5-unwatch"><a href="#10-5-5-unwatch" class="headerlink" title="10. 5. 5. unwatch"></a>10. 5. 5. unwatch</h4><p>取消WATCH命令对所有key的监视。</p><p>如果在执行WATCH命令之后，EXEC命令或DISCARD命令先被执行了的话，那么就<br>不需要再执行UNWATCH了。</p><p><a href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p><h4 id="10-6-Redis-事务三特性"><a href="#10-6-Redis-事务三特性" class="headerlink" title="10. 6 .Redis 事务三特性"></a>10. 6 .Redis 事务三特性</h4><p> 单独的隔离操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会</span><br><span class="line">被其他客户端发送来的命令请求所打断。</span><br></pre></td></tr></table></figure><p> 没有隔离级别的概念</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都</span><br><span class="line">不会被实际执行</span><br></pre></td></tr></table></figure><p> 不保证原子性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</span><br></pre></td></tr></table></figure><h2 id="11-Redis-事务-秒杀案例"><a href="#11-Redis-事务-秒杀案例" class="headerlink" title="11. Redis_事务 _ 秒杀案例"></a>11. Redis_事务 _ 秒杀案例</h2><h4 id="11-1-解决计数器和人员记录的事务操作"><a href="#11-1-解决计数器和人员记录的事务操作" class="headerlink" title="11. 1. 解决计数器和人员记录的事务操作"></a>11. 1. 解决计数器和人员记录的事务操作</h4><h4 id="11-2-Redis-事务-秒杀并发模拟"><a href="#11-2-Redis-事务-秒杀并发模拟" class="headerlink" title="11. 2 .Redis 事务 - - 秒杀并发模拟"></a>11. 2 .Redis 事务 - - 秒杀并发模拟</h4><p>使用工具ab模拟测试</p><p>CentOS 6 默认安装</p><p>CentOS 7 需要手动安装</p><h4 id="11-2-1-联网：yuminstallhttpd-tools"><a href="#11-2-1-联网：yuminstallhttpd-tools" class="headerlink" title="11. 2. 1. 联网：yuminstallhttpd-tools"></a>11. 2. 1. 联网：yuminstallhttpd-tools</h4><h4 id="11-2-2-无网络"><a href="#11-2-2-无网络" class="headerlink" title="11. 2. 2. 无网络"></a>11. 2. 2. 无网络</h4><p>（ 1 ）进入 cd &#x2F;run&#x2F;media&#x2F;root&#x2F;CentOS 7 x 86 _ 64 &#x2F;Packages（路径跟centos 6 不同）</p><p>（ 2 ）顺序安装</p><p>apr- 1. 4. 8 - 3 .el 7 .x 86 _ 64 .rpm</p><p>apr-util- 1. 5. 2 - 6 .el 7 .x 86 _ 64 .rpm</p><p>httpd-tools- 2. 4. 6 - 67 .el 7 .centos.x 86 _ 64 .rpm</p><h4 id="11-2-3-测试及结果"><a href="#11-2-3-测试及结果" class="headerlink" title="11. 2. 3. 测试及结果"></a>11. 2. 3. 测试及结果</h4><h5 id="11-2-3-1-通过-ab-测试"><a href="#11-2-3-1-通过-ab-测试" class="headerlink" title="11. 2. 3. 1. 通过 ab 测试"></a>11. 2. 3. 1. 通过 ab 测试</h5><p>vimpostfile模拟表单提交参数,以&amp;符号结尾;存放当前目录。</p><p>内容：prodid&#x3D; 0101 &amp;</p><p>ab-n 2000 - c 200 - k-p~&#x2F;postfile-Tapplication&#x2F;x-www-form-urlencoded<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 2. 115 : 8081 &#x2F;Seckill&#x2F;doseckill</p><h5 id="11-2-3-2-超卖"><a href="#11-2-3-2-超卖" class="headerlink" title="11. 2. 3. 2. 超卖"></a>11. 2. 3. 2. 超卖</h5><h4 id="11-3-超卖问题"><a href="#11-3-超卖问题" class="headerlink" title="11. 3. 超卖问题"></a>11. 3. 超卖问题</h4><h4 id="11-4-利用乐观锁淘汰用户，解决超卖问题。"><a href="#11-4-利用乐观锁淘汰用户，解决超卖问题。" class="headerlink" title="11. 4. 利用乐观锁淘汰用户，解决超卖问题。"></a>11. 4. 利用乐观锁淘汰用户，解决超卖问题。</h4><p>&#x2F;&#x2F;增加乐观锁</p><p>jedis.watch(qtkey);</p><p>&#x2F;&#x2F; 3 .判断库存</p><p>Stringqtkeystr&#x3D;jedis.get(qtkey);</p><p>if(qtkeystr&#x3D;&#x3D;null||<br>“”.equals(qtkeystr.trim())){</p><p>System.out.println(“未初始化库存”);</p><p>jedis.close();</p><p>returnfalse;</p><p>}</p><p>intqt&#x3D;Integer.parseInt(qtkeystr);</p><p>if(qt&lt;&#x3D; 0 ){</p><p>System.err.println(“已经秒光”);</p><p>jedis.close();</p><p>returnfalse;</p><p>}</p><p>&#x2F;&#x2F;增加事务</p><p>Transaction <strong>multi</strong> &#x3D;jedis.multi();</p><p>&#x2F;&#x2F; 4 .减少库存</p><p>&#x2F;&#x2F;jedis.decr(qtkey);</p><p><strong>multi</strong> .decr(qtkey);</p><p>&#x2F;&#x2F; 5 .加人</p><p>&#x2F;&#x2F;jedis.sadd(usrkey,uid);</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multi .sadd(usrkey,uid);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//执行事务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt;list= multi .exec();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断事务提交是否失败</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(list==null||list.size()== 0 )&#123;</span><br><span class="line">System.out.println(&quot;秒杀失败&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br><span class="line">returnfalse;</span><br><span class="line">&#125;</span><br><span class="line">System.err.print ln(&quot; 秒杀成功&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h4 id="11-5-继续增加并发测试"><a href="#11-5-继续增加并发测试" class="headerlink" title="11. 5. 继续增加并发测试"></a>11. 5. 继续增加并发测试</h4><h4 id="11-5-1-连接有限制"><a href="#11-5-1-连接有限制" class="headerlink" title="11. 5. 1. 连接有限制"></a>11. 5. 1. 连接有限制</h4><p>ab-n 2000 - c 200 - k-ppostfile-T’application&#x2F;x-www-form-urlencoded’<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 140. 1 : 8080 &#x2F;seckill&#x2F;doseckill</p><p>增加-r参数，-r Don’texitonsocketreceiveerrors.</p><p>ab-n 2000 - c 100 - r-ppostfile-T’application&#x2F;x-www-form-urlencoded’<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 140. 1 : 8080 &#x2F;seckill&#x2F;doseckill</p><h4 id="11-5-2-已经秒光，可是还有库存"><a href="#11-5-2-已经秒光，可是还有库存" class="headerlink" title="11. 5. 2. 已经秒光，可是还有库存"></a>11. 5. 2. 已经秒光，可是还有库存</h4><p>ab-n 2000 - c 100 - ppostfile-T’application&#x2F;x-www-form-urlencoded’<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 137. 1 : 8080 &#x2F;seckill&#x2F;doseckill</p><p>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点<br>的可能秒到了。</p><h4 id="11-5-3-连接超时，通过连接池解决"><a href="#11-5-3-连接超时，通过连接池解决" class="headerlink" title="11. 5. 3. 连接超时，通过连接池解决"></a>11. 5. 3. 连接超时，通过连接池解决</h4><h4 id="11-5-4-连接池"><a href="#11-5-4-连接池" class="headerlink" title="11. 5. 4. 连接池"></a>11. 5. 4. 连接池</h4><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</p><p>通过参数管理连接的行为</p><p>代码见项目中</p><p> 链接池参数<br> MaxTotal：控制一个pool可分配多少个 jedis实例，通过pool.getResource()<br>来获取；如果赋值为- 1 ，则表示不限制；如果 pool已经分配了 MaxTotal个<br>jedis实例，则此时pool的状态为 exhausted。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> maxIdle：控制一个pool最多有多少个状态为idle(空闲)的 jedis实例；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等</span><br><span class="line">待时间，则直接抛JedisConnectionException；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；</span><br><span class="line">如果为true，则得到的 jedis实例均是可用的；</span><br></pre></td></tr></table></figure><h4 id="11-6-解决库存遗留问题"><a href="#11-6-解决库存遗留问题" class="headerlink" title="11. 6. 解决库存遗留问题"></a>11. 6. 解决库存遗留问题</h4><h4 id="11-6-1-LUA-脚本"><a href="#11-6-1-LUA-脚本" class="headerlink" title="11. 6. 1. LUA 脚本"></a>11. 6. 1. LUA 脚本</h4><p>Lua是一个小巧的脚本语言，Lua脚本可以很容易的被C&#x2F;C++代码调用，也可以反过<br>来调用C&#x2F;C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过 200 k，<br>所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</p><p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可<br>扩展性。</p><p>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p><p><a href="https://www.w/">https://www.w</a> 3 cschool.cn&#x2F;lua&#x2F;</p><h4 id="11-6-2-LUA-脚本在-Redis-中的优势"><a href="#11-6-2-LUA-脚本在-Redis-中的优势" class="headerlink" title="11. 6. 2. LUA 脚本在 Redis 中的优势"></a>11. 6. 2. LUA 脚本在 Redis 中的优势</h4><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连<br>接redis的次数。提升性能。</p><p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些<br>redis事务性的操作。</p><p>但是注意redis的lua脚本功能，只有在 Redis 2. 6 以上的版本才可以使用。</p><p>利用lua脚本淘汰用户，解决超卖问题。</p><p>redis 2. 6 版本以后，通过 lua脚本解决争抢问题，实际上是 <strong>redis</strong> 利用其单线程的特<br>性，用任务队列的方式解决多任务并发问题。</p><h4 id="11-7-Redis-事务-秒杀案例-代码"><a href="#11-7-Redis-事务-秒杀案例-代码" class="headerlink" title="11. 7. Redis_事务_秒杀案例_代码"></a>11. 7. Redis_事务_秒杀案例_代码</h4><h4 id="11-7-1-项目结构"><a href="#11-7-1-项目结构" class="headerlink" title="11. 7. 1. 项目结构"></a>11. 7. 1. 项目结构</h4><h4 id="11-7-2-第一版：简单版"><a href="#11-7-2-第一版：简单版" class="headerlink" title="11. 7. 2. 第一版：简单版"></a>11. 7. 2. 第一版：简单版</h4><p>老师点 10 次，正常秒杀</p><p>同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。</p><p>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p><h4 id="11-7-3-第二版：加事务-乐观锁-解决超卖-但出现遗留库"><a href="#11-7-3-第二版：加事务-乐观锁-解决超卖-但出现遗留库" class="headerlink" title="11. 7. 3. 第二版：加事务-乐观锁(解决超卖),但出现遗留库"></a>11. 7. 3. 第二版：加事务-乐观锁(解决超卖),但出现遗留库</h4><h4 id="存和连接超时"><a href="#存和连接超时" class="headerlink" title="存和连接超时"></a>存和连接超时</h4><h4 id="11-7-4-第三版：连接池解决超时问题"><a href="#11-7-4-第三版：连接池解决超时问题" class="headerlink" title="11. 7. 4. 第三版：连接池解决超时问题"></a>11. 7. 4. 第三版：连接池解决超时问题</h4><h4 id="11-7-5-第四版：解决库存依赖问题，LUA-脚本"><a href="#11-7-5-第四版：解决库存依赖问题，LUA-脚本" class="headerlink" title="11. 7. 5. 第四版：解决库存依赖问题，LUA 脚本"></a>11. 7. 5. 第四版：解决库存依赖问题，LUA 脚本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localuserid=KEYS[ 1 ];</span><br><span class="line">localprodid=KEYS[ 2 ];</span><br><span class="line">localqtkey=&quot;sk:&quot;..prodid..&quot;:qt&quot;;</span><br><span class="line">localusersKey=&quot;sk:&quot;..prodid.&quot;:usr&#x27;;</span><br><span class="line">localuserExists=redis.call(&quot;sismember&quot;,usersKey,userid);</span><br><span class="line">iftonumber(userExists)== 1 then</span><br><span class="line">return 2 ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">end</span><br><span class="line">localnum=redis.call(&quot;get&quot;,qtkey);</span><br><span class="line">iftonumber(num)&lt;= 0 then</span><br><span class="line">return 0 ;</span><br><span class="line">else</span><br><span class="line">redis.call(&quot;decr&quot;,qtkey);</span><br><span class="line">redis.call(&quot;sadd&quot;,usersKey,userid);</span><br><span class="line">end</span><br><span class="line">return 1 ;</span><br></pre></td></tr></table></figure><h2 id="12-Redis-持久化之-RDB"><a href="#12-Redis-持久化之-RDB" class="headerlink" title="12. Redis 持久化之 RDB"></a>12. Redis 持久化之 RDB</h2><h4 id="12-1-总体介绍"><a href="#12-1-总体介绍" class="headerlink" title="12. 1. 总体介绍"></a>12. 1. 总体介绍</h4><p>官网介绍：<a href="http://www.redis.io/">http://www.redis.io</a></p><p>Redis提供了 2 个不同形式的持久化方式。</p><p> RDB（RedisDataBase）</p><p> AOF（AppendOfFile）</p><h4 id="12-2-RDB-（-RedisDataBase-）"><a href="#12-2-RDB-（-RedisDataBase-）" class="headerlink" title="12. 2 .RDB （ RedisDataBase ）"></a>12. 2 .RDB （ RedisDataBase ）</h4><h4 id="12-2-1-官网介绍"><a href="#12-2-1-官网介绍" class="headerlink" title="12. 2. 1. 官网介绍"></a>12. 2. 1. 官网介绍</h4><h4 id="12-2-2-是什么"><a href="#12-2-2-是什么" class="headerlink" title="12. 2. 2. 是什么"></a>12. 2. 2. 是什么</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot快<br>照，它恢复时是将快照文件直接读到内存里</p><h4 id="12-2-3-备份是如何执行的"><a href="#12-2-3-备份是如何执行的" class="headerlink" title="12. 2. 3. 备份是如何执行的"></a>12. 2. 3. 备份是如何执行的</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件<br>中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程<br>中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数<br>据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比 AOF方式更加<br>的高效。 <strong>RDB</strong> 的缺点是最后一次持久化后的数据可能丢失。</p><h4 id="12-2-4-Fork"><a href="#12-2-4-Fork" class="headerlink" title="12. 2. 4. Fork"></a>12. 2. 4. Fork</h4><p> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、<br>程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进<br>程</p><p> 在 Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多<br>会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”</p><p> 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要<br>发生变化时，才会将父进程的内容复制一份给子进程。</p><h4 id="12-2-5-RDB-持久化流程"><a href="#12-2-5-RDB-持久化流程" class="headerlink" title="12. 2. 5. RDB 持久化流程"></a>12. 2. 5. RDB 持久化流程</h4><h4 id="12-2-6-dump-rdb-文件"><a href="#12-2-6-dump-rdb-文件" class="headerlink" title="12. 2. 6. dump.rdb 文件"></a>12. 2. 6. dump.rdb 文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb</p><h4 id="12-2-7-配置位置"><a href="#12-2-7-配置位置" class="headerlink" title="12. 2. 7. 配置位置"></a>12. 2. 7. 配置位置</h4><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p><p>dir”&#x2F;myredis&#x2F;“</p><h4 id="12-2-8-如何触发-RDB-快照；保持策略"><a href="#12-2-8-如何触发-RDB-快照；保持策略" class="headerlink" title="12. 2. 8. 如何触发 RDB 快照；保持策略"></a>12. 2. 8. 如何触发 RDB 快照；保持策略</h4><h5 id="12-2-8-1-配置文件中默认的快照配置"><a href="#12-2-8-1-配置文件中默认的快照配置" class="headerlink" title="12. 2. 8. 1. 配置文件中默认的快照配置"></a>12. 2. 8. 1. 配置文件中默认的快照配置</h5><h5 id="12-2-8-2-命令-saveVSbgsave"><a href="#12-2-8-2-命令-saveVSbgsave" class="headerlink" title="12. 2. 8. 2. 命令 saveVSbgsave"></a>12. 2. 8. 2. 命令 saveVSbgsave</h5><p>save：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p><p><strong>bgsave</strong> ： <strong>Redis</strong> 会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p><p>可以通过lastsave命令获取最后一次成功执行快照的时间</p><h5 id="12-2-8-3-flushall-命令"><a href="#12-2-8-3-flushall-命令" class="headerlink" title="12. 2. 8. 3. flushall 命令"></a>12. 2. 8. 3. flushall 命令</h5><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p><h5 id="12-2-8-4-SNAPSHOTTING-快照"><a href="#12-2-8-4-SNAPSHOTTING-快照" class="headerlink" title="12. 2. 8. 4. ###SNAPSHOTTING 快照"></a>12. 2. 8. 4. ###SNAPSHOTTING 快照</h5><h5 id="12-2-8-5-Save"><a href="#12-2-8-5-Save" class="headerlink" title="12. 2. 8. 5. Save"></a>12. 2. 8. 5. Save</h5><p>格式：save秒钟写操作次数</p><p>RDB是整个内存的压缩过的 Snapshot，RDB的数据结构，可以配置复合的快照触发条<br>件，</p><p>默认是 <strong>1</strong> 分钟内改了 <strong>1</strong> 万次，或 <strong>5</strong> 分钟内改了 <strong>10</strong> 次，或 <strong>15</strong> 分钟内改了 <strong>1</strong> 次。</p><p>禁用</p><p>不设置save指令，或者给save传入空字符串</p><h5 id="12-2-8-6-stop-writes-on-bgsave-error"><a href="#12-2-8-6-stop-writes-on-bgsave-error" class="headerlink" title="12. 2. 8. 6. stop-writes-on-bgsave-error"></a>12. 2. 8. 6. stop-writes-on-bgsave-error</h5><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p><h5 id="12-2-8-7-rdbcompression-压缩文件"><a href="#12-2-8-7-rdbcompression-压缩文件" class="headerlink" title="12. 2. 8. 7. rdbcompression 压缩文件"></a>12. 2. 8. 7. rdbcompression 压缩文件</h5><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用<br>LZF算法进行压缩。</p><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p><h5 id="12-2-8-8-rdbchecksum-检查完整性"><a href="#12-2-8-8-rdbchecksum-检查完整性" class="headerlink" title="12. 2. 8. 8. rdbchecksum 检查完整性"></a>12. 2. 8. 8. rdbchecksum 检查完整性</h5><p>在存储快照后，还可以让redis使用 CRC 64 算法来进行数据校验，</p><p>但是这样做会增加大约 10 %的性能消耗，如果希望获取到最大的性能提升，可以关<br>闭此功能</p><p>推荐yes.</p><h5 id="12-2-8-9-rdb-的备份"><a href="#12-2-8-9-rdb-的备份" class="headerlink" title="12. 2. 8. 9. rdb 的备份"></a>12. 2. 8. 9. rdb 的备份</h5><p>先通过configgetdir 查询 rdb文件的目录</p><p>将*.rdb的文件拷贝到别的地方</p><p>rdb的恢复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 关闭Redis</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 先把备份的文件拷贝到工作目录下cpdump 2 .rdbdump.rdb</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 启动Redis,备份数据会直接加载</span><br></pre></td></tr></table></figure><h4 id="12-2-9-优势"><a href="#12-2-9-优势" class="headerlink" title="12. 2. 9. 优势"></a>12. 2. 9. 优势</h4><p> 适合大规模的数据恢复</p><p> 对数据完整性和一致性要求不高更适合使用</p><p> 节省磁盘空间</p><p> 恢复速度快</p><h4 id="12-2-10-劣势"><a href="#12-2-10-劣势" class="headerlink" title="12. 2. 10. 劣势"></a>12. 2. 10. 劣势</h4><p> Fork的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</p><p> 虽然 Redis在 fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">耗性能。</span><br></pre></td></tr></table></figure><p> 在备份周期在一定间隔时间做一次备份，所以如果 Redis意外 down掉的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">话，就会丢失最后一次快照后的所有修改。</span><br></pre></td></tr></table></figure><h4 id="12-2-11-如何停止"><a href="#12-2-11-如何停止" class="headerlink" title="12. 2. 11. 如何停止"></a>12. 2. 11. 如何停止</h4><p>动态停止RDB：redis-cliconfigsetsave””#save后给空值，表示禁用保存策略</p><h4 id="12-2-12-小总结"><a href="#12-2-12-小总结" class="headerlink" title="12. 2. 12. 小总结"></a>12. 2. 12. 小总结</h4><h2 id="13-Redis-持久化之-AOF"><a href="#13-Redis-持久化之-AOF" class="headerlink" title="13. Redis 持久化之 AOF"></a>13. Redis 持久化之 AOF</h2><h4 id="13-1-AOF-（-AppendOnlyFile-）"><a href="#13-1-AOF-（-AppendOnlyFile-）" class="headerlink" title="13. 1 .AOF （ AppendOnlyFile ）"></a>13. 1 .AOF （ AppendOnlyFile ）</h4><h4 id="13-1-1-是什么"><a href="#13-1-1-是什么" class="headerlink" title="13. 1. 1. 是什么"></a>13. 1. 1. 是什么</h4><p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下<br>来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重<br>新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一<br>次以完成数据的恢复工作</p><h4 id="13-1-2-AOF-持久化流程"><a href="#13-1-2-AOF-持久化流程" class="headerlink" title="13. 1. 2. AOF 持久化流程"></a>13. 1. 2. AOF 持久化流程</h4><p>（ 1 ）客户端的请求写命令会被append追加到AOF缓冲区内；</p><p>（ 2 ）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘<br>的AOF文件中；</p><p>（ 3 ）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩<br>AOF文件容量；</p><p>（ 4 ）Redis服务重启时，会重新 load加载AOF文件中的写操作达到数据恢复的目的；</p><h4 id="13-1-3-AOF-默认不开启"><a href="#13-1-3-AOF-默认不开启" class="headerlink" title="13. 1. 3. AOF 默认不开启"></a>13. 1. 3. AOF 默认不开启</h4><p>可以在redis.conf中配置文件名称，默认为appendonly.aof</p><p>AOF文件的保存路径，同RDB的路径一致。</p><h4 id="13-1-4-AOF-和-RDB-同时开启，-redis-听谁的？"><a href="#13-1-4-AOF-和-RDB-同时开启，-redis-听谁的？" class="headerlink" title="13. 1. 4. AOF 和 RDB 同时开启， redis 听谁的？"></a>13. 1. 4. AOF 和 RDB 同时开启， redis 听谁的？</h4><p>AOF和RDB同时开启，系统默认取 AOF的数据（数据不会存在丢失）</p><h4 id="13-1-5-AOF-启动-修复-恢复"><a href="#13-1-5-AOF-启动-修复-恢复" class="headerlink" title="13. 1. 5. AOF 启动 &#x2F; 修复 &#x2F; 恢复"></a>13. 1. 5. AOF 启动 &#x2F; 修复 &#x2F; 恢复</h4><p> AOF的备份机制和性能虽然和RDB不同,但是备份和恢复的操作同 RDB一样，<br>都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p><p> 正常恢复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 修改默认的appendonlyno，改为yes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 将有数据的aof文件复制一份保存到对应目录(查看目录：configgetdir)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 恢复：重启redis然后重新加载</span><br></pre></td></tr></table></figure><p> 异常恢复</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 修改默认的appendonlyno，改为yes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 如遇到 AOF 文件损坏，通过/usr/local/bin/ redis-check-aof--fix</span><br><span class="line">appendonly.aof 进行恢复</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 备份被写坏的AOF文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 恢复：重启redis，然后重新加载</span><br></pre></td></tr></table></figure><h4 id="13-1-6-AOF-同步频率设置"><a href="#13-1-6-AOF-同步频率设置" class="headerlink" title="13. 1. 6. AOF 同步频率设置"></a>13. 1. 6. AOF 同步频率设置</h4><p>appendfsyncalways</p><p>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p><p>appendfsynceverysec</p><p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p><p>appendfsyncno</p><p>redis不主动进行同步，把同步时机交给操作系统。</p><h4 id="13-1-7-Rewrite-压缩"><a href="#13-1-7-Rewrite-压缩" class="headerlink" title="13. 1. 7. Rewrite 压缩"></a>13. 1. 7. Rewrite 压缩</h4><p>1 是什么：</p><p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当<br>AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留<br>可以恢复数据的最小指令集.可以使用命令 bgrewriteaof</p><p>2 重写原理，如何实现重写</p><p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件<br>最后再rename)，redis 4. 0 版本后的重写，是指上就是把 rdb的快照，以二级制的形<br>式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p><p>no-appendfsync-on-rewrite：</p><p>如果no-appendfsync-on-rewrite&#x3D;yes,不写入 aof文件只写入缓存，用户请求不会阻<br>塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高<br>性能）</p><p>如果no-appendfsync-on-rewrite&#x3D;no, 还是会把数据往磁盘里刷，但是遇到重<br>写操作，可能会发生阻塞。（数据安全，但是性能降低）</p><p>触发机制，何时重写</p><p>Redis会记录上次重写时的AOF大小，默认配置是当 AOF文件大小是上次 rewrite后<br>大小的一倍且文件大于 64 M时触发</p><p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，<br>因此设定Redis要满足一定条件才会进行重写。</p><p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到 100 %时开始重写（文件<br>是原来重写后文件的 2 倍时触发）</p><p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件 64 MB。达到这个值开始重<br>写。</p><p>例如：文件达到 70 MB开始重写，降到 50 MB，下次什么时候开始重写？ 100 MB</p><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p><p>如果Redis的AOF当前大小&gt;&#x3D;base_size+base_size* 100 %(默认)且当前大<br>小&gt;&#x3D; 64 mb(默认)的情况下，Redis会对 AOF进行重写。</p><p>3 、重写流程</p><p>（ 1 ）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果<br>有，则等待该命令结束后再继续执行。</p><p>（ 2 ）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p><p>（ 3 ）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓<br>冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间<br>的新的数据修改动作不会丢失。</p><p>（ 4 ） 1 ).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。 2 ).主<br>进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（ 5 ）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p><h4 id="13-1-8-优势"><a href="#13-1-8-优势" class="headerlink" title="13. 1. 8. 优势"></a>13. 1. 8. 优势</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 备份机制更稳健，丢失数据概率更低。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 可读的日志文本，通过操作AOF稳健，可以处理误操作。</span><br></pre></td></tr></table></figure><h4 id="13-1-9-劣势"><a href="#13-1-9-劣势" class="headerlink" title="13. 1. 9. 劣势"></a>13. 1. 9. 劣势</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 比起RDB占用更多的磁盘空间。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 恢复备份速度要慢。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 每次读写都同步的话，有一定的性能压力。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 存在个别Bug，造成恢复不能。</span><br></pre></td></tr></table></figure><h4 id="13-1-10-小总结"><a href="#13-1-10-小总结" class="headerlink" title="13. 1. 10. 小总结"></a>13. 1. 10. 小总结</h4><h4 id="13-2-总结-Whichone"><a href="#13-2-总结-Whichone" class="headerlink" title="13. 2. 总结 (Whichone)"></a>13. 2. 总结 (Whichone)</h4><h4 id="13-2-1-用哪个好"><a href="#13-2-1-用哪个好" class="headerlink" title="13. 2. 1. 用哪个好"></a>13. 2. 1. 用哪个好</h4><p>官方推荐两个都启用。</p><p>如果对数据不敏感，可以选单独用RDB。</p><p>不建议单独用AOF，因为可能会出现Bug。</p><p>如果只是做纯内存缓存，可以都不用。</p><h4 id="13-2-2-官网建议"><a href="#13-2-2-官网建议" class="headerlink" title="13. 2. 2. 官网建议"></a>13. 2. 2. 官网建议</h4><p> RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p><p> AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些<br>命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.</p><p> Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p><p> 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何<br>持久化方式.</p><p> 同时开启两种持久化方式</p><p> 在这种情况下,当 redis重启的时候会优先载入 AOF文件来恢复原始的数据,因为<br>在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p><p> RDB的数据不实时，同时使用两者时服务器重启也只会找 AOF文件。那要不要只<br>使用AOF呢？</p><p> 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重<br>启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p><p> 性能建议</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 RDB文件只用作后备用途，建议只在Slave上持久化 RDB文件，而且只要^15</span><br><span class="line">分钟备份一次就够了，只保留 save 9001 这条规则。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果使用 AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简</span><br><span class="line">单只 load自己的AOF文件就可以了。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代价,一是带来了持续的 IO，二是 AOFrewrite的最后将rewrite过程中产生的新数据</span><br><span class="line">写到新文件造成的阻塞几乎是不可避免的。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只要硬盘许可，应该尽量减少 AOFrewrite的频率，AOF重写的基础大小默认值</span><br><span class="line">64 M太小了，可以设到 5 G以上。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认超过原大小 100 %大小时重写可以改到适当的数值。</span><br></pre></td></tr></table></figure><h2 id="14-Redis-主从复制"><a href="#14-Redis-主从复制" class="headerlink" title="14. Redis_主从复制"></a>14. Redis_主从复制</h2><h4 id="14-1-是什么"><a href="#14-1-是什么" class="headerlink" title="14. 1. 是什么"></a>14. 1. 是什么</h4><p>主机数据更新后根据配置和策略，自动同步到备机的 master&#x2F;slaver机制， <strong>Master</strong> 以</p><p>写为主， <strong>Slave</strong> 以读为主</p><h4 id="14-2-能干嘛"><a href="#14-2-能干嘛" class="headerlink" title="14. 2. 能干嘛"></a>14. 2. 能干嘛</h4><p> 读写分离，性能扩展</p><p> 容灾快速恢复</p><h4 id="14-3-怎么玩：主从复制"><a href="#14-3-怎么玩：主从复制" class="headerlink" title="14. 3. 怎么玩：主从复制"></a>14. 3. 怎么玩：主从复制</h4><p>拷贝多个redis.conf文件include(写绝对路径)</p><p>开启daemonizeyes</p><p>Pid文件名字pidfile</p><p>指定端口port</p><p>Log文件名字</p><p>dump.rdb名字 dbfilename</p><p>Appendonly关掉或者换名字</p><h4 id="14-3-1-新建-redis-6379-conf，填写以下内容"><a href="#14-3-1-新建-redis-6379-conf，填写以下内容" class="headerlink" title="14. 3. 1. 新建 redis 6379 .conf，填写以下内容"></a>14. 3. 1. 新建 redis 6379 .conf，填写以下内容</h4><p>include&#x2F;myredis&#x2F;redis.conf</p><p>pidfile&#x2F;var&#x2F;run&#x2F;redis_ 6379 .pid</p><p>port 6379</p><p>dbfilenamedump 6379 .rdb</p><h4 id="14-3-2-新建-redis-6380-conf，填写以下内容"><a href="#14-3-2-新建-redis-6380-conf，填写以下内容" class="headerlink" title="14. 3. 2. 新建 redis 6380 .conf，填写以下内容"></a>14. 3. 2. 新建 redis 6380 .conf，填写以下内容</h4><h4 id="14-3-3-新建-redis-6381-conf，填写以下内容"><a href="#14-3-3-新建-redis-6381-conf，填写以下内容" class="headerlink" title="14. 3. 3. 新建 redis 6381 .conf，填写以下内容"></a>14. 3. 3. 新建 redis 6381 .conf，填写以下内容</h4><p>slave-priority 10</p><p>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认 100</p><h4 id="14-3-4-启动三台-redis-服务器"><a href="#14-3-4-启动三台-redis-服务器" class="headerlink" title="14. 3. 4. 启动三台 redis 服务器"></a>14. 3. 4. 启动三台 redis 服务器</h4><h4 id="14-3-5-查看系统进程，看看三台服务器是否启动"><a href="#14-3-5-查看系统进程，看看三台服务器是否启动" class="headerlink" title="14. 3. 5. 查看系统进程，看看三台服务器是否启动"></a>14. 3. 5. 查看系统进程，看看三台服务器是否启动</h4><h4 id="14-3-6-查看三台主机运行情况"><a href="#14-3-6-查看三台主机运行情况" class="headerlink" title="14. 3. 6. 查看三台主机运行情况"></a>14. 3. 6. 查看三台主机运行情况</h4><p>inforeplication<br>打印主从复制的相关信息</p><h4 id="14-3-7-配从-库-不配主-库"><a href="#14-3-7-配从-库-不配主-库" class="headerlink" title="14. 3. 7. 配从(库 ) 不配主 ( 库 )"></a>14. 3. 7. 配从(库 ) 不配主 ( 库 )</h4><p>slaveof <ip><port></p><p>成为某个实例的从服务器</p><p>1 、在 6380 和 6381 上执行:slaveof 127. 0. 0. 16379</p><p>2 、在主机上写，在从机上可以读取数据</p><p>在从机上写数据报错</p><p>3 、主机挂掉，重启就行，一切如初</p><p>4 、从机重启需重设：slaveof 127. 0. 0. 16379</p><p>可以将配置增加到文件中。永久生效。</p><h4 id="14-4-常用-3-招"><a href="#14-4-常用-3-招" class="headerlink" title="14. 4. 常用 3 招"></a>14. 4. 常用 3 招</h4><h4 id="14-4-1-一主二仆"><a href="#14-4-1-一主二仆" class="headerlink" title="14. 4. 1. 一主二仆"></a>14. 4. 1. 一主二仆</h4><p>切入点问题？slave 1 、slave 2 是从头开始复制还是从切入点开始复制?比如从k 4 进来，<br>那之前的k 1 ,k 2 ,k 3 是否也可以复制？</p><p>从机是否可以写？set可否？</p><p>主机shutdown后情况如何？从机是上位还是原地待命？</p><p>主机又回来了后，主机新增记录，从机还能否顺利复制？</p><p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p><h4 id="14-4-2-薪火相传"><a href="#14-4-2-薪火相传" class="headerlink" title="14. 4. 2. 薪火相传"></a>14. 4. 2. 薪火相传</h4><p>上一个Slave可以是下一个 slave的Master，Slave同样可以接收其他slaves的连接和<br>同步请求，那么该slave作为了链条中下一个的 master,可以有效减轻 master的写压<br>力,去中心化降低风险。</p><p>用slaveof <ip><port></p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的 slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p><h4 id="14-4-3-反客为主"><a href="#14-4-3-反客为主" class="headerlink" title="14. 4. 3. 反客为主"></a>14. 4. 3. 反客为主</h4><p>当一个master宕机后，后面的 slave可以立刻升为 master，其后面的 slave不用做任<br>何修改。</p><p>用slaveof noone 将从机变为主机。</p><h4 id="14-5-复制原理"><a href="#14-5-复制原理" class="headerlink" title="14. 5. 复制原理"></a>14. 5. 复制原理</h4><p> Slave启动成功连接到 master后会发送一个sync命令</p><p> Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命<br>令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次<br>完全同步</p><p> 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p><p> 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</p><p> 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</p><h4 id="14-6-哨兵模式-sentinel"><a href="#14-6-哨兵模式-sentinel" class="headerlink" title="14. 6. 哨兵模式 (sentinel)"></a>14. 6. 哨兵模式 (sentinel)</h4><h4 id="14-6-1-是什么"><a href="#14-6-1-是什么" class="headerlink" title="14. 6. 1. 是什么"></a>14. 6. 1. 是什么</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库<br>转换为主库</p><h4 id="14-6-2-怎么玩-使用步骤"><a href="#14-6-2-怎么玩-使用步骤" class="headerlink" title="14. 6. 2. 怎么玩(使用步骤 )"></a>14. 6. 2. 怎么玩(使用步骤 )</h4><h5 id="14-6-2-1-调整为一主二仆模式，-6379-带着-6380-、-6381"><a href="#14-6-2-1-调整为一主二仆模式，-6379-带着-6380-、-6381" class="headerlink" title="14. 6. 2. 1. 调整为一主二仆模式， 6379 带着 6380 、 6381"></a>14. 6. 2. 1. 调整为一主二仆模式， 6379 带着 6380 、 6381</h5><h5 id="14-6-2-2-自定义的-myredis-目录下新建-sentinel-conf-文件，名"><a href="#14-6-2-2-自定义的-myredis-目录下新建-sentinel-conf-文件，名" class="headerlink" title="14. 6. 2. 2. 自定义的 &#x2F;myredis 目录下新建 sentinel.conf 文件，名"></a>14. 6. 2. 2. 自定义的 &#x2F;myredis 目录下新建 sentinel.conf 文件，名</h5><h5 id="字绝不能错"><a href="#字绝不能错" class="headerlink" title="字绝不能错"></a>字绝不能错</h5><h5 id="14-6-2-3-配置哨兵-填写内容"><a href="#14-6-2-3-配置哨兵-填写内容" class="headerlink" title="14. 6. 2. 3. 配置哨兵 , 填写内容"></a>14. 6. 2. 3. 配置哨兵 , 填写内容</h5><p>sentinelmonitormymaster 127. 0. 0. 163791</p><p>其中 mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p><h5 id="14-6-2-4-启动哨兵"><a href="#14-6-2-4-启动哨兵" class="headerlink" title="14. 6. 2. 4. 启动哨兵"></a>14. 6. 2. 4. 启动哨兵</h5><p>&#x2F;usr&#x2F;local&#x2F;bin</p><p>redis做压测可以用自带的redis-benchmark工具</p><p>执行redis-sentinel &#x2F;myredis&#x2F;sentinel.conf</p><h5 id="14-6-2-5-当主机挂掉，从机选举中产生新的主机"><a href="#14-6-2-5-当主机挂掉，从机选举中产生新的主机" class="headerlink" title="14. 6. 2. 5. 当主机挂掉，从机选举中产生新的主机"></a>14. 6. 2. 5. 当主机挂掉，从机选举中产生新的主机</h5><p>(大概 10 秒左右可以看到哨兵窗口日志，切换了新的主机)</p><p>哪个从机会被选举为主机呢？根据优先级别：slave-priority</p><p>原主机重启后会变为从机。</p><h5 id="14-6-2-6-复制延时"><a href="#14-6-2-6-复制延时" class="headerlink" title="14. 6. 2. 6. 复制延时"></a>14. 6. 2. 6. 复制延时</h5><p>由于所有的写操作都是先在Master上操作，然后同步更新到 Slave上，所以从<br>Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<br>Slave机器数量的增加也会使这个问题更加严重。</p><h4 id="14-6-3-故障恢复"><a href="#14-6-3-故障恢复" class="headerlink" title="14. 6. 3. 故障恢复"></a>14. 6. 3. 故障恢复</h4><p>优先级在redis.conf中默认：slave-priority 100 ，值越小优先级越高</p><p>偏移量是指获得原主机数据最全的</p><p>每个redis实例启动后都会随机生成一个 40 位的runid</p><h4 id="14-6-4-主从复制"><a href="#14-6-4-主从复制" class="headerlink" title="14. 6. 4. 主从复制"></a>14. 6. 4. 主从复制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privatestaticJedisSentinelPooljedisSentinelPool=null;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicstatic JedisgetJedisFromSentinel()&#123;</span><br><span class="line">if(jedisSentinelPool==null)&#123;</span><br><span class="line">Set&lt;String&gt;sentinelSet=newHashSet&lt;&gt;();</span><br><span class="line">sentinelSet.add(&quot; 192. 168. 11. 103 : 26379 &quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JedisPoolConfigjedisPoolConfig=newJedisPoolConfig();</span><br><span class="line">jedisPoolConfig.setMaxTotal( 10 );//最大可用连接数</span><br><span class="line">jedisPoolConfig.setMaxIdle( 5 );//最大闲置连接数</span><br><span class="line">jedisPoolConfig.setMinIdle( 5 );//最小闲置连接数</span><br><span class="line">jedisPoolConfig.setBlockWhenExhausted(true);//连接耗尽是否等待</span><br><span class="line">jedisPoolConfig.setMaxWaitMillis( 2000 );//等待时间</span><br><span class="line">jedisPoolConfig.setTestOnBorrow(true);//取连接的时候进行一下测试pingpong</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedisSentinelPool=newJedisSentinelPool(&quot;mymaster&quot;,sentinelSet,jedisPoolConfig);</span><br><span class="line">returnjedisSentinelPool.getResource();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">returnjedisSentinelPool.getResource();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-Redis-集群"><a href="#15-Redis-集群" class="headerlink" title="15. Redis 集群"></a>15. Redis 集群</h2><h4 id="15-1-问题"><a href="#15-1-问题" class="headerlink" title="15. 1. 问题"></a>15. 1. 问题</h4><p>容量不够，redis如何进行扩容？</p><p>并发写操作，redis如何分摊？</p><p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置<br>需要修改对应的主机地址、端口等信息。</p><p>之前通过代理主机来解决，但是redis 3. 0 中提供了解决方案。就是无中心化集群配置。</p><h4 id="15-2-什么是集群"><a href="#15-2-什么是集群" class="headerlink" title="15. 2. 什么是集群"></a>15. 2. 什么是集群</h4><p>Redis集群实现了对 Redis的水平扩容，即启动 N个redis节点，将整个数据库分布存<br>储在这N个节点中，每个节点存储总数据的 1 &#x2F;N。</p><p>Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群<br>中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</p><h4 id="15-3-删除持久化数据"><a href="#15-3-删除持久化数据" class="headerlink" title="15. 3. 删除持久化数据"></a>15. 3. 删除持久化数据</h4><p>将rdb,aof文件都删除掉。</p><h4 id="15-4-制作-6-个实例，-6379-6380-6381-6389-6390-6391"><a href="#15-4-制作-6-个实例，-6379-6380-6381-6389-6390-6391" class="headerlink" title="15. 4. 制作 6 个实例， 6379 , 6380 , 6381 , 6389 , 6390 , 6391"></a>15. 4. 制作 6 个实例， 6379 , 6380 , 6381 , 6389 , 6390 , 6391</h4><h4 id="15-4-1-配置基本信息"><a href="#15-4-1-配置基本信息" class="headerlink" title="15. 4. 1. 配置基本信息"></a>15. 4. 1. 配置基本信息</h4><p>开启daemonizeyes</p><p>Pid文件名字</p><p>指定端口</p><p>Log文件名字</p><p>Dump.rdb名字</p><p>Appendonly关掉或者换名字</p><h4 id="15-4-2-rediscluster-配置修改"><a href="#15-4-2-rediscluster-配置修改" class="headerlink" title="15. 4. 2. rediscluster 配置修改"></a>15. 4. 2. rediscluster 配置修改</h4><p>cluster-enabledyes 打开集群模式</p><p>cluster-config-filenodes- 6379 .conf 设定节点配置文件名</p><p>cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进<br>行主从切换。</p><p>include&#x2F;home&#x2F;bigdata&#x2F;redis.conf</p><p>port 6379</p><p>pidfile”&#x2F;var&#x2F;run&#x2F;redis_ 6379 .pid”</p><p>dbfilename”dump 6379 .rdb”</p><p>dir”&#x2F;home&#x2F;bigdata&#x2F;redis_cluster”</p><p>logfile”&#x2F;home&#x2F;bigdata&#x2F;redis_cluster&#x2F;redis_err_ 6379 .log”</p><p>cluster-enabledyes</p><p>cluster-config-filenodes- 6379 .conf</p><p>cluster-node-timeout 15000</p><h4 id="15-4-3-修改好-redis-6379-conf-文件，拷贝多个-redis-conf"><a href="#15-4-3-修改好-redis-6379-conf-文件，拷贝多个-redis-conf" class="headerlink" title="15. 4. 3. 修改好 redis 6379 .conf 文件，拷贝多个 redis.conf"></a>15. 4. 3. 修改好 redis 6379 .conf 文件，拷贝多个 redis.conf</h4><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h4 id="15-4-4-使用查找替换修改另外-5-个文件"><a href="#15-4-4-使用查找替换修改另外-5-个文件" class="headerlink" title="15. 4. 4. 使用查找替换修改另外 5 个文件"></a>15. 4. 4. 使用查找替换修改另外 5 个文件</h4><p>例如：:%s&#x2F; 6379 &#x2F; 6380</p><h4 id="15-4-5-启动-6-个-redis-服务"><a href="#15-4-5-启动-6-个-redis-服务" class="headerlink" title="15. 4. 5. 启动 6 个 redis 服务"></a>15. 4. 5. 启动 6 个 redis 服务</h4><h4 id="15-5-将六个节点合成一个集群"><a href="#15-5-将六个节点合成一个集群" class="headerlink" title="15. 5. 将六个节点合成一个集群"></a>15. 5. 将六个节点合成一个集群</h4><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p><p> 合体：</p><p>cd &#x2F;opt&#x2F;redis- 6. 2. 1 &#x2F;src</p><p>redis-cli–clustercreate–cluster-replicas 1192. 168. 11. 101 : 6379<br>192. 168. 11. 101 : 6380192. 168. 11. 101 : 6381192. 168. 11. 101 : 6389<br>192. 168. 11. 101 : 6390192. 168. 11. 101 : 6391</p><p>此处不要用 127. 0. 0. 1 ，请用真实IP地址</p><ul><li>-replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</li></ul><p> 普通方式登录</p><p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群<br>方式登录。</p><h4 id="15-6-c-采用集群策略连接，设置数据会自动切换到相应的"><a href="#15-6-c-采用集群策略连接，设置数据会自动切换到相应的" class="headerlink" title="15. 6. - c 采用集群策略连接，设置数据会自动切换到相应的"></a>15. 6. - c 采用集群策略连接，设置数据会自动切换到相应的</h4><h4 id="写主机"><a href="#写主机" class="headerlink" title="写主机"></a>写主机</h4><h4 id="15-7-通过-cluster-nodes-命令查看集群信息"><a href="#15-7-通过-cluster-nodes-命令查看集群信息" class="headerlink" title="15. 7. 通过 cluster nodes 命令查看集群信息"></a>15. 7. 通过 cluster nodes 命令查看集群信息</h4><h4 id="15-8-redis-cluster-如何分配这六个节点"><a href="#15-8-redis-cluster-如何分配这六个节点" class="headerlink" title="15. 8. redis cluster 如何分配这六个节点?"></a>15. 8. redis cluster 如何分配这六个节点?</h4><p>一个集群至少要有三个主节点。</p><p>选项–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p><p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP<br>地址上。</p><h4 id="15-9-什么是-slots"><a href="#15-9-什么是-slots" class="headerlink" title="15. 9. 什么是 slots"></a>15. 9. 什么是 slots</h4><p>[OK]Allnodesagreeaboutslotsconfiguration.</p><blockquote><blockquote><blockquote><p>Checkforopenslots…<br>Checkslotscoverage…<br>[OK]All 16384 slotscovered.<br>一个Redis集群包含 16384 个插槽（hashslot），数据库中的每个键都属于这 16384<br>个插槽的其中一个，</p></blockquote></blockquote></blockquote><p>集群使用公式CRC 16 (key)% 16384 来计算键key属于哪个槽，其中CRC 16 (key)语<br>句用于计算键key的CRC 16 校验和。</p><p>集群中的每个节点负责处理一部分插槽。举个例子，如果一个集群可以有主节点，<br>其中：</p><p>节点A负责处理 0 号至 5460 号插槽。</p><p>节点B负责处理 5461 号至 10922 号插槽。</p><p>节点C负责处理 10923 号至 16383 号插槽。</p><h4 id="15-10-在集群中录入值"><a href="#15-10-在集群中录入值" class="headerlink" title="15. 10. 在集群中录入值"></a>15. 10. 在集群中录入值</h4><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是<br>该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p><p>redis-cli客户端提供了–c参数实现自动重定向。</p><p>如redis-cli -c–p 6379 登入后，再录入、查询键值对可以自动重定向。</p><p>不在一个slot下的键值，是不能使用mget,mset等多键操作。</p><p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p><h4 id="15-11-查询集群中的值"><a href="#15-11-查询集群中的值" class="headerlink" title="15. 11. 查询集群中的值"></a>15. 11. 查询集群中的值</h4><p>CLUSTERGETKEYSINSLOT<slot><count>返回count个slot槽中的键。</p><h4 id="15-12-故障恢复"><a href="#15-12-故障恢复" class="headerlink" title="15. 12. 故障恢复"></a>15. 12. 故障恢复</h4><p>如果主节点下线？从节点能否自动升为主节点？注意： <strong>15</strong> 秒超时</p><p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage为yes，那么，整个<br>集群都挂掉</p><p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage为no，那么，该插<br>槽数据全都不能使用，也无法存储。</p><p>redis.conf中的参数 cluster-require-full-coverage</p><h4 id="15-13-集群的-Jedis-开发"><a href="#15-13-集群的-Jedis-开发" class="headerlink" title="15. 13. 集群的 Jedis 开发"></a>15. 13. 集群的 Jedis 开发</h4><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p><p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicclassJedisClusterTest&#123;</span><br><span class="line">publicstaticvoidmain(String[]args)&#123;</span><br><span class="line">Set&lt;HostAndPort&gt;set=newHashSet&lt;HostAndPort&gt;();</span><br><span class="line">set.add(newHostAndPort(&quot; 192. 168. 31. 211 &quot;, 6379 ));</span><br><span class="line">JedisClusterjedisCluster=newJedisCluster(set);</span><br><span class="line">jedisCluster.set(&quot;k 1 &quot;,&quot;v 1 &quot;);</span><br><span class="line">System.out.println(jedisCluster.get(&quot;k 1 &quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-14-Redis-集群提供了以下好处"><a href="#15-14-Redis-集群提供了以下好处" class="headerlink" title="15. 14. Redis 集群提供了以下好处"></a>15. 14. Redis 集群提供了以下好处</h4><p>实现扩容</p><p>分摊压力</p><p>无中心配置相对简单</p><h4 id="15-15-Redis-集群的不足"><a href="#15-15-Redis-集群的不足" class="headerlink" title="15. 15. Redis 集群的不足"></a>15. 15. Redis 集群的不足</h4><p>多键操作是不被支持的</p><p>多键的 Redis事务是不被支持的。lua脚本不被支持</p><p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分<br>片的方案想要迁移至rediscluster，需要整体迁移而不是逐步过渡，复杂度较大。</p><h2 id="16-Redis-应用问题解决"><a href="#16-Redis-应用问题解决" class="headerlink" title="16. Redis 应用问题解决"></a>16. Redis 应用问题解决</h2><h4 id="16-1-缓存穿透"><a href="#16-1-缓存穿透" class="headerlink" title="16. 1. 缓存穿透"></a>16. 1. 缓存穿透</h4><h4 id="16-1-1-问题描述"><a href="#16-1-1-问题描述" class="headerlink" title="16. 1. 1. 问题描述"></a>16. 1. 1. 问题描述</h4><p>key对应的数据在数据源并不存在，每次针对此 key的请求从缓存获取不到，请<br>求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，<br>不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><h4 id="16-1-2-解决方案"><a href="#16-1-2-解决方案" class="headerlink" title="16. 1. 2. 解决方案"></a>16. 1. 2. 解决方案</h4><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出<br>于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每<br>次请求都要到存储层去查询，失去了缓存的意义。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">（ 1 ） 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我</span><br><span class="line">们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最</span><br><span class="line">长不超过五分钟</span><br><span class="line">（ 2 ） 设置可访问的名单（白名单）：</span><br><span class="line">使用 bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移</span><br><span class="line">量，每次访问和bitmap里面的id进行比较，如果访问 id不在bitmaps里</span><br><span class="line">面，进行拦截，不允许访问。</span><br><span class="line">（ 3 ） 采用布隆过滤器：(布隆过滤器（BloomFilter）是 1970 年由布隆提出的。</span><br><span class="line">它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函</span><br><span class="line">数）。</span><br><span class="line">布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效</span><br><span class="line">率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困</span><br><span class="line">难。)</span><br><span class="line">将所有可能存在的数据哈希到一个足够大的 bitmaps中，一个一定不存在</span><br><span class="line">的数据会被这个 bitmaps拦截掉，从而避免了对底层存储系统的查询压</span><br><span class="line">力。</span><br><span class="line">（ 4 ） 进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和</span><br><span class="line">访问的数据，和运维人员配合，可以设置黑名单限制服务</span><br></pre></td></tr></table></figure><h4 id="16-2-缓存击穿"><a href="#16-2-缓存击穿" class="headerlink" title="16. 2. 缓存击穿"></a>16. 2. 缓存击穿</h4><h4 id="16-2-1-问题描述"><a href="#16-2-1-问题描述" class="headerlink" title="16. 2. 1. 问题描述"></a>16. 2. 1. 问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求<br>发现缓存过期一般都会从后端 DB加载数据并回设到缓存，这个时候大并发的请求可<br>能会瞬间把后端DB压垮。</p><h4 id="16-2-2-解决方案"><a href="#16-2-2-解决方案" class="headerlink" title="16. 2. 2. 解决方案"></a>16. 2. 2. 解决方案</h4><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时<br>候，需要考虑一个问题：缓存被“击穿”的问题。<br>解决问题：<br>（ <strong>1</strong> ）预先设置热门数据：在 redis高峰访问之前，把一些热门数据提前存入到<br>redis里面，加大这些热门数据key的时长<br>（ <strong>2</strong> ）实时调整：现场监控哪些数据热门，实时调整key的过期时长<br>（ <strong>3</strong> ）使用锁：<br>（ 1 ） 就是在缓存失效的时候（判断拿出来的值为空），不是立即去loaddb。<br>（ 2 ） 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）<br>去set一个 mutexkey<br>（ 3 ） 当操作返回成功时，再进行 loaddb的操作，并回设缓存,最后删除<br>mutexkey；<br>（ 4 ） 当操作返回失败，证明有线程在 loaddb，当前线程睡眠一段时间再重试<br>整个get缓存的方法。</p><h4 id="16-3-缓存雪崩"><a href="#16-3-缓存雪崩" class="headerlink" title="16. 3. 缓存雪崩"></a>16. 3. 缓存雪崩</h4><h4 id="16-3-1-问题描述"><a href="#16-3-1-问题描述" class="headerlink" title="16. 3. 1. 问题描述"></a>16. 3. 1. 问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求<br>发现缓存过期一般都会从后端 DB加载数据并回设到缓存，这个时候大并发的请求可<br>能会瞬间把后端DB压垮。<br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p><p>正常访问</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓存失效瞬间</span><br></pre></td></tr></table></figure><h4 id="16-3-2-解决方案"><a href="#16-3-2-解决方案" class="headerlink" title="16. 3. 2. 解决方案"></a>16. 3. 2. 解决方案</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓存失效时的雪崩效应对底层系统的冲击非常可怕！</span><br><span class="line">解决方案：</span><br><span class="line">（ 1 ） 构建多级缓存架构：nginx缓存+redis缓存+其他缓存（ehcache等）</span><br><span class="line">（ 2 ） 使用锁或队列：</span><br><span class="line">用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行</span><br><span class="line">读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并</span><br><span class="line">发情况</span><br><span class="line">（ 3 ） 设置过期标志更新缓存：</span><br><span class="line">记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程</span><br><span class="line">在后台去更新实际key的缓存。</span><br><span class="line">（ 4 ） 将缓存失效时间分散开：</span><br><span class="line">比如我们可以在原有的失效时间基础上增加一个随机值，比如 1 - 5 分钟随</span><br><span class="line">机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效</span><br><span class="line">的事件。</span><br></pre></td></tr></table></figure><h4 id="16-4-分布式锁"><a href="#16-4-分布式锁" class="headerlink" title="16. 4. 分布式锁"></a>16. 4. 分布式锁</h4><h4 id="16-4-1-问题描述"><a href="#16-4-1-问题描述" class="headerlink" title="16. 4. 1. 问题描述"></a>16. 4. 1. 问题描述</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于<br>分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发<br>控制锁策略失效，单纯的JavaAPI并不能提供分布式锁的能力。为了解决这个问题就<br>需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p><p>分布式锁主流的实现方案：</p><p>1 .基于数据库实现分布式锁</p><p>2 .基于缓存（Redis等）</p><p>3 .基于Zookeeper</p><p>每一种分布式锁解决方案都有各自的优缺点：</p><p>1 .性能：redis最高</p><p>2 .可靠性：zookeeper最高</p><p>这里，我们就基于redis实现分布式锁。</p><h4 id="16-4-2-解决方案：使用-redis-实现分布式锁"><a href="#16-4-2-解决方案：使用-redis-实现分布式锁" class="headerlink" title="16. 4. 2. 解决方案：使用 redis 实现分布式锁"></a>16. 4. 2. 解决方案：使用 redis 实现分布式锁</h4><p>redis:命令</p><p>#setsku: 1 :info“OK”NXPX 10000</p><p>EXsecond：设置键的过期时间为second秒。SETkeyvalueEXsecond效果等同于<br>SETEXkeysecondvalue。</p><p>PXmillisecond：设置键的过期时间为millisecond毫秒。SETkeyvaluePX<br>millisecond效果等同于PSETEXkeymillisecondvalue。</p><p>NX：只在键不存在时，才对键进行设置操作。SETkeyvalueNX效果等同于SETNX<br>keyvalue。</p><p>XX：只在键已经存在时，才对键进行设置操作。</p><p>1 .多个客户端同时获取锁（setnx）</p><p>2 .获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p><p>3 .其他客户端等待重试</p><h4 id="16-4-3-编写代码"><a href="#16-4-3-编写代码" class="headerlink" title="16. 4. 3. 编写代码"></a>16. 4. 3. 编写代码</h4><p>Redis:setnum 0</p><p>@GetMapping(“testLock”)<br>publicvoidtestLock(){<br>&#x2F;&#x2F; 1 获取锁，setne<br>Booleanlock&#x3D;redisTemplate.opsForValue().setIfAbsent(“lock”,” 111 “);<br>&#x2F;&#x2F; 2 获取锁成功、查询 num的值<br>if(lock){<br>Objectvalue&#x3D;redisTemplate.opsForValue().get(“num”);<br>&#x2F;&#x2F; 2. 1 判断 num为空 return<br>if(StringUtils.isEmpty(value)){<br>return;<br>}<br>&#x2F;&#x2F; 2. 2 有值就转成成 int<br>intnum&#x3D;Integer.parseInt(value+””);<br>&#x2F;&#x2F; 2. 3 把 redis的 num加 1<br>redisTemplate.opsForValue().set(“num”,++num);<br>&#x2F;&#x2F; 2. 4 释放锁，del<br>redisTemplate.delete(“lock”);</p><p>}else{<br>&#x2F;&#x2F; 3 获取锁失败、每隔 0. 1 秒再获取<br>try{<br>Thread.sleep( 100 );<br>testLock();<br>}catch(InterruptedExceptione){<br>e.printStackTrace();<br>}<br>}<br>}</p><p>重启，服务集群，通过网关压力测试：</p><p>ab-n 1000 - c 100 <a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 140. 1 : 8080 &#x2F;test&#x2F;testLock</p><p>查看redis中num的值：</p><p>基本实现。</p><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p><p>解决：设置过期时间，自动释放锁。</p><h4 id="16-4-4-优化之设置锁的过期时间"><a href="#16-4-4-优化之设置锁的过期时间" class="headerlink" title="16. 4. 4. 优化之设置锁的过期时间"></a>16. 4. 4. 优化之设置锁的过期时间</h4><p>设置过期时间有两种方式：</p><p>1 .首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之<br>间出现异常，锁也无法释放）</p><p>2 .在set时指定过期时间（推荐）</p><p>设置过期时间：</p><p>压力测试肯定也没有问题。自行测试</p><p>问题：可能会释放其他服务器的锁。</p><p>场景：如果业务逻辑的执行时间是 7 s。执行流程如下</p><p>1 .index 1 业务逻辑没执行完， 3 秒后锁被自动释放。</p><p>2 .index 2 获取到锁，执行业务逻辑， 3 秒后锁被自动释放。</p><p>3 .index 3 获取到锁，执行业务逻辑</p><p>4 .index 1 业务逻辑执行完成，开始调用del释放锁，这时释放的是index 3 的锁，<br>导致index 3 的业务只执行 1 s就被别人释放。</p><p>最终等于没锁的情况。</p><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这<br>个值，判断是否自己的锁</p><h4 id="16-4-5-优化之-UUID-防误删"><a href="#16-4-5-优化之-UUID-防误删" class="headerlink" title="16. 4. 5. 优化之 UUID 防误删"></a>16. 4. 5. 优化之 UUID 防误删</h4><p>问题：删除操作缺乏原子性。</p><p>场景：</p><p>1 .index 1 执行删除时，查询到的 lock值确实和 uuid相等</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uuid=v 1</span><br><span class="line">set(lock,uuid)；</span><br></pre></td></tr></table></figure><p>2 .index 1 执行删除前，lock刚好过期时间已到，被 redis自动释放</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 redis中没有了 lock，没有了锁。</span><br></pre></td></tr></table></figure><p>3 .index 2 获取了 lock</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index 2 线程获取到了 cpu的资源，开始执行方法</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uuid=v 2</span><br><span class="line">set(lock,uuid)；</span><br></pre></td></tr></table></figure><p>4 .index 1 执行删除，此时会把 index 2 的 lock删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index 1 因为已经在方法中了，所以不需要重新上锁。index 1 有执行的权</span><br></pre></td></tr></table></figure><p>限。index 1 已经比较完成了，这个时候，开始执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除的 index 2 的锁！</span><br></pre></td></tr></table></figure><h4 id="16-4-6-优化之-LUA-脚本保证删除的原子性"><a href="#16-4-6-优化之-LUA-脚本保证删除的原子性" class="headerlink" title="16. 4. 6. 优化之 LUA 脚本保证删除的原子性"></a>16. 4. 6. 优化之 LUA 脚本保证删除的原子性</h4><p>@GetMapping(“testLockLua”)<br>publicvoidtestLockLua(){<br>&#x2F;&#x2F; 1 声明一个 uuid,将做为一个 value放入我们的 key所对应的值中<br>Stringuuid&#x3D;UUID.randomUUID().toString();<br>&#x2F;&#x2F; 2 定义一个锁：lua脚本可以使用同一把锁，来实现删除！<br>StringskuId&#x3D;” 25 “;&#x2F;&#x2F;访问 skuId为 25 号的商品 100008348542<br>StringlocKey&#x3D;”lock:”+skuId;&#x2F;&#x2F;锁住的是每个商品的数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 3 获取锁</span><br><span class="line">Booleanlock=redisTemplate.opsForValue().setIfAbsent(locKey,uuid, 3 ,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;第一种：lock与过期时间中间不写任何的代码。<br>&#x2F;&#x2F;redisTemplate.expire(“lock”, 10 ,TimeUnit.SECONDS);&#x2F;&#x2F;设置过期时间<br>&#x2F;&#x2F;如果 true<br>if(lock){<br>&#x2F;&#x2F;执行的业务逻辑开始<br>&#x2F;&#x2F;获取缓存中的 num数据<br>Objectvalue&#x3D;redisTemplate.opsForValue().get(“num”);<br>&#x2F;&#x2F;如果是空直接返回<br>if(StringUtils.isEmpty(value)){<br>return;<br>}<br>&#x2F;&#x2F;不是空如果说在这出现了异常！那么delete就删除失败！也就是说锁永远存在！<br>intnum&#x3D;Integer.parseInt(value+””);<br>&#x2F;&#x2F;使 num每次+ 1 放入缓存<br>redisTemplate.opsForValue().set(“num”,String.valueOf(++num));<br>&#x2F;<em>使用 lua脚本来锁</em>&#x2F;<br>&#x2F;&#x2F;定义 lua脚本<br>Stringscript&#x3D;”ifredis.call(‘get’,KEYS[ 1 ])&#x3D;&#x3D;ARGV[ 1 ]thenreturnredis.call(‘del’,KEYS[ 1 ])<br>elsereturn 0 end”;<br>&#x2F;&#x2F;使用 redis执行 lua执行<br>DefaultRedisScript<Long>redisScript&#x3D;newDefaultRedisScript&lt;&gt;();<br>redisScript.setScriptText(script);<br>&#x2F;&#x2F;设置一下返回值类型为 Long<br>&#x2F;&#x2F;因为删除判断的时候，返回的 0 ,给其封装为数据类型。如果不封装那么默认返回<br>String类型，<br>&#x2F;&#x2F;那么返回字符串与 0 会有发生错误。<br>redisScript.setResultType(Long.class);<br>&#x2F;&#x2F;第一个要是 script脚本，第二个需要判断的 key，第三个就是 key所对应的值。</p><p>redisTemplate.execute(redisScript,Arrays.asList(locKey),uuid);<br>}else{<br>&#x2F;&#x2F;其他线程等待<br>try{<br>&#x2F;&#x2F;睡眠<br>Thread.sleep( 1000 );<br>&#x2F;&#x2F;睡醒了之后，调用方法。<br>testLockLua();<br>}catch(InterruptedExceptione){<br>e.printStackTrace();<br>}<br>}<br>}</p><p>Lua脚本详解：</p><p>项目中正确使用：</p><p>1 .定义key，key应该是为每个 sku定义的，也就是每个 sku有一把锁。</p><p>StringlocKey&#x3D; <strong>“lock:”</strong> +skuId;&#x2F;&#x2F;锁住的是每个商品的数据</p><p>Booleanlock&#x3D; <strong>redisTemplate</strong> .opsForValue().setIfAbsent(locKey,uuid, 3 ,TimeUnit. <strong>SECONDS</strong> );</p><h4 id="16-4-7-总结"><a href="#16-4-7-总结" class="headerlink" title="16. 4. 7. 总结"></a>16. 4. 7. 总结</h4><p>1 、加锁</p><p>&#x2F;&#x2F; 1 .从redis中获取锁,setk 1 v 1 px 20000 nx</p><p>Stringuuid&#x3D;UUID.randomUUID().toString();</p><p>Booleanlock&#x3D; <strong>this</strong>. <strong>redisTemplate</strong> .opsForValue()</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.setIfAbsent( &quot;lock&quot; ,uuid, 2 ,TimeUnit. SECONDS );</span><br></pre></td></tr></table></figure><p>2 、使用 lua释放锁</p><p>&#x2F;&#x2F; 2 .释放锁del<br>Stringscript&#x3D; <strong>“ifredis.call(‘get’,KEYS[ 1 ])&#x3D;&#x3D;ARGV[ 1 ]thenreturnredis.call(‘del’,</strong></p><p><strong>KEYS[ 1 ])elsereturn 0 end”</strong> ;<br>&#x2F;&#x2F;设置lua脚本返回的数据类型<br>DefaultRedisScript<Long>redisScript&#x3D; <strong>new</strong> DefaultRedisScript&lt;&gt;();<br>&#x2F;&#x2F;设置lua脚本返回类型为Long<br>redisScript.setResultType(Long. <strong>class</strong> );</p><p>redisScript.setScriptText(script);<br><strong>redisTemplate</strong> .execute(redisScript,Arrays.asList( <strong>“lock”</strong> ),uuid);</p><p>3 、重试</p><p>Thread.sleep( 500 );</p><p>testLock();</p><p>为了确保分布式锁可用，我们至少要确保锁的实现同时 <strong>满足以下四个条件</strong> ：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也<br>能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人<br>加的锁给解了。</li><li>加锁和解锁必须具有原子性。</li></ul><h2 id="17-Redis-6-0-新功能"><a href="#17-Redis-6-0-新功能" class="headerlink" title="17. Redis 6. 0 新功能"></a>17. Redis 6. 0 新功能</h2><h4 id="17-1-ACL"><a href="#17-1-ACL" class="headerlink" title="17. 1 .ACL"></a>17. 1 .ACL</h4><h4 id="17-1-1-简介"><a href="#17-1-1-简介" class="headerlink" title="17. 1. 1. 简介"></a>17. 1. 1. 简介</h4><p>RedisACL是 AccessControlList（访问控制列表）的缩写，该功能允许根据可<br>以执行的命令和可以访问的键来限制某些连接。<br>在 Redis 5 版本之前，Redis安全规则只有密码控制还有通过 rename来调整<br>高危命令比如flushdb，KEYS*，shutdown等。Redis 6 则提供 ACL的功能对用户<br>进行更细粒度的权限控制：<br>（ 1 ）接入权限:用户名和密码<br>（ 2 ）可以执行的命令<br>（ 3 ）可以操作的KEY<br>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p><h4 id="17-1-2-命令"><a href="#17-1-2-命令" class="headerlink" title="17. 1. 2. 命令"></a>17. 1. 2. 命令</h4><p>1 、使用acllist命令展现用户权限列表<br>（ 1 ）数据说明</p><p>2 、使用aclcat命令</p><p>（ 1 ）查看添加权限指令类别</p><p>（ 2 ）加参数类型名可以查看类型下具体命令</p><p>3 、使用aclwhoami命令查看当前用户</p><p>4 、使用aclsetuser命令创建和编辑用户 ACL<br>（ 1 ）ACL规则<br>下面是有效 ACL规则的列表。某些规则只是用于激活或删除标志，或对用户 ACL<br>执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连</p><p>接在一起。</p><p>（ 2 ）通过命令创建新用户默认权限<br>aclsetuseruser 1</p><p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用justcreated<br>的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p><p>（ 3 ）设置有用户名、密码、ACL权限、并启用的用户<br>aclsetuseruser 2 on&gt;password~cached:*+get</p><p>( 4 )切换用户，验证权限</p><h4 id="ACL规则"><a href="#ACL规则" class="headerlink" title="ACL规则"></a>ACL规则</h4><p>类型 参数 说明</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动和禁用用户</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on 激活某用户账号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">off</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">禁用某用户账号。注意，已验证的连接仍然可以工</span><br><span class="line">作。如果默认用户被标记为off，则新连接将在未进</span><br><span class="line">行身份验证的情况下启动，并要求用户使用AUTH选</span><br><span class="line">项发送AUTH或HELLO，以便以某种方式进行身份验</span><br><span class="line">证。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">权限的添加删除</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+&lt;command&gt; 将指令添加到用户可以调用的指令列表中</span><br></pre></td></tr></table></figure><ul><li><command> 从用户可执行指令列表移除指令</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+@&lt;category&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加该类别中用户要调用的所有指令，有效类别为</span><br><span class="line">@admin、@set、@sortedset...等，通过调用ACL</span><br><span class="line">CAT命令查看完整列表。特殊类别@all表示所有命</span><br><span class="line">令，包括当前存在于服务器中的命令，以及将来将</span><br><span class="line">通过模块加载的命令。</span><br></pre></td></tr></table></figure><ul><li>@<actegory> 从用户可调用指令中移除类别<br>allcommands +@all的别名<br>nocommand -@all的别名<br>可操作键的添加<br>或删除 ~<pattern></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加可作为用户可操作的键的模式。例如~*允许所有</span><br><span class="line">的键</span><br></pre></td></tr></table></figure><h4 id="17-2-IO-多线程"><a href="#17-2-IO-多线程" class="headerlink" title="17. 2 .IO 多线程"></a>17. 2 .IO 多线程</h4><h4 id="17-2-1-简介"><a href="#17-2-1-简介" class="headerlink" title="17. 2. 1. 简介"></a>17. 2. 1. 简介</h4><p>Redis 6 终于支撑多线程了，告别单线程了吗？<br>IO 多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线<br>程。Redis 6 执行命令依然是单线程。</p><h4 id="17-2-2-原理架构"><a href="#17-2-2-原理架构" class="headerlink" title="17. 2. 2. 原理架构"></a>17. 2. 2. 原理架构</h4><p>Redis 6 加入多线程,但跟Memcached这种从IO处理到数据访问多线程的实现模式有<br>些差异。Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单<br>线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制key、lua、事务，<br>LPUSH&#x2F;LPOP等等的并发问题。整体的设计大体如下:</p><p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p><p>io-threads-do-reads yes</p><p>io-threads 4</p><h4 id="17-3-工具支持-Cluster"><a href="#17-3-工具支持-Cluster" class="headerlink" title="17. 3. 工具支持 Cluster"></a>17. 3. 工具支持 Cluster</h4><p>之前老版 Redis想要搭集群需要单独安装 ruby环境，Redis 5 将redis-trib.rb的<br>功能集成到redis-cli。另外官方redis-benchmark工具开始支持cluster模式了，通过<br>多线程的方式对多个分片进行压测。</p><h4 id="17-4-Redis-新功能持续关注"><a href="#17-4-Redis-新功能持续关注" class="headerlink" title="17. 4 .Redis 新功能持续关注"></a>17. 4 .Redis 新功能持续关注</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 6 新功能还有：</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 、RESP 3 新的Redis通信协议：优化服务端与客户端之间通信</span><br></pre></td></tr></table></figure><p>2 、Clientsidecaching客户端缓存：基于RESP 3 协议实现的客户端缓存功能。为<br>了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络<br>交互。</p><p>3 、Proxy集群代理模式：Proxy功能，让Cluster拥有像单实例一样的接入方式，<br>降低大家使用cluster的门槛。不过需要注意的是代理不改变Cluster的功能限制，不<br>支持的命令还是不会支持，比如跨slot的多Key操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 、ModulesAPI</span><br></pre></td></tr></table></figure><p>Redis 6 中模块API开发进展非常大，因为RedisLabs为了开发复杂的功能，从<br>一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，<br>而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放<br>的平台。</p>-->]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%9F%A5%E6%89%BE/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找又叫折半查找，顾名思义，折半查找的意思就是每次查询的时候对数组折半，原理如下所示：</p><p> 我们此时进行比较，target &#x3D; 4与arr[mid]的值，如果比mid位置的数大，我们只需在mid的右边进行查找，因为当前数组为有序数组，mid左边的数都是比mid小的数，所以左边的数我们无需考虑，此时下一步如下：</p><img src="d153b259d3084aef805be248369d3d62.png" alt="d153b259d3084aef805be248369d3d62" style="zoom:;"><p> 当前计算的mid&#x3D;4,即arr[mid]&#x3D;5,此时的target&lt;mid位置的值，所以我们只需再比较mid左边的值，详细步骤如下：</p><img src="98fb7d484c9745a5b5500a7b51e3aa18.png" alt="98fb7d484c9745a5b5500a7b51e3aa18" style="zoom:67%;"><p> 此时计算的mid&#x3D;min,此时再进行比较，发现我们需要查找的target的值等于当前mid的值，所以我们直接返回当前mid位置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        System.out.println(binarySearch(arr, target));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> min + (max - min) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">                mid = min + (max - min) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">                mid = min + (max - min) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计模式七大原则</p><p>单一职责原则、接口隔离原则、依赖倒置原则、里氏替换原则、开闭原则、迪米特法则、合成复用原则</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>​对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p><ul><li><p>单一职责原则注意事项和细节</p><p>1）降低类的复杂度，一个类只负责一项职责</p><p>2）提高类的可读性，可维护性</p><p>3）降低变更引起的风险</p></li></ul><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>​客户端不应该依赖他它需要的接口，即<code>一个类对另一个类对依赖应该建立在最小的接口上</code></p><img src="image-20230106105640913.png" alt="image-20230106105640913" style="zoom:50%;"><p>应该将Interface1拆分为独立的几个接口，类A和C分别与他们需要的接口建立依赖关系。</p><img src="image-20230106105806679.png" alt="image-20230106105806679" style="zoom:50%;"><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><ul><li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li><li>抽象不应该依赖细节，细节应该依赖抽象</li><li>依赖倒置的中心思想是面向接口编程</li></ul><h4 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h4><ul><li>接口传递</li><li>构造方法传递</li><li>setter方式传递</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.inversion.improve;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyPass</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">ChangHong</span> <span class="variable">changHong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangHong</span>();</span><br><span class="line"><span class="comment">// OpenAndClose openAndClose = new OpenAndClose();</span></span><br><span class="line"><span class="comment">// openAndClose.open(changHong);</span></span><br><span class="line"><span class="comment">//通过构造器进行依赖传递</span></span><br><span class="line"><span class="comment">// OpenAndClose openAndClose = new OpenAndClose(changHong);</span></span><br><span class="line"><span class="comment">// openAndClose.open();</span></span><br><span class="line"><span class="comment">//通过 setter 方法进行依赖传递</span></span><br><span class="line"><span class="type">OpenAndClose</span> <span class="variable">openAndClose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAndClose</span>();</span><br><span class="line">openAndClose.setTv(changHong);</span><br><span class="line">openAndClose.open();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式 1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="comment">// interface IOpenAndClose &#123;</span></span><br><span class="line"><span class="comment">// public void open(ITV tv); //抽象方法,接收接口</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// interface ITV &#123; //ITV 接口</span></span><br><span class="line"><span class="comment">// public void play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// class ChangHong implements ITV &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// @Override</span></span><br><span class="line"><span class="comment">// public void play() &#123;</span></span><br><span class="line"><span class="comment">// // TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;长虹电视机，打开&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//// 实现接口</span></span><br><span class="line"><span class="comment">// class OpenAndClose implements IOpenAndClose&#123;</span></span><br><span class="line"><span class="comment">// public void open(ITV tv)&#123;</span></span><br><span class="line"><span class="comment">// tv.play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 方式 2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="comment">// interface </span></span><br><span class="line"><span class="comment">// public void open(); //抽象方法</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// interface ITV &#123; //ITV 接口</span></span><br><span class="line"><span class="comment">// public void play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// class OpenAndClose implements IOpenAndClose&#123;</span></span><br><span class="line"><span class="comment">// public ITV tv; //成员</span></span><br><span class="line"><span class="comment">// public OpenAndClose(ITV tv)&#123; //构造器</span></span><br><span class="line"><span class="comment">// this.tv = tv;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// public void open()&#123;</span></span><br><span class="line"><span class="comment">// this.tv.play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 方式 3 , 通过 setter 方法传递</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123; <span class="comment">// ITV 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line"><span class="keyword">private</span> ITV tv;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.tv = tv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.tv.play();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangHong</span> <span class="keyword">implements</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ol><li>一个对象应该对其他对象保持最少的了解 </li><li>类与类关系越密切，耦合度越大 </li><li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</li><li>迪米特法则还有个更简单的定义：只与直接的朋友通信 </li><li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，<strong>我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li></ol><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><img src="image-20230106142814445.png" alt="image-20230106142814445" style="zoom:50%;"><ul><li>用来描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</li><li>类之间的关系：依赖、泛化（继承）、实现、关联、聚合和组合</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式分为三种类型，共23种</p><ul><li><p>创建型模式：<font color="red"> 单例模式</font>、抽象工厂模式、原型模式、建造者模式、<font color="red">工厂模式</font></p></li><li><p>结构型模式：适配器模式、桥接模式、<font color="red">装饰模式</font>、组合模式、外观模式、亨元模式、<font color="red">代理模式</font></p></li><li><p>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、<code>观察者模式</code>、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式</p></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p><h4 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1.饿汉式（静态常量）"></a>1.饿汉式（静态常量）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式（静态变量）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有化（防止new）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个共有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点</p><p>​1）优点：在类装载时就完成了初始化，避免了线程同步问题。</p><p>​2）缺点：没有达到lazy loading的效果，如果从始至终没有使用这个实例，会造成内存浪费。</p><h4 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块中创建代理对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个共有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-懒汉式（线程不安全）-不推荐使用"><a href="#3-懒汉式（线程不安全）-不推荐使用" class="headerlink" title="3.懒汉式（线程不安全）- 不推荐使用"></a>3.懒汉式（线程不安全）- 不推荐使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点</p><p>1）实现了lazy loading，但是只能在单线程下使用</p><p>2）如果在多线程下，如果一个线程进入了if判断，还未来得及往下执行，另一个线程也通过了这个判断语句，这时会产生多个实例</p><h4 id="4-懒汉式（线程安全）-不推荐使用"><a href="#4-懒汉式（线程安全）-不推荐使用" class="headerlink" title="4.懒汉式（线程安全）- 不推荐使用"></a>4.懒汉式（线程安全）- 不推荐使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-双重检查-实际开发推荐"><a href="#5-双重检查-实际开发推荐" class="headerlink" title="5.双重检查-实际开发推荐"></a>5.双重检查-实际开发推荐</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，加入双重检查代码，解决线程问题，同时解决懒加载问题</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点：</p><p>1）双重检查在多线程常用，进行两次if判读，可以保证线程安全</p><p>2）实例化代码只用执行一次，后面再次访问时，判断if成立，直接return实例化对象</p><h4 id="6-静态内部类"><a href="#6-静态内部类" class="headerlink" title="6.静态内部类"></a>6.静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写一个静态内部类，该类中有一个静态属性 Singleton</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态共有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-枚举"><a href="#7-枚举" class="headerlink" title="7.枚举"></a>7.枚举</h4><p>推荐使用</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1）单例模式保证了系统内存中只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</p><p>2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</p><p>3）使用场景：需要频繁进行创建销毁的对象、创建对象时耗时过多或耗费资源过多但又经常用到的对象</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>1.简单工厂模式是属于创建型模式，是工厂模式的一种。<strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式。</p><p>2.简单工厂模式：定义了一个创建对象的类，由这个类来<strong>封装实例化对象的行为</strong>(代码)</p><p>3.在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将pizza类做成抽象的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料，不同的披萨不一样，所以用抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; baking;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; cutting;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; boxing;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  11:35</span></span><br><span class="line"><span class="comment"> * 简单工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用简单工厂模式&quot;</span>);</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">            pizza.setName(orderType);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;chess&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ChessPizza</span>();</span><br><span class="line">            pizza.setName(orderType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出pizza制作过程</span></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong>工厂方法模式设计方案</strong>：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</p><p><strong>工厂方法模式</strong>：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将<strong>对象的实例化推迟到子类</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个抽象方法,createPizza,让各个工厂子类自己实现</span></span><br><span class="line">    <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String orderType;<span class="comment">//订购pizza的类型</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = createPizza(orderType);<span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line">            <span class="comment">//输出pizza制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line"><span class="comment">//    SimpleFactory simpleFactory;</span></span><br><span class="line"><span class="comment">//    Pizza pizza = null;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //构造器</span></span><br><span class="line"><span class="comment">//    public OrderPizza(SimpleFactory simpleFactory)&#123;</span></span><br><span class="line"><span class="comment">//        setFactory(simpleFactory);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public void setFactory(SimpleFactory simpleFactory)&#123;</span></span><br><span class="line"><span class="comment">//        String orderType = &quot;&quot;;//用户输入</span></span><br><span class="line"><span class="comment">//        this.simpleFactory = simpleFactory;//设置简单工厂对象</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        do &#123;</span></span><br><span class="line"><span class="comment">//            orderType = getType();</span></span><br><span class="line"><span class="comment">//            pizza = this.simpleFactory.createPizza(orderType);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            if (pizza != null)&#123;</span></span><br><span class="line"><span class="comment">//                //成功</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125; while (true);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//写一个方法可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;chess&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;chess&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建北京口味的各种披萨</span></span><br><span class="line"><span class="comment">//        new BJOrderPizza();</span></span><br><span class="line">        <span class="comment">//创建伦敦口味的各种披萨</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LDOrderPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ol><li><p>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类</p></li><li><p>抽象工厂模式可以将<strong>简单工厂模式</strong>和<strong>工厂方法模式</strong>进行整合。</p></li><li><p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</p></li><li><p>将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了<strong>工厂簇</strong>，更利于代码的维护和扩展。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  16:47</span></span><br><span class="line"><span class="comment"> * 一个抽象工厂模式的抽象层（接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让下面的工厂子类来具体实现</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  16:59</span></span><br><span class="line"><span class="comment"> * 工厂子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  16:59</span></span><br><span class="line"><span class="comment"> * 工厂子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    AbsFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span>&#123;</span><br><span class="line">        setFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(AbsFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = factory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != pizza)&#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝区别是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。</p><p>浅拷贝是使用默认的clone方法来实现。</p><p><strong>深拷贝的实现方式</strong></p><p>1）重写clone方法</p><p>2）通过对象序列化实现深拷贝</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><strong>1)</strong> <strong>建造者模式（</strong>Builder Pattern<strong>）</strong> 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><p><strong>2)</strong> <strong>建造者模式</strong> 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><p>建造者模式的四个角色</p><p><strong>1) Product</strong>（产品角色）： 一个具体的产品对象。</p><p><strong>2) Builder</strong>（抽象建造者）： 创建一个Product对象的各个部件指定的 接口&#x2F;<strong>抽象类</strong>。</p><p><strong>3) ConcreteBuilder</strong>（具体建造者）： 实现接口，构建和装配各个部件。</p><p><strong>4) Director</strong>（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</p><img src="image-20230111154707417.png" alt="image-20230111154707417" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/11  16:22</span></span><br><span class="line"><span class="comment"> * 产品-&gt;product</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBaise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBaise</span><span class="params">(String baise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWall</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWall</span><span class="params">(String wall)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoofed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roofed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoofed</span><span class="params">(String roofed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roofed = roofed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/11  16:25</span></span><br><span class="line"><span class="comment"> * 抽象的建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将建造的流程写好，抽象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWall</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子,将产品返回</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/11  16:28</span></span><br><span class="line"><span class="comment"> * 具体的建造类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子打地基5m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWall</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子砌墙10cm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子屋顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>基本介绍</p><ol><li><p>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</p></li><li><p>适配器模式属于结构型模式</p></li><li><p>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p></li></ol><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>类适配器的原理就是通过继承来实现适配器功能。具体做法：让Adapter实现Target接口，并且继承Adaptee，这样Adapter就具备Target和Adaptee可以将两者进行转化。</p><img src="adapter.png" alt="adapter" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specialRequest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理特殊请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理普通请求&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.specialRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>对象适配器的原理就是通过组合来实现适配器功能。具体做法：让Adapter实现Target接口，然后内部持有Adaptee实例，然后在Target接口规定的方法内转换Adaptee。</p><p>具体代码实现很简单就是将<code>Adapter</code>代码修改一下，原来是继承 <code>Adaptee</code>，现在是持有 <code>Adaptee</code>示例 具体代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理普通请求&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.adaptee.specialRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/class.webp" class title="interface"><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><p>​接口适配器的关注点与类适配器和对象适配器的关注点不太一样，类适配器和对象适配器着重于将系统存在的一个角色(Adaptee）转化成目标接口（Target）所需内容，而接口适配器的使用场景是解决接口方法过多，如果直接实现接口，那么类会多出许多空实现的方法，类显得很臃肿。此时，使用接口适配器就能让我们只实现我们需要的接口方法，目标更清晰。</p><p>​其实接口适配器和对象适配器就很像了无非是对象适配器关注点是一个对象的转换，接口可能是多个他的关注点不再是对象转换而是接口转换，这些接口可能需要用到很多个源对象，也就是说这样设计之后转换器中持有的对象就可能是多个了。</p><img src="interface.png" alt="interface" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoginService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> <span class="keyword">implements</span> <span class="title class_">ILoginService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户：&quot;</span> + username);</span><br><span class="line">        System.out.println(<span class="string">&quot;密码：&quot;</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IThirdLoginAdapter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(IThirdLoginAdapter adapter)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName,String openId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ThirdLoginAdapter</span> <span class="keyword">implements</span> <span class="title class_">IThirdLoginAdapter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ILoginService loginService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThirdLoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginService = loginService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QQLoginAdapter</span> <span class="keyword">extends</span> <span class="title class_">ThirdLoginAdapter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QQLoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(loginService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(IThirdLoginAdapter adapter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adapter <span class="keyword">instanceof</span> QQLoginAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, String openId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatLoginAdapter</span> <span class="keyword">extends</span> <span class="title class_">ThirdLoginAdapter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeChatLoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(loginService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(IThirdLoginAdapter adapter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adapter <span class="keyword">instanceof</span> WeChatLoginAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, String openId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信登录:&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.loginService.login(userName, openId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginAdapter</span> <span class="keyword">implements</span> <span class="title class_">ILoginAdapter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILoginService loginService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginService = loginService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">qqLogin</span><span class="params">(String userName,String openId)</span> &#123;</span><br><span class="line">        login(userName,openId,WeChatLoginAdapter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">weChatLogin</span><span class="params">(String userName,String openId)</span> &#123;</span><br><span class="line">        login(userName,openId,WeChatLoginAdapter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, String openId, Class&lt;? extends IThirdLoginAdapter&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">IThirdLoginAdapter</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor(ILoginService.class).newInstance(<span class="built_in">this</span>.loginService);</span><br><span class="line">            <span class="keyword">if</span>(instance.support(instance))&#123;</span><br><span class="line">                instance.login(userName,openId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ILoginService</span> <span class="variable">loginService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginService</span>();</span><br><span class="line">        loginService.login(<span class="string">&quot;土豆&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ILoginAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginAdapter</span>(loginService);</span><br><span class="line">        adapter.qqLogin(<span class="string">&quot;qwe&quot;</span>,<span class="string">&quot;123qwe234234&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul><li><p>桥接模式是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</p></li><li><p>是一种结构型设计模式</p></li><li><p>Bridge模式基于类的<code>最小设计原则</code>，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</p><img src="11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/bridge.png" class title="bridge"></li></ul><p>桥接模式分为一下四个角色：</p><ul><li><strong>Abstract</strong>：定义抽象接口，拥有一个Implementor类型的对象引用</li><li><strong>RefinedAbstraction</strong>：扩展Abstraction中的接口定义</li><li><strong>Implementor</strong>：实现部分，可以为接口或者是抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，而抽象部分定义的则是基于实现部分操作的业务方法</li><li><strong>ConcreteImplementorA &#x2F;B</strong>： 实现Implementor接口，给出具体实现</li></ul><img src="Phone.png" alt="Phone" style="zoom:67%;"><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p><strong>装饰者模式定义</strong></p><ol><li><p>装饰者模式：<strong>动态的</strong>将新功能<strong>附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p></li><li><p>这里提到的<strong>动态的将新功能附加到对象</strong>和<strong>ocp****原则</strong>，在后面的应用实例上会以代码的形式体现，请同学们注意体会。</p></li></ol><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>基本介绍</p><ol><li><p>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。</p></li><li><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p></li><li><p>这种类型的设计模式属于结构型模式。</p></li><li><p>组合模式使得用户对单个对象和组合对象的访问具有一致性，<strong>即</strong>：组合能让客户以一致的方式处理个别对象以及组合对象</p></li></ol><img src="screenshot-20230308-171645.png" alt="screenshot-20230308-171645" style="zoom:67%;"><p>对原理结构图的说明-即(组合模式的角色及职责)</p><ol><li><p>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口</p></li><li><p>Leaf : 在组合中表示叶子节点，叶子节点没有子节点</p></li><li><p>Composite:非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加、删除</p></li></ol><p><strong>组合模式注意事项</strong></p><ul><li>简化客户端操作。客户端只需要面向一致的对象而不用考虑整体部分或者节点叶子的部分</li><li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动</li><li>需要&#x3D;&#x3D;遍历组织结构，或者处理的对象具有树形结构时，非常适用组合模式&#x3D;&#x3D;</li><li>要求较高的抽象性，&#x3D;&#x3D;如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式&#x3D;&#x3D;</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p><strong>基本介绍</strong></p><ol><li><p>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p></li><li><p>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p></li></ol><img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230309112648315.png" alt="image-20230309112648315" style="zoom:67%;"><p><strong>原理类图的说明(外观模式的角色)</strong></p><ol><li><p>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象</p></li><li><p>调用者(Client): 外观接口的调用者</p></li><li><p>子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者</p></li></ol><p><strong>外观模式的注意事项和细节</strong></p><ol><li><p>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</p></li><li><p>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</p></li><li><p>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</p></li><li><p>当系统需要进行分层设计时，可以考虑使用Facade模式</p></li><li><p>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</p></li><li><p>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</p></li></ol><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>基本介绍</p><ol><li><p>享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象</p></li><li><p>常用于系统底层开发，解决系统的性能问题。像<strong>数据库连接池</strong>，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</p></li><li><p>享元模式能够解决<strong>重复对象的内存浪费的问题</strong>，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</p></li><li><p>享元模式<strong>经典的应用场景</strong>就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</p></li><li><p>享元模式把一个对象的状态分为内部状态和外部状态，<strong>内部状态是不变的可以共享的相同内容</strong>，<strong>外部状态是变化的是需要外部环境来设置的不能共享的内容</strong>，需要注意内部状态和外部状态的区分</p></li></ol><img src="WX20230328-162411@2x.png" alt="WX20230328-162411@2x" style="zoom:50%;"><ol><li><p>FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现</p></li><li><p>ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</p></li><li><p>UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂</p></li><li><p>FlyWeightFactory 享元工厂类，用于构建一个池容器，同时提供从池中获取对象</p></li></ol><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p><strong>代理模式</strong>(Proxy Pattern) 是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。代理模式给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</p></blockquote><img src="11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/proxy.webp" class title="proxy"><p>主要包含三种角色：</p><p>1.抽象主题角色（Subject）：主要职责是声明真实主题与代理的共同接口方法，该类可以是接口也可以是抽象类</p><p>2.真实主题角色（RealSubject）：也被称为被代理类，该类定义的代理所表示的真实对象，是负责执行系统真正的逻辑业务对象</p><p>3.代理主题角色（Proxy）：也被称为代理类，其内部持有RealSubject的引用，因此具备完全的对Real Subject的代理权，客户端调用代理对象的方法，同时也调用被代理对象的方法，但是会在代理对象前后增加一些处理代码</p><h3 id="代理模式的通用写法"><a href="#代理模式的通用写法" class="headerlink" title="代理模式的通用写法"></a>代理模式的通用写法</h3><p><strong>Subject：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RealSubject:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原始类处理请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Proxy:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="built_in">this</span>.subject.request();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理请求之前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理请求之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(realSubject);</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>这种代理方式需要代理对象和目标对象实现一样的接口，且代理类的代码是在运行之前就需要写好的 优点是：可以在不修改目标对象的前提下扩展目标对象的功能。</p><p>缺点也很明显</p><ol><li>如果接口需要增加一个方法对应的代理类和被代理类都需要添加新的实现。</li><li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>比如买房，通常卖家只有房源，而卖家一般是没有房源的所以需要找到中介提供房源然后卖房。其中卖房的人就是被代理类，中介相当于代理类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sellHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Seller</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要卖房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intermediary</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IPerson person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Intermediary</span><span class="params">(IPerson person)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        person.sellHouse();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发布房源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;交易完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于JDK实现动态代理"><a href="#基于JDK实现动态代理" class="headerlink" title="基于JDK实现动态代理"></a>基于JDK实现动态代理</h4><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>还是上述的例子我们用JDK动态代理来实现(接口以及卖家代码都不变,新增代理处理类)</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkIntermediary</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">IPerson</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">IPerson</span> <span class="title function_">getInstance</span>(<span class="params">IPerson target</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">target</span> = target;</span><br><span class="line">        <span class="title class_">Class</span>&lt;?&gt; clz = target.<span class="title function_">getClass</span>();</span><br><span class="line">        <span class="keyword">return</span> (<span class="title class_">IPerson</span>)<span class="title class_">Proxy</span>.<span class="title function_">newProxyInstance</span>(clz.<span class="title function_">getClassLoader</span>(),clz.<span class="title function_">getInterfaces</span>(),<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">before</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;发布房源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">after</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;交易完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">invoke</span>(<span class="title class_">Object</span> proxy, <span class="title class_">Method</span> method, <span class="title class_">Object</span>[] args) throws <span class="title class_">Throwable</span> &#123;</span><br><span class="line">        <span class="title function_">before</span>();</span><br><span class="line">        <span class="title class_">Object</span> result = method.<span class="title function_">invoke</span>(<span class="variable language_">this</span>.<span class="property">target</span>, args);</span><br><span class="line">        <span class="title function_">after</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">IPerson</span> person = <span class="keyword">new</span> <span class="title class_">Seller</span>();</span><br><span class="line">        <span class="title class_">JdkIntermediary</span> jdkIntermediary = <span class="keyword">new</span> <span class="title class_">JdkIntermediary</span>();</span><br><span class="line">        <span class="title class_">IPerson</span> instance = jdkIntermediary.<span class="title function_">getInstance</span>(person);</span><br><span class="line">        instance.<span class="title function_">sellHouse</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去可能有些人说<code>JdkIntermediary</code>不就是代理类吗不也是在运行之前生成的吗，但是其实<code>JdkIntermediary</code>并不是代理类，它可以理解成代理处理程序我们可以断点看一下真正的代 理类是<code>$Proxy0</code>这个类是在运行时生成的。</p><p>优点：接口中新增方法不需要再像静态代理来一样每个方法都实现一遍了，维护比较方便<br>缺点：被代理类必须实现接口</p><img src="13812aba28ed4a9db14eb1b98a48fc0c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.png" alt="13812aba28ed4a9db14eb1b98a48fc0c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;"><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式使用的就是面向对象的继承和多态机制，从未实现同一行为在不同场景下具备不同实现。</p><p>通俗点将就是在我们业务逻辑中肯定有很多<code>switch case</code>或者是很多<code>if else</code>,我们的业务是需要通过场景判断选择其中一个逻辑执行，这个时候就可以使用策略模式（需要注意的是策略模式一定是只需要执行很多逻辑算法中的一个，而不是执行多个逻辑算法，如果是执行多个就不太适合使用策略模式）</p><p>总结一下：策略模式适用场景：</p><ol><li>针对一个问题有多个不同的处理方式，每种方式之间没有耦合（可以独立解决问题）</li><li>算法逻辑需要自由切换的情况下</li><li>需要屏蔽算法逻辑规则的场景（应为高层是不接触算法逻辑的实现的）</li></ol><img src="83bb6f26a4ff4e2686a60e7ebefa88cc~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.png" alt="512_0_0_0" style="zoom:67%;"><p>其中：</p><ul><li>上下文角色（Context）:主要使用来操作策略上下文，做到屏蔽高层模块对策略、算法直接访问，也可以在这里封装可能存在的变化</li><li>抽象策略角色（Strategy）:主要是规定策略或者算法的行为</li><li>具体策略角色（ConcreteStrategy）：策略或者是算法的实现</li></ul><h4 id="支付案例实现（策略设计模式）"><a href="#支付案例实现（策略设计模式）" class="headerlink" title="支付案例实现（策略设计模式）"></a>支付案例实现（策略设计模式）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String uid, String orderId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = uid;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String payType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.equals(payType, <span class="string">&quot;AliPay&quot;</span>))&#123;</span><br><span class="line">            <span class="type">AliPay</span> <span class="variable">aliPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliPay</span>();</span><br><span class="line">            <span class="type">PayContext</span> <span class="variable">payContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayContext</span>(aliPay);</span><br><span class="line">            payContext.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Objects.equals(payType, <span class="string">&quot;WeChatPay&quot;</span>))&#123;</span><br><span class="line">            <span class="type">WeChatPay</span> <span class="variable">weChatPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeChatPay</span>();</span><br><span class="line">            <span class="type">PayContext</span> <span class="variable">payContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayContext</span>(weChatPay);</span><br><span class="line">            payContext.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Objects.equals(payType, <span class="string">&quot;UnionPay&quot;</span>))&#123;</span><br><span class="line">            <span class="type">UnionPay</span> <span class="variable">unionPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionPay</span>();</span><br><span class="line">            <span class="type">PayContext</span> <span class="variable">payContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayContext</span>(unionPay);</span><br><span class="line">            payContext.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String uid,Double price)</span>&#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">currentAmount</span>  <span class="operator">=</span> queryBalance(uid);</span><br><span class="line">        <span class="keyword">if</span>(currentAmount &lt; price)&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;支付成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付宝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">900.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;银行卡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式是将链中的每一个节点看做是一个对象，每个节点处理的请求均不相同，且内部自动维护下一个节点对象，当一个请求从链式的首段发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求位置，属于行为模式。</p><p>这里需要注意的是每个节点都能对对象进行一定的处理(也可以不处理)，处理完成之后节点再进行判断还要进行后续处理还是说传递给下一个节点。</p><p>首先举一个日常的例子，比如我们申请开发票，首先我们要写好报销单，首先要你的部门领导审批，部门领导审批不通过直接打回，审批通过再由公司的总经理审批这里审批通过才算成审批完成。这种情况就很适合使用责任链模式。</p><p>总结一下责任链主要适用一下几种情况：</p><ol><li>多个对象可以处理同一个请求，但是具体由那个对象处理完成则在运行时决定。</li><li>不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li></ol><img src="5555afc019f84091aa585a5e27484910~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="5555afc019f84091aa585a5e27484910~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;"><p>通过类图可以看到总共包含以下角色：</p><ul><li>抽象处理者：主要是定义处理请求的方法以及维护下一个处理结点的对象的引用</li><li>具体处理者：处理的具体实现</li></ul><p>首先创建抽象类规定抽象方法以及维护下一个节点</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是创建多个实现逻辑的节点对象:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidatedHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(user.getUsername() == <span class="literal">null</span> || user.getPassword() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;账户或者密码为null&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.next.doHandler(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryUserInfo(user);</span><br><span class="line">        <span class="keyword">if</span>(user.getRoleName() == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到用户&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.next.doHandler(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">queryUserInfo</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.equals(user.getUsername(), <span class="string">&quot;土豆&quot;</span>) &amp;&amp; Objects.equals(user.getPassword(), <span class="string">&quot;666666&quot;</span>)) &#123;</span><br><span class="line">            user.setRoleName(<span class="string">&quot;超管&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Objects.equals(user.getUsername(), <span class="string">&quot;土豆2号&quot;</span>) &amp;&amp; Objects.equals(user.getPassword(), <span class="string">&quot;666666&quot;</span>))&#123;</span><br><span class="line">            user.setRoleName(<span class="string">&quot;普通员工&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Objects.equals(user.getRoleName(), <span class="string">&quot;超管&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;登入成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;土豆&quot;</span>,<span class="string">&quot;666666&quot;</span>);</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">validatedHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValidatedHandler</span>();</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">userHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserHandler</span>();</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">authHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthHandler</span>();</span><br><span class="line">    validatedHandler.setNext(userHandler);</span><br><span class="line">    userHandler.setNext(authHandler);</span><br><span class="line">    validatedHandler.doHandler(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><blockquote><p>门面模式，是指提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使得子系统更容易使用。</p></blockquote><img src="e5d4180f5ddc475ea572241f53e9a40a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="e5d4180f5ddc475ea572241f53e9a40a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;"><p>主要角色有：</p><ol><li>外观角色（Facade）:也称门面角色，系统对外的统一接口</li><li>子系统角色（SubSystem）:可以同时有一个或者多个SubSystem，SubSystem并不知道Facade的存在，Facade对于SubSystem而言仅仅只是一个客户端</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SystemA</span> <span class="variable">systemA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemA</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SystemB</span> <span class="variable">systemB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SystemC</span> <span class="variable">systemC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemC</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        systemA.doSomething();</span><br><span class="line">        systemB.doSomething();</span><br><span class="line">        systemC.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用A系统&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用B系统&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用C系统&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        facade.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="门面模式应用场景"><a href="#门面模式应用场景" class="headerlink" title="门面模式应用场景"></a>门面模式应用场景</h4><ol><li>对分层结构系统构建时，使用门面模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外门面模式可以为系统设计一个简单的接口供外界访问</li><li>当客户端与多个子系统之间存在很大的联系时，引入门面模式可将它们分离，从而提高子系统的独立性和可移植性</li></ol><h4 id="门面模式优缺点"><a href="#门面模式优缺点" class="headerlink" title="门面模式优缺点"></a>门面模式优缺点</h4><p>优点：</p><ol><li>简化了调用过程，无需深入了解子系统</li><li>减少系统依赖</li><li>更好的划分层次</li><li>遵循迪米特法则</li></ol><p>缺点：</p><ol><li>不符合开闭原则</li><li>有可能出现违背单一职责原则</li></ol><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote><p>模板方法模式(Template Method Pattern）又叫模板模式，是指定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤，属于行为型设计模式。</p></blockquote><img src="11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/fd77cdf01287446dbbb4123e45e8eea5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class title="fd77cdf01287446dbbb4123e45e8eea5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"><p>具体代码实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">step3</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        <span class="keyword">if</span>(hookMethod())&#123;</span><br><span class="line">            step3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreateTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">step3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreateTemplate</span> <span class="variable">concreateTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreateTemplate</span>();</span><br><span class="line">        concreateTemplate.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是这个<code>hookMethod</code>钩子函数可有可无，设计钩子方法的主要目的是用来干预执行流程，使得我们控制行为流程更加灵活，更符合实际业务的需求。钩子方法的返回值一般为适合条件分支语句的返回值（如 boolean、 int等）。具体可以根据自己的业务场景来决定是否需要使用钩子方法</p><p>我们封装一下rocketmq发送下消息的流程，rocketmq的流程是比较固定的，大致分为三步，启动生产者、发送消息、关闭应用程序，我们可以吧这三步固定在抽象类中，让子类去实现：</p><p>抽象模板：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RocketMQProducerTemplate</span> &#123;</span><br><span class="line">    DefaultMQProducer producer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RocketMQProducerTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.producer = <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;tudou1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        start();</span><br><span class="line">        send(message);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerA</span> <span class="keyword">extends</span> <span class="title class_">RocketMQProducerTemplate</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;TestA&quot;</span>, message.getBytes());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.producer.send(msg);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板方法优缺点"><a href="#模板方法优缺点" class="headerlink" title="模板方法优缺点"></a>模板方法优缺点</h3><p>优点：</p><ol><li>利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。</li><li>将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。</li><li>把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。</li></ol><p>缺点：</p><ol><li>类的个数增加，应为每种逻辑都需要新增一个实现类</li><li>系统复杂度增加</li><li>如果父类新增抽象方法，子类都需要实现一遍</li></ol><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote><p>迭代器模式 （Iterator Pattern）又称为游标模式(Cursor Pattern)，它提供一种顺序访问集合&#x2F; 容器对象元素的方法，而又无须暴露集合内部表示(到底是列表、栈还是树等)。迭代器模式可以为不同的容器提供一致的 遍历行为，而不用关心容器内容元素组成结构，属于行为型模式。</p></blockquote><img src="11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/94fa013a840949a68a5541a00840a3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" class title="94fa013a840949a68a5541a00840a3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"><p>实现代码如下（这里使用的集合是list,也可以使用其他集合这里就不一一展示了）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(cursor++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size() &gt; cursor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;User&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">IAggregate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.remove(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;User&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>&lt;&gt;(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三3&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三4&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三5&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三6&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三7&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">ConcreteAggregate</span> <span class="variable">concreteAggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>();</span><br><span class="line">        concreteAggregate.add(user1);</span><br><span class="line">        concreteAggregate.add(user2);</span><br><span class="line">        concreteAggregate.add(user3);</span><br><span class="line">        concreteAggregate.add(user4);</span><br><span class="line">        concreteAggregate.add(user5);</span><br><span class="line">        concreteAggregate.add(user6);</span><br><span class="line">        concreteAggregate.add(user7);</span><br><span class="line">        Iterator&lt;User&gt; iterator = concreteAggregate.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器模式的优缺点"><a href="#迭代器模式的优缺点" class="headerlink" title="迭代器模式的优缺点"></a>迭代器模式的优缺点</h3><p>优点：</p><ol><li>多态迭代：为不同的聚合结构提供一致的遍历接口，即一个迭代接口可以访问不同的集合对象</li><li>简化集合对象接口：迭代器模式将集合对象本身应该提供的元索迭代接口抽取到了迭代器 中，使集合对象无须关心具体迭代行为</li><li>元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使的同种元素聚 合结构可以有不同的迭代行为；</li><li>解耦迭代与集合：迭代器模式封装了具体的迭代算法，迭代算法的变化，不会影响到集合 对象的架构</li></ol><p>缺点：<br> 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐。</p><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作</p></blockquote><p>命令模式( Command Pattern) 是对命令的封装，每一个命令都是一个操作：请求的一方 发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式解耦了请求方和接 收方，请求方只需请求执行命令，不用关心命令是怎样被接收，怎样被操作以及是否被执行⋯等。<br>命令模式属于行为型模式。</p><h3 id="命令模式的应用层场景"><a href="#命令模式的应用层场景" class="headerlink" title="命令模式的应用层场景"></a>命令模式的应用层场景</h3><p>当系统的某项操作具备命令语义时，且命令实现不稳定（变化），那么可以通过命令模式解 耦请求与实现，利用抽象命令接口使请求方代码架构稳定，封装接收方具体命令实现细节。接 收方与抽象命令接口呈现弱耦合（内部方法无需一致），具备良好的扩展性。命令模式适用于 以下应用场景：</p><ol><li>现实语义中具备 “命令”的操作（如命令菜单，shell 命令⋯）；</li><li>请求调用者和请求的接收者需要解耦，使得调用者和接收者不直接交互；</li><li>需要抽象出等待执行的行为，比如撤销(Undo)操作和恢复(Redo)等操作；</li><li>需要支持命令宏（即命令组合操作）。</li></ol><img src="fd026f9b958a4e0087c6d42c65223fd7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="fd026f9b958a4e0087c6d42c65223fd7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;"><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收方接收到命令并执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICommand command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(ICommand command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteCommand</span> <span class="variable">concreteCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(<span class="keyword">new</span> <span class="title class_">Receiver</span>());</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(concreteCommand);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的类图中就可以发现<code>Invoker</code>和<code>Receiver</code>是没有耦合的，<code>Invoker</code>通过<code>Command</code>和<code>Receiver</code>建立联系的，这里 <code>Invoker</code>就相当于我们平时写业务中的一个业务逻辑的实现，你可以理解成是一个 <code>service</code>,而 <code>Receiver</code>相当于这个业务中的具体某个功能的实现，如果此时业务的需求需要变动，此时我们只需要更改<code>Command</code>中<code>Receiver</code>的应用或者为了符合开闭原则我们完全可以重新创建一个<code>Command</code>,对应者新的<code>Receiver</code>即可，这样对该对于我们整体的业务逻辑是没有改动的。</p><p>同时也可以结合装饰器模式，在原有的功能基础上增加一些其他的功能比如日志的收集等等，如果命令不是一个单独的命令而是一个命令的集合 <code>Command</code>会对应着多个命令，同时 <code>Receiver</code>也对应这多个方法，如果能对 <code>Receiver</code>进行抽象，这不就演变成了桥接模式，变成了command和Receiver两个变化的维度，这样扩展性更好</p><h3 id="命令模式优缺点"><a href="#命令模式优缺点" class="headerlink" title="命令模式优缺点"></a>命令模式优缺点</h3><p>优点：</p><ol><li>通过引入中间件（抽象接口），解耦了命令请求与实现；</li><li>扩展性良好，可以很容易地增加新命令；</li><li>支持组合命令，支持命令队列；</li><li>可以在现有命令的基础上，增加额外功能（比如日志记录…，结合装饰器模式更酸爽）。</li></ol><p>缺点：</p><ol><li>具体命令类可能过多；</li><li>命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构，解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难（不过这 也是设计模式带来的一个通病，抽象必然会引入额外类型；抽象肯定比紧密难理解）。</li></ol><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>观察者模式(Observer Pattern），又叫发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图 Model&#x2F;View ） 模式、源-监听器（Source&#x2F;Listener）模式或从属者(Dependents）模式。定义一种一对多的依赖关系，一个主题对象可被多个观察者对象同时监听，使得每当主题对象状态变化时，所有依赖于它的对象都会得到通知并被自动更新。属于行为型模式。</p><p>ex：比如MQ、异步队列</p></blockquote><p>以下几点适合该模式</p><p>1.当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面</p><p>2.其他一个或多个对象的变化依赖于另一个对象的变化</p><p>3.实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收广播</p><p>4.多层次嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知</p><img src="观察者模式.webp" alt="观察者模式" style="zoom:67%;"><p>具体代码如下： 首先是被观察者它主要的功能是：</p><ol><li>一个目标可以被多个观察者观察</li><li>目标提供对观察者注册和退订的维护</li><li>当目标的状态发生变化时，目标负责通知所有注册的、有效的观察者</li></ol><p><code>ISubject</code>它的主要作用就是定义接口（主要是订阅和取消订阅以及通知的接口）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISubject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(IObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(IObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是具体的被观察对象<code>ConcreteSubject</code>这里主要实现具体方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">ISubject</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;IObserver&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(IObserver observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(IObserver observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (IObserver observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是观察者，观察者的功能就比较少了就是实现方法等待被通知</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">IObserver</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被观察者更新了数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后再看一下客户端的使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ISubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        <span class="type">IObserver</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();</span><br><span class="line">        subject.attach(observer);</span><br><span class="line">        subject.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h3><p>优点：</p><ol><li>观察者和被观察者是松耦合（抽象耦合）的，符合依赖倒置原则</li><li>分离了表示层（观察者） 和数据逻辑层（被观察者），并且建立了一套触发机制，使得数据的变 化可以响应到多个表示层上；</li><li>实现了一对多的通讯机制，支持事件注册机制，支持兴趣分发机制，当被观察者触发事件时，只 有感兴趣的观察者可以接收到通知。</li></ol><p>缺点：</p><ol><li>如果观察者数量过多，则事件通知会耗时较长；</li><li>事件通知呈线性关系，如果其中一个观察者处理事件卡壳，会影响后续的观察者接收该事件；</li><li>如果观察者和被观察者之间存在循环依赖，则可能造成两者之间的循环调用，导致系统崩溃。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
