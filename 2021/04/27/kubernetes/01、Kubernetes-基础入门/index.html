<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Miller | Miller</title><meta name="author" content="Miller"><meta name="copyright" content="Miller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、Kubernetes简介1、背景1、部署方式的变迁   传统部署时代： 在物理服务器上运行应用程序 无法为应用程序定义资源边界 导致资源分配问题     例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本">
<meta property="og:type" content="article">
<meta property="og:title" content="Miller">
<meta property="og:url" content="https://dongxiaopipi.github.io/2021/04/27/kubernetes/01%E3%80%81Kubernetes-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Miller">
<meta property="og:description" content="一、Kubernetes简介1、背景1、部署方式的变迁   传统部署时代： 在物理服务器上运行应用程序 无法为应用程序定义资源边界 导致资源分配问题     例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png">
<meta property="article:published_time" content="2021-04-27T07:16:28.000Z">
<meta property="article:modified_time" content="2024-06-04T03:06:26.407Z">
<meta property="article:author" content="Miller">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dongxiaopipi.github.io/2021/04/27/kubernetes/01%E3%80%81Kubernetes-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Miller","link":"链接: ","source":"来源: Miller","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Miller',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-04 11:06:26'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Miller"><span class="site-name">Miller</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-27T07:16:28.000Z" title="发表于 2021-04-27 15:16:28">2021-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-04T03:06:26.407Z" title="更新于 2024-06-04 11:06:26">2024-06-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="一、Kubernetes简介"><a href="#一、Kubernetes简介" class="headerlink" title="一、Kubernetes简介"></a>一、Kubernetes简介</h1><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><h1 id="1、部署方式的变迁"><a href="#1、部署方式的变迁" class="headerlink" title="1、部署方式的变迁"></a>1、部署方式的变迁</h1>

<ul>
<li><strong>传统部署时代：</strong><ul>
<li>在物理服务器上运行应用程序</li>
<li>无法为应用程序定义资源边界</li>
<li>导致资源分配问题</li>
</ul>
</li>
</ul>
<p> 例如，如果在物理服务器上运行多个应用程序，则可能会出现一个应用程序占用大部分资源的情况， 结果可能导致其他应用程序的性能下降。 一种解决方案是在不同的物理服务器上运行每个应用程序，但是由于资源利用不足而无法扩展， 并且维护许多物理服务器的成本很高。</p>
<ul>
<li><strong>虚拟化部署时代：</strong><ul>
<li>作为解决方案，引入了虚拟化</li>
<li>虚拟化技术允许你在单个物理服务器的 CPU 上运行多个虚拟机（VM）</li>
<li>虚拟化允许应用程序在 VM 之间隔离，并提供一定程度的安全</li>
<li>一个应用程序的信息 不能被另一应用程序随意访问。</li>
<li>虚拟化技术能够更好地利用物理服务器上的资源</li>
<li>因为可轻松地添加或更新应用程序 ，所以可以实现更好的可伸缩性，降低硬件成本等等。</li>
<li>每个 VM 是一台完整的计算机，在虚拟化硬件之上运行所有组件，包括其自己的操作系统。</li>
</ul>
</li>
</ul>
<p>缺点：虚拟层冗余导致的资源浪费与性能下降</p>
<ul>
<li><strong>容器部署时代：</strong><ul>
<li>容器类似于 VM，但可以在应用程序之间共享操作系统（OS）。 </li>
<li>容器被认为是轻量级的。</li>
<li>容器与 VM 类似，具有自己的文件系统、CPU、内存、进程空间等。 </li>
<li>由于它们与基础架构分离，因此可以跨云和 OS 发行版本进行移植。</li>
<li><em><u><strong>参照【Docker隔离原理- namespace 6项隔离（资源隔离）与 cgroups 8项资源限制（资源限制）】</strong></u></em></li>
</ul>
</li>
</ul>
<p>裸金属：真正的物理服务器</p>
<p><strong>容器优势：</strong></p>
<ul>
<li><strong>敏捷性：</strong>敏捷应用程序的创建和部署：与使用 VM 镜像相比，提高了容器镜像创建的简便性和效率。</li>
<li><strong>及时性：</strong>持续开发、集成和部署：通过快速简单的回滚（由于镜像不可变性），支持可靠且频繁的 容器镜像构建和部署。</li>
<li><strong>解耦性：</strong>关注开发与运维的分离：在构建&#x2F;发布时创建应用程序容器镜像，而不是在部署时。 从而将应用程序与基础架构分离。</li>
<li><strong>可观测性：</strong>可观察性不仅可以显示操作系统级别的信息和指标，还可以显示应用程序的运行状况和其他指标信号。</li>
<li><strong>跨平台：</strong>跨开发、测试和生产的环境一致性：在便携式计算机上与在云中相同地运行。</li>
<li><strong>可移植：</strong>跨云和操作系统发行版本的可移植性：可在 Ubuntu、RHEL、CoreOS、本地、 Google Kubernetes Engine 和其他任何地方运行。</li>
<li><strong>简易性：</strong>以应用程序为中心的管理：提高抽象级别，从在虚拟硬件上运行 OS 到使用逻辑资源在 OS 上运行应用程序。</li>
<li><strong>大分布式：</strong>松散耦合、分布式、弹性、解放的微服务：应用程序被分解成较小的独立部分， 并且可以动态部署和管理 - 而不是在一台大型单机上整体运行。</li>
<li><strong>隔离性：</strong>资源隔离：可预测的应用程序性能。</li>
<li><strong>高效性：</strong>资源利用：高效率和<strong>高密度</strong></li>
</ul>
<p>K8S之前：</p>
<p>10台服务器：25+15中间件</p>
<p>K8S之后：</p>
<p>10台服务器：上百个应用了。</p>
<p>k8s管理10几台服务器。资源规划。</p>
<h3 id="2、容器化问题"><a href="#2、容器化问题" class="headerlink" title="2、容器化问题"></a>2、容器化问题</h3><ul>
<li>弹性的容器化应用管理</li>
<li>强大的故障转移能力</li>
<li>高性能的负载均衡访问机制</li>
<li>便捷的扩展</li>
<li>自动化的资源监测</li>
<li>……</li>
</ul>
<p>docker swarm：大规模进行容器编排</p>
<p>mesos：apache</p>
<p>Kubernetes : google；</p>
<p>竞品： Kubernetes 胜利</p>
<h3 id="3、为什么用-Kubernetes"><a href="#3、为什么用-Kubernetes" class="headerlink" title="3、为什么用 Kubernetes"></a>3、为什么用 Kubernetes</h3><p>容器是打包和运行应用程序的好方式。在生产环境中，你需要管理运行应用程序的容器，并确保不会停机。 例如，如果一个容器发生故障，则需要启动另一个容器。如果系统处理此行为，会不会更容易？</p>
<p>这就是 Kubernetes 来解决这些问题的方法！ Kubernetes 为你提供了一个可弹性运行分布式系统的框架。linux之上的一个服务编排框架；</p>
<p> Kubernetes 会满足你的扩展要求、故障转移、部署模式等。 例如，Kubernetes 可以轻松管理系统的 Canary 部署。</p>
<p>Kubernetes 为你提供：</p>
<ul>
<li><p><strong>服务发现和负载均衡</strong></p>
<p>Kubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。</p>
</li>
<li><p><strong>存储编排</strong></p>
<p>Kubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。</p>
</li>
<li><p><strong>自动部署和回滚</strong></p>
<p>你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p>
</li>
<li><p><strong>自动完成装箱计算</strong></p>
<p>Kubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。</p>
</li>
<li><p><strong>自我修复</strong></p>
<p>Kubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。</p>
</li>
<li><p><strong>密钥与配置管理</strong></p>
<p>Kubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥</p>
</li>
<li><p>…….</p>
</li>
</ul>
<p><strong>为了生产环境的容器化大规模应用编排，必须有一个自动化的框架。系统</strong></p>
<h3 id="4、市场份额"><a href="#4、市场份额" class="headerlink" title="4、市场份额"></a>4、市场份额</h3><h4 id="1、容器化"><a href="#1、容器化" class="headerlink" title="1、容器化"></a>1、容器化</h4><p>docker swarm</p>




<h4 id="2、服务编排"><a href="#2、服务编排" class="headerlink" title="2、服务编排"></a>2、服务编排</h4>







<p>google — kubernetes — 发起cncf — 众多的项目辅佐 kubernetes —- kubernetes +cncf其他软件 &#x3D; 整个大型云平台</p>
<h2 id="2、简介"><a href="#2、简介" class="headerlink" title="2、简介"></a>2、简介</h2><p>Kubernetes 是一个可移植的、可扩展的<strong>开源</strong>平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。</p>
<p>名称 <strong>Kubernetes</strong> 源于希腊语，意为“舵手”或“飞行员”。Google 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 <a target="_blank" rel="noopener" href="https://research.google/pubs/pub43438">Google 在大规模运行生产工作负载方面拥有十几年的经验</a> 的基础上，结合了社区中最好的想法和实践。</p>
<h3 id="1、Kubernetes不是什么"><a href="#1、Kubernetes不是什么" class="headerlink" title="1、Kubernetes不是什么"></a>1、Kubernetes不是什么</h3><ul>
<li>Kubernetes 不是传统的、包罗万象的 PaaS（平台即服务）系统。 </li>
<li>Kubernetes 在容器级别而不是在硬件级别运行</li>
<li>它提供了 PaaS 产品共有的一些普遍适用的功能， 例如部署、扩展、负载均衡、日志记录和监视。 </li>
<li>但是，Kubernetes 不是单体系统，默认解决方案都是可选和可插拔的。 Kubernetes 提供了构建开发人员平台的基础，但是在重要的地方保留了用户的选择和灵活性。</li>
</ul>
<p>Kubernetes：</p>
<ul>
<li><p><strong>不限制支持的应用程序类型</strong>。 Kubernetes 旨在支持极其多种多样的工作负载，包括无状态、有状态和数据处理工作负载。 如果应用程序可以在容器中运行，那么它应该可以在 Kubernetes 上很好地运行。</p>
</li>
<li><p><strong>不部署源代码</strong>，也不构建你的应用程序。 <strong>持续集成(CI)、交付和部署（CI&#x2F;CD）</strong>工作流取决于组织的文化和偏好以及技术要求。</p>
</li>
<li><p><strong>不提供应用程序级别的服务作为内置服务</strong>，例如中间件（例如，消息中间件）、 数据处理框架（例如，Spark）、数据库（例如，mysql）、缓存、集群存储系统 （例如，Ceph）。这样的组件可以在 Kubernetes 上运行，并且&#x2F;或者可以由运行在 Kubernetes 上的应用程序通过可移植机制（例如， <a target="_blank" rel="noopener" href="https://openservicebrokerapi.org/">开放服务代理</a>）来访问。</p>
</li>
<li><p><strong>不要求日志记录、监视或警报解决方案</strong>。 它提供了一些集成作为概念证明，并提供了收集和导出指标的机制。</p>
</li>
<li><p><strong>不提供或不要求配置语言&#x2F;系统</strong>（例如 jsonnet），它提供了<strong>声明性 API</strong>， 该声明性 API 可以由任意形式的声明性规范所构成。RESTful；写yaml文件</p>
</li>
<li><p>不提供也不采用任何全面的机器配置、维护、管理或自我修复系统。</p>
</li>
<li><p>此外，Kubernetes 不仅仅是一个编排系统，实际上它消除了编排的需要。 编排的技术定义是执行已定义的工作流程：首先执行 A，然后执行 B，再执行 C。 相比之下，Kubernetes 包含一组独立的、可组合的控制过程， 这些过程连续地将当前状态驱动到所提供的所需状态。 如何从 A 到 C 的方式无关紧要，也不需要集中控制，这使得系统更易于使用 且功能更强大、系统更健壮、更为弹性和可扩展。</p>
</li>
</ul>
<p>容器管家：</p>
<p>安装了很多应用。  	 ————————-  qq电脑管家。（自动杀垃圾，自动卸载没用东西….）</p>
<p>机器上有很多容器。 ————————–  kubernete容器的管家。（容器的启动停止、故障转义、负载均衡等）</p>
<h1 id="二、Kubernetes安装"><a href="#二、Kubernetes安装" class="headerlink" title="二、Kubernetes安装"></a>二、Kubernetes安装</h1><h2 id="1、集群原理"><a href="#1、集群原理" class="headerlink" title="1、集群原理"></a>1、集群原理</h2><p>集群：</p>
<p>主从：</p>
<ul>
<li>主从同步&#x2F;复制  ;mysql 主  – mysql 从</li>
<li>主管理从   v</li>
</ul>
<p>分片（数据集群）：</p>
<ul>
<li>大家都一样</li>
<li>每个人存一部分东西</li>
</ul>
<h3 id="1、master-node-架构"><a href="#1、master-node-架构" class="headerlink" title="1、master-node 架构"></a>1、master-node 架构</h3><p>11000台机器</p>
<p>地主+奴隶</p>
<p>地（机器）</p>
<p>奴隶（在机器上干活）</p>
<p>master：主节点（地主）。可能有很多（多人控股公司）</p>
<p>node：work节点（工作节点）。 很多。真正干应用的活</p>


<blockquote>
<p>master 和 worker怎么交互</p>
<p>master决定worker里面都有什么</p>
<p>worker只是和master （API） 通信；  每一个节点自己干自己的活</p>
</blockquote>
<p>程序员使用UI或者CLI操作k8s集群的master，就可以知道整个集群的状况。</p>
<h3 id="2、工作原理"><a href="#2、工作原理" class="headerlink" title="2、工作原理"></a>2、工作原理</h3>

<blockquote>
<p>master节点（Control Plane【控制面板】）：master节点控制整个集群</p>
<p>master节点上有一些核心组件：</p>
<ul>
<li>Controller  Manager：控制管理器</li>
<li>etcd：键值数据库（redis）【记账本，记事本】</li>
<li>scheduler：调度器</li>
<li>api server：api网关（所有的控制都需要通过api-server）</li>
</ul>
<p>node节点（worker工作节点）：</p>
<ul>
<li>kubelet（监工）：每一个node节点上必须安装的组件。</li>
<li>kube-proxy：代理。代理网络</li>
</ul>
<p>部署一个应用？</p>
<p>程序员：调用CLI告诉master，我们现在要部署一个tomcat应用</p>
<ul>
<li>程序员的所有调用都先去master节点的网关api-server。这是matser的唯一入口（mvc模式中的c层）</li>
<li>收到的请求先交给master的api-server。由api-server交给controller-mannager进行控制</li>
<li>controller-mannager 进行 应用部署</li>
<li>controller-mannager 会生成一次部署信息。 tomcat –image:tomcat6 –port 8080 ,真正不部署应用</li>
<li>部署信息被记录在etcd中</li>
<li>scheduler调度器从etcd数据库中，拿到要部署的应用，开始调度。看哪个节点合适，</li>
<li>scheduler把算出来的调度信息再放到etcd中</li>
<li>每一个node节点的监控kubelet，随时和master保持联系的（给api-server发送请求不断获取最新数据），所有节点的kubelet就会从master</li>
<li>假设node2的kubelet最终收到了命令，要部署。</li>
<li>kubelet就自己run一个应用在当前机器上，随时给master汇报当前应用的状态信息，分配ip</li>
<li>node和master是通过master的api-server联系的</li>
<li>每一个机器上的kube-proxy能知道集群的所有网络。只要node访问别人或者别人访问node，node上的kube-proxy网络代理自动计算进行流量转发</li>
</ul>
</blockquote>
<p>下图和上图一样的，再理解一下</p>


<p>无论访问哪个机器，都可以访问到真正应用（Service【服务】）</p>
<h3 id="3、原理分解"><a href="#3、原理分解" class="headerlink" title="3、原理分解"></a>3、原理分解</h3><h4 id="1、主节点（master）"><a href="#1、主节点（master）" class="headerlink" title="1、主节点（master）"></a>1、主节点（master）</h4>

<blockquote>
<p>快速介绍：</p>
<ul>
<li><p>master也要装kubelet和kubeproxy</p>
</li>
<li><p>前端访问（UI\CLI）：</p>
</li>
<li><p>kube-apiserver：</p>
</li>
<li><p>scheduler:</p>
</li>
<li><p>controller manager:</p>
</li>
<li><p>etcd</p>
</li>
<li><p>kubelet+kubeproxy每一个节点的必备+docker（容器运行时环境）</p>
</li>
</ul>
</blockquote>
<h4 id="2、工作节点（node）"><a href="#2、工作节点（node）" class="headerlink" title="2、工作节点（node）"></a>2、工作节点（node）</h4>

<blockquote>
<p>快速介绍：</p>
<ul>
<li>Pod：<ul>
<li>docker run 启动的是一个container（容器），<strong>容器是docker的基本单位</strong>，一个应用是一个容器</li>
<li>kubelet run 启动的一个应用称为一个Pod；<strong>Pod是k8s的基本单位。</strong><ul>
<li>Pod是容器的一个再封装</li>
<li>atguigu(永远不变)    &#x3D;&#x3D;slf4j&#x3D;    log4j(类)</li>
<li>应用 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;Pod&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; docker的容器</li>
<li>一个容器往往代表不了一个基本应用。博客（php+mysql合起来完成）</li>
<li>准备一个Pod 可以包含多个 container；一个Pod代表一个基本的应用。</li>
<li>IPod（看电影、听音乐、玩游戏）【一个基本产品，原子】；</li>
<li>Pod（music container、movie container）【一个基本产品，原子的】</li>
</ul>
</li>
</ul>
</li>
<li>Kubelet：监工，负责交互master的api-server以及当前机器的应用启停等，在master机器就是master的小助手。每一台机器真正干活的都是这个 Kubelet</li>
<li>Kube-proxy：</li>
<li><h2 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h2></li>
</ul>
</blockquote>
<h2 id="2、组件交互原理"><a href="#2、组件交互原理" class="headerlink" title="2、组件交互原理"></a>2、组件交互原理</h2>

<blockquote>
<p>想让k8s部署一个tomcat？</p>
<p>0、开机默认所有节点的kubelet、master节点的scheduler（调度器）、controller-manager（控制管理器）一直监听master的api-server发来的事件变化（for ::）</p>
<p>1、程序员使用命令行工具： kubectl ； kubectl create deploy tomcat –image&#x3D;tomcat8（告诉master让集群使用tomcat8镜像，部署一个tomcat应用）</p>
<p>2、kubectl命令行内容发给api-server，api-server保存此次创建信息到etcd</p>
<p>3、etcd给api-server上报事件，说刚才有人给我里面保存一个信息。（部署Tomcat[deploy]）</p>
<p>4、controller-manager监听到api-server的事件，是 （部署Tomcat[deploy]）</p>
<p>5、controller-manager 处理这个 （部署Tomcat[deploy]）的事件。controller-manager会生成Pod的部署信息【pod信息】</p>
<p>6、controller-manager 把Pod的信息交给api-server，再保存到etcd</p>
<p>7、etcd上报事件【pod信息】给api-server。</p>
<p>8、scheduler专门监听 【pod信息】 ，拿到 【pod信息】的内容，计算，看哪个节点合适部署这个Pod【pod调度过后的信息（node: node-02）】，</p>
<p>9、scheduler把 【pod调度过后的信息（node: node-02）】交给api-server保存给etcd</p>
<p>10、etcd上报事件【pod调度过后的信息（node: node-02）】，给api-server</p>
<p>11、其他节点的kubelet专门监听 【pod调度过后的信息（node: node-02）】 事件，集群所有节点kubelet从api-server就拿到了 【pod调度过后的信息（node: node-02）】 事件</p>
<p>12、每个节点的kubelet判断是否属于自己的事情；node-02的kubelet发现是他的事情</p>
<p>13、node-02的kubelet启动这个pod。汇报给master当前启动好的所有信息</p>
</blockquote>
<h2 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h2><h3 id="1、理解"><a href="#1、理解" class="headerlink" title="1、理解"></a>1、理解</h3><p>安装方式</p>
<ul>
<li>二进制方式（建议生产环境使用）</li>
<li>MiniKube…..</li>
<li>kubeadm引导方式（官方推荐）<ul>
<li>GA</li>
</ul>
</li>
</ul>
<p>大致流程</p>
<ul>
<li>准备N台服务器，<strong>内网互通</strong>，</li>
<li>安装Docker容器化环境【k8s放弃dockershim】</li>
<li>安装Kubernetes<ul>
<li>三台机器安装核心组件（<strong>kubeadm(创建集群的引导工具)</strong>,  <em><strong>kubelet</strong></em>，<strong>kubectl（程序员用的命令行）</strong>  ）</li>
<li>kubelet可以直接通过容器化的方式创建出之前的核心组件（api-server）【官方把核心组件做成镜像】</li>
<li>由kubeadm引导创建集群</li>
</ul>
</li>
</ul>
<h3 id="2、执行"><a href="#2、执行" class="headerlink" title="2、执行"></a>2、执行</h3><h4 id="1、准备机器"><a href="#1、准备机器" class="headerlink" title="1、准备机器"></a>1、准备机器</h4><ul>
<li>开通三台机器，内网互通，配置公网ip。centos7.8&#x2F;7.9，基础实验2c4g三台也可以</li>
<li>每台机器的hostname不要用localhost，可用k8s-01，k8s-02，k8s-03之类的【不包含下划线、小数点、大写字母】（这个后续步骤也可以做）</li>
</ul>
<h4 id="2、安装前置环境（都执行）"><a href="#2、安装前置环境（都执行）" class="headerlink" title="2、安装前置环境（都执行）"></a>2、安装前置环境（都执行）</h4><h5 id="1、基础环境"><a href="#1、基础环境" class="headerlink" title="1、基础环境"></a>1、基础环境</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment">#关闭防火墙： 如果是云服务器，需要设置安全组策略放行端口</span></span><br><span class="line"><span class="comment"># https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#check-required-ports</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 hostname</span></span><br><span class="line">hostnamectl set-hostname k8s-01</span><br><span class="line"><span class="comment"># 查看修改结果</span></span><br><span class="line">hostnamectl status</span><br><span class="line"><span class="comment"># 设置 hostname 解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;127.0.0.1   <span class="subst">$(hostname)</span>&quot;</span> &gt;&gt; /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭 selinux： </span></span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭 swap：</span></span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab </span><br><span class="line"></span><br><span class="line"><span class="comment">#允许 iptables 检查桥接流量</span></span><br><span class="line"><span class="comment">#https://kubernetes.io/zh/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#%E5%85%81%E8%AE%B8-iptables-%E6%A3%80%E6%9F%A5%E6%A1%A5%E6%8E%A5%E6%B5%81%E9%87%8F</span></span><br><span class="line"><span class="comment">## 开启br_netfilter</span></span><br><span class="line"><span class="comment">## sudo modprobe br_netfilter</span></span><br><span class="line"><span class="comment">## 确认下</span></span><br><span class="line"><span class="comment">## lsmod | grep br_netfilter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改配置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####这里用这个，不要用课堂上的配置。。。。。。。。。</span></span><br><span class="line"><span class="comment">#将桥接的 IPv4 流量传递到 iptables 的链：</span></span><br><span class="line"><span class="comment"># 修改 /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># 如果有配置，则修改</span></span><br><span class="line">sed -i <span class="string">&quot;s#^net.ipv4.ip_forward.*#net.ipv4.ip_forward=1#g&quot;</span>  /etc/sysctl.conf</span><br><span class="line">sed -i <span class="string">&quot;s#^net.bridge.bridge-nf-call-ip6tables.*#net.bridge.bridge-nf-call-ip6tables=1#g&quot;</span>  /etc/sysctl.conf</span><br><span class="line">sed -i <span class="string">&quot;s#^net.bridge.bridge-nf-call-iptables.*#net.bridge.bridge-nf-call-iptables=1#g&quot;</span>  /etc/sysctl.conf</span><br><span class="line">sed -i <span class="string">&quot;s#^net.ipv6.conf.all.disable_ipv6.*#net.ipv6.conf.all.disable_ipv6=1#g&quot;</span>  /etc/sysctl.conf</span><br><span class="line">sed -i <span class="string">&quot;s#^net.ipv6.conf.default.disable_ipv6.*#net.ipv6.conf.default.disable_ipv6=1#g&quot;</span>  /etc/sysctl.conf</span><br><span class="line">sed -i <span class="string">&quot;s#^net.ipv6.conf.lo.disable_ipv6.*#net.ipv6.conf.lo.disable_ipv6=1#g&quot;</span>  /etc/sysctl.conf</span><br><span class="line">sed -i <span class="string">&quot;s#^net.ipv6.conf.all.forwarding.*#net.ipv6.conf.all.forwarding=1#g&quot;</span>  /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 可能没有，追加</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-ip6tables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-iptables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv6.conf.all.disable_ipv6 = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv6.conf.default.disable_ipv6 = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv6.conf.lo.disable_ipv6 = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv6.conf.all.forwarding = 1&quot;</span>  &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 执行命令以应用</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################################</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2、docker环境"><a href="#2、docker环境" class="headerlink" title="2、docker环境"></a>2、docker环境</h5><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker*</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"><span class="comment">#配置docker yum 源</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment">#安装docker 19.03.9</span></span><br><span class="line">yum install -y docker-ce-3:19.03.9-3.el7.x86_64  docker-ce-cli-3:19.03.9-3.el7.x86_64 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装docker 19.03.9   docker-ce  19.03.9</span></span><br><span class="line">yum install -y docker-ce-19.03.9-3  docker-ce-cli-19.03.9 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置加速</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://82m9ar63.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>



<h4 id="3、安装k8s核心（都执行）"><a href="#3、安装k8s核心（都执行）" class="headerlink" title="3、安装k8s核心（都执行）"></a>3、安装k8s核心（都执行）</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置K8S的yum源</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载旧版本</span></span><br><span class="line">yum remove -y kubelet kubeadm kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可以安装的版本</span></span><br><span class="line">yum list kubelet --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装kubelet、kubeadm、kubectl 指定版本</span></span><br><span class="line">yum install -y kubelet-1.21.0 kubeadm-1.21.0 kubectl-1.21.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动kubelet</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>



<h4 id="4、初始化master节点（master执行）"><a href="#4、初始化master节点（master执行）" class="headerlink" title="4、初始化master节点（master执行）"></a>4、初始化master节点（master执行）</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">############下载核心镜像 kubeadm config images list：查看需要哪些镜像###########</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####封装成images.sh文件</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">  kube-apiserver:v1.21.0</span><br><span class="line">  kube-proxy:v1.21.0</span><br><span class="line">  kube-controller-manager:v1.21.0</span><br><span class="line">  kube-scheduler:v1.21.0</span><br><span class="line">  coredns:v1.8.0</span><br><span class="line">  etcd:3.4.13-0</span><br><span class="line">  pause:3.4.1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$&#123;images[@]&#125;</span> ; <span class="keyword">do</span></span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/<span class="variable">$imageName</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#####封装结束</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x images.sh &amp;&amp; ./images.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/coredns:v1.8.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##注意1.21.0版本的k8s coredns镜像比较特殊，结合阿里云需要特殊处理，重新打标签</span></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/coredns:v1.8.0 registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/coredns/coredns:v1.8.0</span><br><span class="line"></span><br><span class="line"><span class="comment">########kubeadm init 一个master########################</span></span><br><span class="line"><span class="comment">########kubeadm join 其他worker########################</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.170.11.8 \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.21.0 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"><span class="comment">## 注意：pod-cidr与service-cidr</span></span><br><span class="line"><span class="comment"># cidr 无类别域间路由（Classless Inter-Domain Routing、CIDR）</span></span><br><span class="line"><span class="comment"># 指定一个网络可达范围  pod的子网范围+service负载均衡网络的子网范围+本机ip的子网范围不能有重复域</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">######按照提示继续######</span></span><br><span class="line"><span class="comment">## init完成后第一步：复制相关文件夹</span></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment">## 导出环境变量</span></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 部署一个pod网络</span></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line">  <span class="comment">##############如下：安装calico#####################</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 命令检查</span></span><br><span class="line">kubectl get pod -A  <span class="comment">##获取集群中所有部署好的应用Pod</span></span><br><span class="line">kubectl get nodes  <span class="comment">##查看集群所有机器的状态</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 172.24.80.222:6443 --token nz9azl.9bl27pyr4exy2wz4 \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:4bdc81a83b80f6bdd30bb56225f9013006a45ed423f131ac256ffe16bae73a20 </span><br></pre></td></tr></table></figure>

<h4 id="5、初始化worker节点（worker执行）"><a href="#5、初始化worker节点（worker执行）" class="headerlink" title="5、初始化worker节点（worker执行）"></a>5、初始化worker节点（worker执行）</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 用master生成的命令即可</span></span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 172.24.80.222:6443 --token nz9azl.9bl27pyr4exy2wz4 \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:4bdc81a83b80f6bdd30bb56225f9013006a45ed423f131ac256ffe16bae73a20 </span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment">##过期怎么办</span></span><br><span class="line">kubeadm token create --print-join-command</span><br><span class="line">kubeadm token create --ttl 0 --print-join-command</span><br><span class="line">kubeadm <span class="built_in">join</span> --token y1eyw5.ylg568kvohfdsfco --discovery-token-ca-cert-hash sha256: 6c35e4f73f72afd89bf1c8c303ee55677d2cdb1342d67bb23c852aba2efc7c73</span><br></pre></td></tr></table></figure>





<h4 id="6、验证集群"><a href="#6、验证集群" class="headerlink" title="6、验证集群"></a>6、验证集群</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取所有节点</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line"><span class="comment">#给节点打标签</span></span><br><span class="line"><span class="comment">## k8s中万物皆对象。node:机器  Pod：应用容器</span></span><br><span class="line"><span class="comment">###加标签  《h1》</span></span><br><span class="line">kubectl label node k8s-02 node-role.kubernetes.io/worker=<span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="comment">###去标签</span></span><br><span class="line">kubectl label node k8s-02 node-role.kubernetes.io/worker-</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## k8s集群，机器重启了会自动再加入集群，master重启了会自动再加入集群控制中心</span></span><br></pre></td></tr></table></figure>



<h4 id="7、设置ipvs模式"><a href="#7、设置ipvs模式" class="headerlink" title="7、设置ipvs模式"></a>7、设置ipvs模式</h4><p>k8s整个集群为了访问通；默认是用iptables,性能下（kube-proxy在集群之间同步iptables的内容）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、查看默认kube-proxy 使用的模式</span></span><br><span class="line">kubectl logs -n kube-system kube-proxy-28xv4</span><br><span class="line"><span class="comment">#2、需要修改 kube-proxy 的配置文件,修改mode 为ipvs。默认iptables，但是集群大了以后就很慢</span></span><br><span class="line">kubectl edit cm kube-proxy -n kube-system</span><br><span class="line">修改如下</span><br><span class="line">   ipvs:</span><br><span class="line">      excludeCIDRs: null</span><br><span class="line">      minSyncPeriod: 0s</span><br><span class="line">      scheduler: <span class="string">&quot;&quot;</span></span><br><span class="line">      strictARP: <span class="literal">false</span></span><br><span class="line">      syncPeriod: 30s</span><br><span class="line">    kind: KubeProxyConfiguration</span><br><span class="line">    metricsBindAddress: 127.0.0.1:10249</span><br><span class="line">    mode: <span class="string">&quot;ipvs&quot;</span></span><br><span class="line"> <span class="comment">###修改了kube-proxy的配置，为了让重新生效，需要杀掉以前的Kube-proxy</span></span><br><span class="line"> kubectl get pod -A|grep kube-proxy</span><br><span class="line"> kubectl delete pod kube-proxy-pqgnt -n kube-system</span><br><span class="line"><span class="comment">### 修改完成后可以重启kube-proxy以生效</span></span><br></pre></td></tr></table></figure>



<h4 id="8、让其他客户端kubelet也能操作集群"><a href="#8、让其他客户端kubelet也能操作集群" class="headerlink" title="8、让其他客户端kubelet也能操作集群"></a>8、让其他客户端kubelet也能操作集群</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、master获取管理员配置</span></span><br><span class="line"><span class="built_in">cat</span> /etc/kubernetes/admin.conf</span><br><span class="line"><span class="comment">#2、其他节点创建保存</span></span><br><span class="line">vi ~/.kube/config</span><br><span class="line"><span class="comment">#3、重新测试使用</span></span><br></pre></td></tr></table></figure>



<h2 id="4、急速安装方式"><a href="#4、急速安装方式" class="headerlink" title="4、急速安装方式"></a>4、急速安装方式</h2><ul>
<li>1、三台机器设置自己的hostname（不能是localhost）。云厂商注意三台机器一定要通。<ul>
<li>青云需要额外设置组内互信</li>
<li>阿里云默认是通的</li>
<li>虚拟机，关闭所有机器的防火墙</li>
</ul>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 hostname;  k8s-01要变为自己的hostname</span></span><br><span class="line">hostnamectl set-hostname k8s-01</span><br><span class="line"><span class="comment"># 设置 hostname 解析</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;127.0.0.1   <span class="subst">$(hostname)</span>&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>

<ul>
<li><p>2、所有机器批量执行如下脚本</p>
</li>
<li><pre><code class="sh">#先在所有机器执行 vi k8s.sh
# 进入编辑模式（输入i），把如下脚本复制
# 所有机器给脚本权限  chmod +x k8s.sh
#执行脚本 ./k8s.sh
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```sh</span><br><span class="line">#/bin/sh</span><br><span class="line"></span><br><span class="line">#######################开始设置环境##################################### \n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf &quot;##################正在配置所有基础环境信息################## \n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf &quot;##################关闭selinux################## \n&quot;</span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br><span class="line">setenforce 0</span><br><span class="line">printf &quot;##################关闭swap################## \n&quot;</span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab </span><br><span class="line"></span><br><span class="line">printf &quot;##################配置路由转发################## \n&quot;</span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line">echo &#x27;net.ipv4.ip_forward = 1&#x27; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line"></span><br><span class="line">## 必须 ipv6流量桥接</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-ip6tables = 1&#x27; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">## 必须 ipv4流量桥接</span><br><span class="line">echo &#x27;net.bridge.bridge-nf-call-iptables = 1&#x27; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">echo &quot;net.ipv6.conf.all.disable_ipv6 = 1&quot; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">echo &quot;net.ipv6.conf.default.disable_ipv6 = 1&quot; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">echo &quot;net.ipv6.conf.lo.disable_ipv6 = 1&quot; &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">echo &quot;net.ipv6.conf.all.forwarding = 1&quot;  &gt;&gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">modprobe br_netfilter</span><br><span class="line">sudo sysctl --system</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">printf &quot;##################配置ipvs################## \n&quot;</span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules </span><br><span class="line">sh /etc/sysconfig/modules/ipvs.modules</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf &quot;##################安装ipvsadm相关软件################## \n&quot;</span><br><span class="line">yum install -y ipset ipvsadm</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf &quot;##################安装docker容器环境################## \n&quot;</span><br><span class="line">sudo yum remove docker*</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum install -y docker-ce-19.03.9  docker-ce-cli-19.03.9 containerd.io</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://82m9ar63.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf &quot;##################安装k8s核心包 kubeadm kubelet kubectl################## \n&quot;</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">###指定k8s安装版本</span><br><span class="line">yum install -y kubelet-1.21.0 kubeadm-1.21.0 kubectl-1.21.0</span><br><span class="line"></span><br><span class="line">###要把kubelet立即启动。</span><br><span class="line">systemctl enable kubelet</span><br><span class="line">systemctl start kubelet</span><br><span class="line"></span><br><span class="line">printf &quot;##################下载api-server等核心镜像################## \n&quot;</span><br><span class="line">sudo tee ./images.sh &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">#!/bin/bash</span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.21.0</span><br><span class="line">kube-proxy:v1.21.0</span><br><span class="line">kube-controller-manager:v1.21.0</span><br><span class="line">kube-scheduler:v1.21.0</span><br><span class="line">coredns:v1.8.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.4.1</span><br><span class="line">)</span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName</span><br><span class="line">done</span><br><span class="line">## 全部完成后重新修改coredns镜像</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/coredns:v1.8.0 registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/coredns/coredns:v1.8.0</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line">chmod +x ./images.sh &amp;&amp; ./images.sh</span><br><span class="line">   </span><br><span class="line">### k8s的所有基本环境全部完成</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>3、使用kubeadm引导集群（参照初始化master继续做）</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#### --apiserver-advertise-address 的地址一定写成自己master机器的ip地址</span></span><br><span class="line"><span class="comment">#### 虚拟机或者其他云厂商给你的机器ip  10.96  192.168</span></span><br><span class="line"><span class="comment">#### 以下的只在master节点执行</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.170.11.8 \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.21.0 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>4、master结束以后，按照控制台引导继续往下</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 第一步</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line"><span class="comment">##第二步</span></span><br><span class="line"><span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">##第三步 部署网络插件</span></span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##第四步，用控制台打印的kubeadm join 去其他node节点执行</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.170.11.8:6443 --token cnb7x2.lzgz7mfzcjutn0nk \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:00c9e977ee52632098aadb515c90076603daee94a167728110ef8086d0d5b37d</span><br></pre></td></tr></table></figure>

<ul>
<li>5、验证集群</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#等一会，在master节点执行</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>



<ul>
<li>6、设置kube-proxy的ipvs模式</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">##修改kube-proxy默认的配置</span></span><br><span class="line">kubectl edit cm kube-proxy -n kube-system</span><br><span class="line"><span class="comment">## 修改mode: &quot;ipvs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##改完以后重启kube-proxy</span></span><br><span class="line"><span class="comment">### 查到所有的kube-proxy</span></span><br><span class="line">kubectl get pod -n kube-system |grep kube-proxy</span><br><span class="line"><span class="comment">### 删除之前的即可</span></span><br><span class="line">kubectl delete pod 【用自己查出来的kube-proxy-dw5sf kube-proxy-hsrwp kube-proxy-vqv7n】  -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>











<h1 id="三、Kubernetes基础入门"><a href="#三、Kubernetes基础入门" class="headerlink" title="三、Kubernetes基础入门"></a>三、Kubernetes基础入门</h1><p>以下的所有都先进行基本理解，我们后来会一一详细讲解</p>
<h2 id="0、基础知识"><a href="#0、基础知识" class="headerlink" title="0、基础知识"></a>0、基础知识</h2>

<p>以上展示了一个master（主节点）和6个worker（工作节点）的k8s集群</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker run  --name hello-pod alpine  是跑一个容器，容器的粒度有点小</span></span><br><span class="line"></span><br><span class="line">kubectl run  hello-pod --image=alpine <span class="comment">#跑一个Pod。Pod里面其实也是容器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">kubectl get pod  <span class="comment">#以前的docker ps -a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 所有kubectl在master节点运行，把命令请求发给api-server。api-server一系列处理</span></span><br><span class="line"><span class="comment">##  master只负责调度，而worker node才是真正部署应用的。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>









<p>docker是每一个worker节点的运行时环境</p>
<p>kubelet负责控制所有容器的启动停止，保证节点工作正常，已经帮助节点交互master</p>
<p>master节点的关键组件：</p>
<ul>
<li>kubelet（监工）：所有节点必备的。控制这个节点所有pod的生命周期以及与api-server交互等工作</li>
<li>kube-api-server：负责接收所有请求。集群内对集群的任何修改都是通过命令行、ui把请求发给api-server才能执行的。api-server是整个集群操作对内、对外的唯一入口。不包含我们后来部署应用暴露端口的方式</li>
<li>kube-proxy：整个节点的网络流量负责</li>
<li>cri：都有容器运行时环境</li>
</ul>
<p>worker节点：</p>
<ul>
<li>kubelet（监工）：所有节点必备的。控制这个节点所有pod的生命周期以及与api-server交互等工作</li>
<li>kube-proxy：整个节点的网络流量负责</li>
<li>cri：都有容器运行时环境</li>
</ul>
<h2 id="1、部署一个应用"><a href="#1、部署一个应用" class="headerlink" title="1、部署一个应用"></a>1、部署一个应用</h2><p>创建一次部署工作。(自愈机制)</p>
<ul>
<li>kubectl create deploy xxxxxx  ：命令行会给api-server发送要部署xxx的请求</li>
<li>api-server把这个请求保存到etcd</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl create 帮我们创建k8s集群中的一些对象</span></span><br><span class="line">kubectl create --<span class="built_in">help</span></span><br><span class="line">kubectl create deployment 这次部署的名字 --image=应用的镜像</span><br><span class="line"><span class="comment">#Create a deployment named  my-nginx that runs the nginx image</span></span><br><span class="line">kubectl create deployment my-nginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">##最终在一个机器上有pod、这个pod其实本质里面就是一个容器</span></span><br><span class="line">k8s_nginx_my-nginx-6b74b79f57-snlr4_default_dbeac79e-1ce9-42c9-bc59-c8ca0412674b_0</span><br><span class="line"><span class="comment">### k8s_镜像(nginx)_pod名(my-nginx-6b74b79f57-snlr4)_容器名(default_dbeac79e-1ce9-42c9-bc59-c8ca0412674b_0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a deployment with command</span></span><br><span class="line">kubectl create deployment my-nginx --image=nginx -- <span class="built_in">date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a deployment named my-nginx that runs the nginx image with 3 replicas.</span></span><br><span class="line">kubectl create deployment my-nginx --image=nginx --replicas=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a deployment named my-nginx that runs the nginx image and expose port 80.</span></span><br><span class="line">kubectl create deployment my-nginx --image=nginx --port=80</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p> <strong>Deployment（部署）</strong></p>
<ul>
<li>在k8s中，通过发布 Deployment，可以创建应用程序 (docker image) 的实例 (docker container)，这个实例会被包含在称为 <strong>Pod</strong> 的概念中，<strong>Pod</strong> 是 k8s 中最小可管理单元。</li>
<li>在 k8s 集群中发布 Deployment 后，Deployment 将指示 k8s 如何创建和更新应用程序的实例，master 节点将应用程序实例调度到集群中的具体的节点上。</li>
<li>创建应用程序实例后，Kubernetes Deployment Controller 会持续监控这些实例。如果运行实例的 worker 节点关机或被删除，则 Kubernetes Deployment Controller 将在群集中资源最优的另一个 worker 节点上重新创建一个新的实例。<strong>这提供了一种自我修复机制来解决机器故障或维护问题。</strong></li>
<li>在容器编排之前的时代，各种安装脚本通常用于启动应用程序，但是不能够使应用程序从机器故障中恢复。通过创建应用程序实例并确保它们在集群节点中的运行实例个数，Kubernetes Deployment 提供了一种完全不同的方式来管理应用程序。</li>
<li>Deployment 处于 master 节点上，通过发布 Deployment，master 节点会选择合适的 worker 节点创建 Container（即图中的正方体），Container 会被包含在 Pod （即蓝色圆圈）里。</li>
</ul>
</blockquote>


<p>自愈：针对使用Deployment等部署的应用。</p>
<p>kubectl run ：直接启动一个pod； 不会产生一次部署信息。所以删除就没</p>
<p>kubectl create deploy： <strong>启动一个Pod</strong>，以及<strong>记录这次部署信息</strong>。所以，这个pod即使挂了，这次部署信息有，就会强制同步到这次部署信息期望的最终结果；kubectl get deploy,pod 都有内容</p>
<h2 id="2、应用程序探索"><a href="#2、应用程序探索" class="headerlink" title="2、应用程序探索"></a>2、应用程序探索</h2><ul>
<li>了解Kubernetes Pods（容器组）</li>
<li>了解Kubernetes Nodes（节点）</li>
<li>排查故障</li>
</ul>
<p>创建 Deployment 后，k8s创建了一个 <strong>Pod（容器组）</strong> 来放置应用程序实例（container 容器）。</p>


<h3 id="1、了解Pod"><a href="#1、了解Pod" class="headerlink" title="1、了解Pod"></a>1、了解Pod</h3><p><strong>Pod （容器组）</strong> 是一个k8s中一个抽象的概念，用于存放一组 container（可包含一个或多个 container 容器，即图上正方体)，以及这些 container （容器）的一些共享资源。这些资源包括：</p>
<ul>
<li>共享存储，称为卷(Volumes)，即图上紫色圆柱</li>
<li>网络，每个 Pod（容器组）在集群中有个唯一的 IP，pod（容器组）中的 container（容器）共享该IP地址</li>
<li>container（容器）的基本信息，例如容器的镜像版本，对外暴露的端口等</li>
</ul>
<p><strong>Pod（容器组）是 k8s 集群上的最基本的单元</strong>。当我们在 k8s 上创建 Deployment 时，会在**集群上创建包含容器的 Pod (而不是直接创建容器)**。每个Pod都与运行它的 worker 节点（Node）绑定，并保持在那里直到终止或被删除。如果节点（Node）发生故障，则会在群集中的其他可用节点（Node）上运行相同的 Pod（从同样的镜像创建 Container，使用同样的配置，IP 地址不同，Pod 名字不同）。</p>
<blockquote>
<p>TIP</p>
<p>重要：</p>
<ul>
<li>Pod 是一组容器（可包含一个或多个应用程序容器），以及共享存储（卷 Volumes）、IP 地址和有关如何运行容器的信息。</li>
<li>如果多个容器紧密耦合并且需要共享磁盘等资源，则他们应该被部署在同一个Pod（容器组）中。</li>
</ul>
</blockquote>
<h3 id="2、了解Node"><a href="#2、了解Node" class="headerlink" title="2、了解Node"></a>2、了解Node</h3><p><strong>Pod（容器组）</strong>总是在 <strong>Node（节点）</strong> 上运行。Node（节点）是 kubernetes 集群中的计算机，可以是虚拟机或物理机。每个 Node（节点）都由 master 管理。一个 Node（节点）可以有多个Pod（容器组），kubernetes master 会根据每个 Node（节点）上可用资源的情况，自动调度 Pod（容器组）到最佳的 Node（节点）上。</p>
<p>每个 Kubernetes Node（节点）至少运行：</p>
<ul>
<li>Kubelet，负责 master 节点和 worker 节点之间通信的进程；管理 Pod（容器组）和 Pod（容器组）内运行的 Container（容器）。</li>
<li>kube-proxy，负责进行流量转发</li>
<li>容器运行环境（如Docker）负责下载镜像、创建和运行容器等。</li>
</ul>


<p>Kubelet启动的Pod每个都有Ip，全集群任意位置均可访问</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=10.170.11.8 \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.21.0 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"></span><br><span class="line">--pod-network-cidr=192.168.0.0/16：pod 的ip范围</span><br><span class="line"></span><br><span class="line">calico：网络组件:</span><br><span class="line">【扁平化网络】</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、故障排除"><a href="#3、故障排除" class="headerlink" title="3、故障排除"></a>3、故障排除</h3><ul>
<li><p><strong>kubectl get</strong> - 显示资源列表</p>
<ul>
<li><pre><code class="sh"># kubectl get 资源类型

#获取类型为Deployment的资源列表
kubectl get deployments

#获取类型为Pod的资源列表
kubectl get pods

#获取类型为Node的资源列表
kubectl get nodes
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```sh</span><br><span class="line">  # 查看所有名称空间的 Deployment</span><br><span class="line">  kubectl get deployments -A</span><br><span class="line">  kubectl get deployments --all-namespaces</span><br><span class="line">  # 查看 kube-system 名称空间的 Deployment</span><br><span class="line">  kubectl get deployments -n kube-system</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="sh">#####并不是所有的对象都在名称空间中

# 在名称空间里
kubectl api-resources --namespaced=true

# 不在名称空间里
kubectl api-resources --namespaced=false
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **kubectl describe** - 显示有关资源的详细信息</span><br><span class="line"></span><br><span class="line">  - ```sh</span><br><span class="line">    # kubectl describe 资源类型 资源名称</span><br><span class="line">    </span><br><span class="line">    #查看名称为nginx-XXXXXX的Pod的信息</span><br><span class="line">    kubectl describe pod nginx-XXXXXX	</span><br><span class="line">    </span><br><span class="line">    #查看名称为nginx的Deployment的信息</span><br><span class="line">    kubectl describe deployment my-nginx	</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>kubectl logs</strong> - 查看pod中的容器的打印日志（和命令docker logs 类似）</p>
<ul>
<li><pre><code class="sh"># kubectl logs Pod名称

#查看名称为nginx-pod-XXXXXXX的Pod内的容器打印的日志
#本案例中的 nginx-pod 没有输出日志，所以您看到的结果是空的
kubectl logs -f nginx-pod-XXXXXXX
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- **kubectl exec** - 在pod中的容器环境内执行命令(和命令docker exec 类似)</span><br><span class="line"></span><br><span class="line">  - ```sh</span><br><span class="line">    # kubectl exec Pod名称 操作命令</span><br><span class="line">    </span><br><span class="line">    # 在名称为nginx-pod-xxxxxx的Pod中运行bash</span><br><span class="line">    kubectl exec -it nginx-pod-xxxxxx /bin/bash</span><br><span class="line">    </span><br><span class="line">    ### 注意：新版1.21.0 提示这个命令会过期</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="4、kubectl-run"><a href="#4、kubectl-run" class="headerlink" title="4、kubectl run"></a>4、kubectl run</h3><p>也可以独立跑一个Pod</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## kubectl run --help</span></span><br><span class="line">kubectl run nginx --image=nginx</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl create 资源  <span class="comment">#创建任意资源</span></span><br><span class="line">kubectl create deploy <span class="comment">#创建部署</span></span><br><span class="line">kubectl run <span class="comment">#只创建一个Pod</span></span><br><span class="line">kubectl get 资源名(node/pod/deploy) -n xxx（指定名称空间，默认是default） <span class="comment">#获取资源</span></span><br><span class="line">kubectl describe  资源名(node/pod/deploy)  xxx <span class="comment">#描述某个资源的详细信息</span></span><br><span class="line">kubectl logs 资源名 <span class="comment">##查看日志</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it pod名 -- 命令  <span class="comment">#进pod并执行命令</span></span><br><span class="line">kubectl delete 资源名(node/pod/deploy) xxx  <span class="comment">#删除资源</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3、应用外部可见"><a href="#3、应用外部可见" class="headerlink" title="3、应用外部可见"></a>3、应用外部可见</h2><h3 id="1、目标"><a href="#1、目标" class="headerlink" title="1、目标"></a>1、目标</h3><ul>
<li>了解 Kubernetes 中的 Service</li>
<li>了解 标签(Label) 和 标签选择器(Label Selector) 对象如何与 Service 关联</li>
<li>在 Kubernetes 集群外用 Service 暴露应用</li>
</ul>
<h3 id="2、Kubernetes-Service-总览"><a href="#2、Kubernetes-Service-总览" class="headerlink" title="2、Kubernetes Service 总览"></a>2、Kubernetes Service 总览</h3><ul>
<li>Kubernetes <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/pods/">Pod</a> 是转瞬即逝的。</li>
<li>Pod 实际上拥有 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/">生命周期</a>。 当一个工作 Node 挂掉后, 在 Node 上运行的 Pod 也会消亡。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> 会自动地通过创建新的 Pod 驱动集群回到目标状态，以保证应用程序正常运行。</li>
<li><em>Kubernetes 的 Service 是一个抽象层，它定义了一组 Pod 的逻辑集，并为这些 Pod 支持外部流量暴露、负载平衡和服务发现。</em><ul>
<li>Service 使从属 Pod 之间的松耦合成为可能。 和其他 Kubernetes 对象一样, Service 用 YAML <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/configuration/overview/#general-configuration-tips">(更推荐)</a> 或者 JSON 来定义. Service 下的一组 Pod 通常由 <em>LabelSelector</em> (请参阅下面的说明为什么您可能想要一个 spec 中不包含<code>selector</code>的服务)来标记。</li>
<li>尽管每个 Pod 都有一个唯一的 IP 地址，但是如果没有 Service ，这些 IP 不会暴露在群集外部。Service 允许您的应用程序接收流量。Service 也可以用在 ServiceSpec 标记<code>type</code>的方式暴露<ul>
<li><em>ClusterIP</em> (默认) - 在集群的内部 IP 上公开 Service 。这种类型使得 Service 只能从集群内访问。</li>
<li><em>NodePort</em> - 使用 NAT 在集群中每个选定 Node 的相同端口上公开 Service 。使用<code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 从集群外部访问 Service。是 ClusterIP 的超集。</li>
<li><em>LoadBalancer</em> - 在当前云中创建一个外部负载均衡器(如果支持的话)，并为 Service 分配一个固定的外部IP。是 NodePort 的超集。</li>
<li><em>ExternalName</em> - 通过返回带有该名称的 CNAME 记录，使用任意名称(由 spec 中的<code>externalName</code>指定)公开 Service。不使用代理。这种类型需要<code>kube-dns</code>的v1.7或更高版本。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3、Service-和-Label"><a href="#3、Service-和-Label" class="headerlink" title="3、Service 和 Label"></a>3、Service 和 Label</h3>

<p>Service 通过一组 Pod 路由通信。Service 是一种抽象，它允许 Pod 死亡并在 Kubernetes 中复制，而不会影响应用程序。在依赖的 Pod (如应用程序中的前端和后端组件)之间进行发现和路由是由Kubernetes Service 处理的。</p>
<p>Service 匹配一组 Pod 是使用 <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/overview/working-with-objects/labels">标签(Label)和选择器(Selector)</a>, 它们是允许对 Kubernetes 中的对象进行逻辑操作的一种分组原语。标签(Label)是附加在对象上的键&#x2F;值对，可以以多种方式使用:</p>
<ul>
<li>指定用于开发，测试和生产的对象</li>
<li>嵌入版本标签</li>
<li>使用 Label 将对象进行分类</li>
</ul>




<h3 id="4、kubectl-expose"><a href="#4、kubectl-expose" class="headerlink" title="4、kubectl expose"></a>4、kubectl expose</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment tomcat6 --port=8912 --target-port=8080 --<span class="built_in">type</span>=NodePort</span><br><span class="line"></span><br><span class="line"><span class="comment">## --port：集群内访问service的端口 8912</span></span><br><span class="line"><span class="comment">## --target-port： pod容器的端口 8080</span></span><br><span class="line"><span class="comment">## --nodePort： 每个机器开发的端口 30403</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 进行验证</span></span><br><span class="line">kubectl get svc </span><br><span class="line">curl ip:port</span><br><span class="line"></span><br><span class="line">kubectl expose  <span class="comment">#暴露，成一个负载均衡网络</span></span><br><span class="line"><span class="comment">## kubectl exec 进去pod修改，并测试负载均衡</span></span><br></pre></td></tr></table></figure>



<h2 id="4、伸缩应用程序-扩缩容"><a href="#4、伸缩应用程序-扩缩容" class="headerlink" title="4、伸缩应用程序-扩缩容"></a>4、伸缩应用程序-扩缩容</h2><p><strong>目标</strong></p>
<ul>
<li>用 kubectl 扩缩应用程序</li>
<li>扩缩一个 Deployment</li>
</ul>
<p>我们创建了一个 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment </a>，然后通过 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">服务</a>提供访问 Pod 的方式。我们发布的 Deployment 只创建了一个 Pod 来运行我们的应用程序。当流量增加时，我们需要对应用程序进行伸缩操作以满足系统性能需求。</p>




<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 扩展</span></span><br><span class="line"><span class="comment">## 扩容的Pod会自动加入到他之前存在的Service（负载均衡网络）</span></span><br><span class="line">kubectl scale --replicas=3  deployment tomcat6</span><br><span class="line"></span><br><span class="line"><span class="comment">#持续观测效果</span></span><br><span class="line">watch kubectl get pods -o wide</span><br></pre></td></tr></table></figure>



<h2 id="5、执行滚动升级"><a href="#5、执行滚动升级" class="headerlink" title="5、执行滚动升级"></a>5、执行滚动升级</h2><p><strong>目标</strong></p>
<ul>
<li>使用 kubectl 执行滚动更新</li>
</ul>
<blockquote>
<p><em>滚动更新允许通过使用新的实例逐步更新 Pod 实例从而实现 Deployments 更新，停机时间为零。</em></p>
</blockquote>
<p>与应用程序扩展类似，如果暴露了 Deployment，服务（Service）将在更新期间仅对可用的 pod 进行负载均衡。可用 Pod 是应用程序用户可用的实例。</p>
<p>滚动更新允许以下操作：</p>
<ul>
<li>将应用程序从一个环境提升到另一个环境（通过容器镜像更新）</li>
<li>回滚到以前的版本</li>
<li>持续集成和持续交付应用程序，无需停机</li>
</ul>
















<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#应用升级: tomcat:alpine、tomcat:jre8-alpine</span></span><br><span class="line"><span class="comment"># kubectl set image deployment/my-nginx2  nginx=nginx:1.9.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##联合jenkins 形成持续集成，灰度发布功能</span></span><br><span class="line">kubectl <span class="built_in">set</span> image deployment.apps/tomcat6 tomcat=tomcat:jre8-alpine <span class="comment">#可以携带--record参数，记录变更</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##回滚升级</span></span><br><span class="line"><span class="comment">### 查看历史记录</span></span><br><span class="line">kubectl rollout <span class="built_in">history</span> deployment.apps/tomcat6</span><br><span class="line">kubectl rollout <span class="built_in">history</span> deploy tomcat6</span><br><span class="line"></span><br><span class="line"><span class="comment">### 回滚到指定版本</span></span><br><span class="line">kubectl rollout undo deployment.apps/tomcat6 --to-revision=1</span><br><span class="line">kubectl rollout undo deploy tomcat6 --to-revision=1</span><br></pre></td></tr></table></figure>



<p>命令：记的太多</p>
<p>声明式API；</p>
<p>对象描述文件的方式；Pod –》 yaml ，  Deploy–》yaml  ，  Service –》 yaml</p>
<p>kubectl apply -f  xxx.yaml .；</p>
<p>用文件固化操作。移植性增加</p>
<h2 id="6、以上用配置文件方式"><a href="#6、以上用配置文件方式" class="headerlink" title="6、以上用配置文件方式"></a>6、以上用配置文件方式</h2><h3 id="1、部署一个应用-1"><a href="#1、部署一个应用-1" class="headerlink" title="1、部署一个应用"></a>1、部署一个应用</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>	<span class="comment">#与k8s集群版本有关，使用 kubectl api-versions 即可查看当前集群支持的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>	<span class="comment">#该配置的类型，我们使用的是 Deployment</span></span><br><span class="line"><span class="attr">metadata:</span>	        <span class="comment">#译名为元数据，即 Deployment 的一些基本属性和信息</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span>	<span class="comment">#Deployment 的名称</span></span><br><span class="line">  <span class="attr">labels:</span>	    <span class="comment">#标签，可以灵活定位一个或多个资源，其中key和value均可自定义，可以定义多组，目前不需要理解</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>	<span class="comment">#为该Deployment设置key为app，value为nginx的标签</span></span><br><span class="line"><span class="attr">spec:</span>	        <span class="comment">#这是关于该Deployment的描述，可以理解为你期待该Deployment在k8s中如何使用</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span>	<span class="comment">#使用该Deployment创建一个应用程序实例</span></span><br><span class="line">  <span class="attr">selector:</span>	    <span class="comment">#标签选择器，与上面的标签共同作用，目前不需要理解</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment">#选择包含标签app:nginx的资源</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span>	    <span class="comment">#这是选择或创建的Pod的模板</span></span><br><span class="line">    <span class="attr">metadata:</span>	<span class="comment">#Pod的元数据</span></span><br><span class="line">      <span class="attr">labels:</span>	<span class="comment">#Pod的标签，上面的selector即选择包含标签app:nginx的Pod</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span>	    <span class="comment">#期望Pod实现的功能（即在pod中部署）</span></span><br><span class="line">      <span class="attr">containers:</span>	<span class="comment">#生成container，与docker中的container是同一种</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span>	<span class="comment">#container的名称</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span>	<span class="comment">#使用镜像nginx:1.7.9创建container，该container默认80端口可访问</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>kubectl apply -f xxx.yaml</p>
</blockquote>
<h3 id="2、暴露应用"><a href="#2、暴露应用" class="headerlink" title="2、暴露应用"></a>2、暴露应用</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span>	<span class="comment">#Service 的名称</span></span><br><span class="line">  <span class="attr">labels:</span>     	<span class="comment">#Service 自己的标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>	<span class="comment">#为该 Service 设置 key 为 app，value 为 nginx 的标签</span></span><br><span class="line"><span class="attr">spec:</span>	    <span class="comment">#这是关于该 Service 的定义，描述了 Service 如何选择 Pod，如何被访问</span></span><br><span class="line">  <span class="attr">selector:</span>	    <span class="comment">#标签选择器</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span>	<span class="comment">#选择包含标签 app:nginx 的 Pod</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span>	<span class="comment">#端口的名字</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span>	    <span class="comment">#协议类型 TCP/UDP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span>	        <span class="comment">#集群内的其他容器组可通过 80 端口访问 Service</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">32600</span>   <span class="comment">#通过任意节点的 32600 端口访问 Service</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span>	<span class="comment">#将请求转发到匹配 Pod 的 80 端口</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span>	<span class="comment">#Serive的类型，ClusterIP/NodePort/LoaderBalancer</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3、扩缩容"><a href="#3、扩缩容" class="headerlink" title="3、扩缩容"></a>3、扩缩容</h3><p>修改deployment.yaml 中的 replicas 属性即可</p>
<p>完成后运行  kubectl apply -f xxx.yaml</p>
<h3 id="4、滚动升级"><a href="#4、滚动升级" class="headerlink" title="4、滚动升级"></a>4、滚动升级</h3><p>修改deployment.yaml 中的 imageName 属性等</p>
<p>完成后运行  kubectl apply -f xxx.yaml</p>
<blockquote>
<p>以上都可以直接 kubectl edit deploy&#x2F;service 等，修改完成后自动生效</p>
</blockquote>
<h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><h2 id="1、查看Kubernetes适配的docker版本"><a href="#1、查看Kubernetes适配的docker版本" class="headerlink" title="1、查看Kubernetes适配的docker版本"></a>1、查看Kubernetes适配的docker版本</h2><p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/releases">https://github.com/kubernetes/kubernetes/releases</a>   查看他的changelog，搜索适配的docker版本即可。</p>
<h2 id="2、弃用dockershim的问题"><a href="#2、弃用dockershim的问题" class="headerlink" title="2、弃用dockershim的问题"></a>2、弃用dockershim的问题</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/blog/2020/12/02/dockershim-faq/">https://kubernetes.io/zh/blog/2020/12/02/dockershim-faq/</a></p>
<ul>
<li>使用containerd： <a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd">https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#containerd</a></li>
<li>配置docker：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker">https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/#docker</a></li>
</ul>
<h2 id="3、部署dashboard"><a href="#3、部署dashboard" class="headerlink" title="3、部署dashboard"></a>3、部署dashboard</h2><p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p>
<p>type: NodePort</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#访问测试</span></span><br><span class="line">每次访问都需要令牌</span><br><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>



<p>需要在下载来的文件中改这个</p>


<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 运行这个给个权限</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="4、master初始化的日志"><a href="#4、master初始化的日志" class="headerlink" title="4、master初始化的日志"></a>4、master初始化的日志</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@i-iqrlgkwc ~]<span class="comment"># kubeadm init \</span></span><br><span class="line">&gt; --apiserver-advertise-address=10.170.11.8 \</span><br><span class="line">&gt; --image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">&gt; --kubernetes-version v1.21.0 \</span><br><span class="line">&gt; --service-cidr=10.96.0.0/16 \</span><br><span class="line">&gt; --pod-network-cidr=192.168.0.0/16</span><br><span class="line">[init] Using Kubernetes version: v1.21.0</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">	[WARNING IsDockerSystemdCheck]: detected <span class="string">&quot;cgroupfs&quot;</span> as the Docker cgroup driver. The recommended driver is <span class="string">&quot;systemd&quot;</span>. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Pulling images required <span class="keyword">for</span> setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action <span class="keyword">in</span> beforehand using <span class="string">&#x27;kubeadm config images pull&#x27;</span></span><br><span class="line">[certs] Using certificateDir folder <span class="string">&quot;/etc/kubernetes/pki&quot;</span></span><br><span class="line">[certs] Generating <span class="string">&quot;ca&quot;</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">&quot;apiserver&quot;</span> certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed <span class="keyword">for</span> DNS names [k8s-01 kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.170.11.8]</span><br><span class="line">[certs] Generating <span class="string">&quot;apiserver-kubelet-client&quot;</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">&quot;front-proxy-ca&quot;</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">&quot;front-proxy-client&quot;</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">&quot;etcd/ca&quot;</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">&quot;etcd/server&quot;</span> certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed <span class="keyword">for</span> DNS names [k8s-01 localhost] and IPs [10.170.11.8 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">&quot;etcd/peer&quot;</span> certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed <span class="keyword">for</span> DNS names [k8s-01 localhost] and IPs [10.170.11.8 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating <span class="string">&quot;etcd/healthcheck-client&quot;</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">&quot;apiserver-etcd-client&quot;</span> certificate and key</span><br><span class="line">[certs] Generating <span class="string">&quot;sa&quot;</span> key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder <span class="string">&quot;/etc/kubernetes&quot;</span></span><br><span class="line">[kubeconfig] Writing <span class="string">&quot;admin.conf&quot;</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">&quot;kubelet.conf&quot;</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">&quot;controller-manager.conf&quot;</span> kubeconfig file</span><br><span class="line">[kubeconfig] Writing <span class="string">&quot;scheduler.conf&quot;</span> kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file <span class="string">&quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span></span><br><span class="line">[kubelet-start] Writing kubelet configuration to file <span class="string">&quot;/var/lib/kubelet/config.yaml&quot;</span></span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder <span class="string">&quot;/etc/kubernetes/manifests&quot;</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">&quot;kube-apiserver&quot;</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">&quot;kube-controller-manager&quot;</span></span><br><span class="line">[control-plane] Creating static Pod manifest <span class="keyword">for</span> <span class="string">&quot;kube-scheduler&quot;</span></span><br><span class="line">[etcd] Creating static Pod manifest <span class="keyword">for</span> <span class="built_in">local</span> etcd <span class="keyword">in</span> <span class="string">&quot;/etc/kubernetes/manifests&quot;</span></span><br><span class="line">[wait-control-plane] Waiting <span class="keyword">for</span> the kubelet to boot up the control plane as static Pods from directory <span class="string">&quot;/etc/kubernetes/manifests&quot;</span>. This can take up to 4m0s</span><br><span class="line">[kubelet-check] Initial <span class="built_in">timeout</span> of 40s passed.</span><br><span class="line">[apiclient] All control plane components are healthy after 66.504822 seconds</span><br><span class="line">[upload-config] Storing the configuration used <span class="keyword">in</span> ConfigMap <span class="string">&quot;kubeadm-config&quot;</span> <span class="keyword">in</span> the <span class="string">&quot;kube-system&quot;</span> Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap <span class="string">&quot;kubelet-config-1.21&quot;</span> <span class="keyword">in</span> namespace kube-system with the configuration <span class="keyword">for</span> the kubelets <span class="keyword">in</span> the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node k8s-01 as control-plane by adding the labels: [node-role.kubernetes.io/master(deprecated) node-role.kubernetes.io/control-plane node.kubernetes.io/exclude-from-external-load-balancers]</span><br><span class="line">[mark-control-plane] Marking the node k8s-01 as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: os234q.tqr5fxmvapgu0b71</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs <span class="keyword">in</span> order <span class="keyword">for</span> nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation <span class="keyword">for</span> all node client certificates <span class="keyword">in</span> the cluster</span><br><span class="line">[bootstrap-token] Creating the <span class="string">&quot;cluster-info&quot;</span> ConfigMap <span class="keyword">in</span> the <span class="string">&quot;kube-public&quot;</span> namespace</span><br><span class="line">[kubelet-finalize] Updating <span class="string">&quot;/etc/kubernetes/kubelet.conf&quot;</span> to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 10.170.11.8:6443 --token os234q.tqr5fxmvapgu0b71 \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:68251032e1f77a7356e784bdeb8e1f7f728cb0fb31c258dc7b44befc9f516f85 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://dongxiaopipi.github.io">Miller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://dongxiaopipi.github.io/2021/04/27/kubernetes/01%E3%80%81Kubernetes-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">https://dongxiaopipi.github.io/2021/04/27/kubernetes/01%E3%80%81Kubernetes-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dongxiaopipi.github.io" target="_blank">Miller</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/30/kubernetes/02%E3%80%81Kubernetes-%E6%A6%82%E5%BF%B5/" title=""><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2021/04/26/kubernetes/06%E3%80%81kubernetes-%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/" title=""><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Miller</div><div class="author-info__description">但行前路，不负韶华！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dongxiaopipi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dongxiaopipi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Kubernetes%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、Kubernetes简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">1、背景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8F%98%E8%BF%81"><span class="toc-number">2.</span> <span class="toc-text">1、部署方式的变迁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AE%B9%E5%99%A8%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">2.0.1.</span> <span class="toc-text">2、容器化问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-Kubernetes"><span class="toc-number">2.0.2.</span> <span class="toc-text">3、为什么用 Kubernetes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%B8%82%E5%9C%BA%E4%BB%BD%E9%A2%9D"><span class="toc-number">2.0.3.</span> <span class="toc-text">4、市场份额</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">1、容器化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E6%9C%8D%E5%8A%A1%E7%BC%96%E6%8E%92"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">2、服务编排</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2、简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Kubernetes%E4%B8%8D%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.1.</span> <span class="toc-text">1、Kubernetes不是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Kubernetes%E5%AE%89%E8%A3%85"><span class="toc-number">3.</span> <span class="toc-text">二、Kubernetes安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%9B%86%E7%BE%A4%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">1、集群原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81master-node-%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">1、master-node 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">2、工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E8%A7%A3"><span class="toc-number">3.1.3.</span> <span class="toc-text">3、原理分解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%B8%BB%E8%8A%82%E7%82%B9%EF%BC%88master%EF%BC%89"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">1、主节点（master）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9%EF%BC%88node%EF%BC%89"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">2、工作节点（node）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%EF%BC%9A"><span class="toc-number">3.2.</span> <span class="toc-text">其他：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">2、组件交互原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-number">3.4.</span> <span class="toc-text">3、安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%90%86%E8%A7%A3"><span class="toc-number">3.4.1.</span> <span class="toc-text">1、理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%89%A7%E8%A1%8C"><span class="toc-number">3.4.2.</span> <span class="toc-text">2、执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%87%86%E5%A4%87%E6%9C%BA%E5%99%A8"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">1、准备机器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%AE%89%E8%A3%85%E5%89%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%EF%BC%88%E9%83%BD%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">2、安装前置环境（都执行）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.2.2.1.</span> <span class="toc-text">1、基础环境</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E3%80%81docker%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.2.2.2.</span> <span class="toc-text">2、docker环境</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85k8s%E6%A0%B8%E5%BF%83%EF%BC%88%E9%83%BD%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">3、安装k8s核心（都执行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96master%E8%8A%82%E7%82%B9%EF%BC%88master%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">4、初始化master节点（master执行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96worker%E8%8A%82%E7%82%B9%EF%BC%88worker%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">5、初始化worker节点（worker执行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E9%AA%8C%E8%AF%81%E9%9B%86%E7%BE%A4"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">6、验证集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E8%AE%BE%E7%BD%AEipvs%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.2.7.</span> <span class="toc-text">7、设置ipvs模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E8%AE%A9%E5%85%B6%E4%BB%96%E5%AE%A2%E6%88%B7%E7%AB%AFkubelet%E4%B9%9F%E8%83%BD%E6%93%8D%E4%BD%9C%E9%9B%86%E7%BE%A4"><span class="toc-number">3.4.2.8.</span> <span class="toc-text">8、让其他客户端kubelet也能操作集群</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%80%A5%E9%80%9F%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.</span> <span class="toc-text">4、急速安装方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Kubernetes%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8"><span class="toc-number">4.</span> <span class="toc-text">三、Kubernetes基础入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">0、基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">1、部署一个应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A2%E7%B4%A2"><span class="toc-number">4.3.</span> <span class="toc-text">2、应用程序探索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%86%E8%A7%A3Pod"><span class="toc-number">4.3.1.</span> <span class="toc-text">1、了解Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%86%E8%A7%A3Node"><span class="toc-number">4.3.2.</span> <span class="toc-text">2、了解Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="toc-number">4.3.3.</span> <span class="toc-text">3、故障排除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81kubectl-run"><span class="toc-number">4.3.4.</span> <span class="toc-text">4、kubectl run</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%BA%94%E7%94%A8%E5%A4%96%E9%83%A8%E5%8F%AF%E8%A7%81"><span class="toc-number">4.4.</span> <span class="toc-text">3、应用外部可见</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%9B%AE%E6%A0%87"><span class="toc-number">4.4.1.</span> <span class="toc-text">1、目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Kubernetes-Service-%E6%80%BB%E8%A7%88"><span class="toc-number">4.4.2.</span> <span class="toc-text">2、Kubernetes Service 总览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81Service-%E5%92%8C-Label"><span class="toc-number">4.4.3.</span> <span class="toc-text">3、Service 和 Label</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81kubectl-expose"><span class="toc-number">4.4.4.</span> <span class="toc-text">4、kubectl expose</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%BC%B8%E7%BC%A9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-number">4.5.</span> <span class="toc-text">4、伸缩应用程序-扩缩容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%89%A7%E8%A1%8C%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7"><span class="toc-number">4.6.</span> <span class="toc-text">5、执行滚动升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E4%BB%A5%E4%B8%8A%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">6、以上用配置文件方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8-1"><span class="toc-number">4.7.1.</span> <span class="toc-text">1、部署一个应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%9A%B4%E9%9C%B2%E5%BA%94%E7%94%A8"><span class="toc-number">4.7.2.</span> <span class="toc-text">2、暴露应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-number">4.7.3.</span> <span class="toc-text">3、扩缩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7"><span class="toc-number">4.7.4.</span> <span class="toc-text">4、滚动升级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">5.</span> <span class="toc-text">四、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%9F%A5%E7%9C%8BKubernetes%E9%80%82%E9%85%8D%E7%9A%84docker%E7%89%88%E6%9C%AC"><span class="toc-number">5.1.</span> <span class="toc-text">1、查看Kubernetes适配的docker版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%BC%83%E7%94%A8dockershim%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">2、弃用dockershim的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E9%83%A8%E7%BD%B2dashboard"><span class="toc-number">5.3.</span> <span class="toc-text">3、部署dashboard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81master%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">5.4.</span> <span class="toc-text">4、master初始化的日志</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/29/Spring/Conditional%E6%B3%A8%E8%A7%A3/" title="Spring注解">Spring注解</a><time datetime="2023-12-29T14:15:37.000Z" title="发表于 2023-12-29 22:15:37">2023-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/29/Spring/Spring5.3.X%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/" title="Spring5.3.X源码搭建">Spring5.3.X源码搭建</a><time datetime="2023-12-29T14:15:37.000Z" title="发表于 2023-12-29 22:15:37">2023-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/29/SpringBoot/@ConditionalOnMissingBean/" title="ConditionalOnMissingBean注解">ConditionalOnMissingBean注解</a><time datetime="2023-12-29T14:15:37.000Z" title="发表于 2023-12-29 22:15:37">2023-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/05/JVM/5%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" title="5、JVM执行引擎">5、JVM执行引擎</a><time datetime="2023-12-05T01:55:37.000Z" title="发表于 2023-12-05 09:55:37">2023-12-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/12/05/JVM/4%E3%80%81%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/" title="4、JVM对象内存布局">4、JVM对象内存布局</a><time datetime="2023-12-05T01:55:37.000Z" title="发表于 2023-12-05 09:55:37">2023-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Miller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'db42a262fa6f18cde447',
      clientSecret: '6b983379141001746330082f46fbd2b645ce1e33',
      repo: 'dongxiaopipi.github.io',
      owner: 'dongxiaopipi',
      admin: ['dongxiaopipi'],
      id: '7fc39f5776bf51f7a579a03ad307fd0b',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>