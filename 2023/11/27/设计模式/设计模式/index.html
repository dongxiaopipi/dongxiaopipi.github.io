<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>设计模式 | Miller</title><meta name="author" content="Miller"><meta name="copyright" content="Miller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设计原则设计模式七大原则 单一职责原则、接口隔离原则、依赖倒置原则、里氏替换原则、开闭原则、迪米特法则、合成复用原则 单一职责原则​		对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。  单一职责原则注意事项和细节 1）降低类的复杂度，一个类只负责一项职责 2）提高类的可读性，可">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Miller">
<meta property="og:description" content="设计原则设计模式七大原则 单一职责原则、接口隔离原则、依赖倒置原则、里氏替换原则、开闭原则、迪米特法则、合成复用原则 单一职责原则​		对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。  单一职责原则注意事项和细节 1）降低类的复杂度，一个类只负责一项职责 2）提高类的可读性，可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png">
<meta property="article:published_time" content="2023-11-27T14:15:37.000Z">
<meta property="article:modified_time" content="2023-11-28T00:58:09.227Z">
<meta property="article:author" content="Miller">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-28 08:58:09'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Miller"><span class="site-name">Miller</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-28T00:58:09.227Z" title="更新于 2023-11-28 08:58:09">2023-11-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>设计模式七大原则</p>
<p>单一职责原则、接口隔离原则、依赖倒置原则、里氏替换原则、开闭原则、迪米特法则、合成复用原则</p>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>​		对类来说，即一个类应该只负责一项职责。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为A1，A2。</p>
<ul>
<li><p>单一职责原则注意事项和细节</p>
<p>1）降低类的复杂度，一个类只负责一项职责</p>
<p>2）提高类的可读性，可维护性</p>
<p>3）降低变更引起的风险</p>
</li>
</ul>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>​		客户端不应该依赖他它需要的接口，即<code>一个类对另一个类对依赖应该建立在最小的接口上</code></p>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230106105640913.png" alt="image-20230106105640913" style="zoom:50%;">

<p>应该将Interface1拆分为独立的几个接口，类A和C分别与他们需要的接口建立依赖关系。</p>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/hexo/blog/source/_posts/设计模式/image/image-20230106105806679.png" alt="image-20230106105806679" style="zoom:50%;">



<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><ul>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒置的中心思想是面向接口编程</li>
</ul>
<h4 id="依赖关系传递的三种方式"><a href="#依赖关系传递的三种方式" class="headerlink" title="依赖关系传递的三种方式"></a>依赖关系传递的三种方式</h4><ul>
<li>接口传递</li>
<li>构造方法传递</li>
<li>setter方式传递</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.principle.inversion.improve;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependencyPass</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="type">ChangHong</span> <span class="variable">changHong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChangHong</span>();</span><br><span class="line"><span class="comment">// OpenAndClose openAndClose = new OpenAndClose();</span></span><br><span class="line"><span class="comment">// openAndClose.open(changHong);</span></span><br><span class="line"><span class="comment">//通过构造器进行依赖传递</span></span><br><span class="line"><span class="comment">// OpenAndClose openAndClose = new OpenAndClose(changHong);</span></span><br><span class="line"><span class="comment">// openAndClose.open();</span></span><br><span class="line"><span class="comment">//通过 setter 方法进行依赖传递</span></span><br><span class="line"><span class="type">OpenAndClose</span> <span class="variable">openAndClose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenAndClose</span>();</span><br><span class="line">openAndClose.setTv(changHong);</span><br><span class="line">openAndClose.open();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式 1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="comment">// interface IOpenAndClose &#123;</span></span><br><span class="line"><span class="comment">// public void open(ITV tv); //抽象方法,接收接口</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// interface ITV &#123; //ITV 接口</span></span><br><span class="line"><span class="comment">// public void play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// class ChangHong implements ITV &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// @Override</span></span><br><span class="line"><span class="comment">// public void play() &#123;</span></span><br><span class="line"><span class="comment">// // TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// System.out.println(&quot;长虹电视机，打开&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//// 实现接口</span></span><br><span class="line"><span class="comment">// class OpenAndClose implements IOpenAndClose&#123;</span></span><br><span class="line"><span class="comment">// public void open(ITV tv)&#123;</span></span><br><span class="line"><span class="comment">// tv.play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 方式 2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="comment">// interface </span></span><br><span class="line"><span class="comment">// public void open(); //抽象方法</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// interface ITV &#123; //ITV 接口</span></span><br><span class="line"><span class="comment">// public void play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// class OpenAndClose implements IOpenAndClose&#123;</span></span><br><span class="line"><span class="comment">// public ITV tv; //成员</span></span><br><span class="line"><span class="comment">// public OpenAndClose(ITV tv)&#123; //构造器</span></span><br><span class="line"><span class="comment">// this.tv = tv;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// public void open()&#123;</span></span><br><span class="line"><span class="comment">// this.tv.play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 方式 3 , 通过 setter 方法传递</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ITV</span> &#123; <span class="comment">// ITV 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenAndClose</span> <span class="keyword">implements</span> <span class="title class_">IOpenAndClose</span> &#123;</span><br><span class="line"><span class="keyword">private</span> ITV tv;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTv</span><span class="params">(ITV tv)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.tv = tv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.tv.play();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChangHong</span> <span class="keyword">implements</span> <span class="title class_">ITV</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">&quot;长虹电视机，打开&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><ol>
<li>一个对象应该对其他对象保持最少的了解 </li>
<li>类与类关系越密切，耦合度越大 </li>
<li>迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息</li>
<li>迪米特法则还有个更简单的定义：只与直接的朋友通信 </li>
<li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，<strong>我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</li>
</ol>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/hexo/blog/source/_posts/设计模式/image/image-20230106142814445.png" alt="image-20230106142814445" style="zoom:50%;">

<ul>
<li>用来描述系统中的类（对象）本身的组成和类（对象）之间的各种静态关系</li>
<li>类之间的关系：依赖、泛化（继承）、实现、关联、聚合和组合</li>
</ul>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式分为三种类型，共23种</p>
<ul>
<li><p>创建型模式：<font color="red"> 单例模式</font>、抽象工厂模式、原型模式、建造者模式、<font color="red">工厂模式</font></p>
</li>
<li><p>结构型模式：适配器模式、桥接模式、<font color="red">装饰模式</font>、组合模式、外观模式、亨元模式、<font color="red">代理模式</font></p>
</li>
<li><p>行为型模式：模版方法模式、命令模式、访问者模式、迭代器模式、<code>观察者模式</code>、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、责任链模式</p>
</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>​		采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。</p>
<h4 id="1-饿汉式（静态常量）"><a href="#1-饿汉式（静态常量）" class="headerlink" title="1.饿汉式（静态常量）"></a>1.饿汉式（静态常量）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式（静态变量）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="comment">//1.构造器私有化（防止new）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个共有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点</p>
<p>​	1）优点：在类装载时就完成了初始化，避免了线程同步问题。</p>
<p>​	2）缺点：没有达到lazy loading的效果，如果从始至终没有使用这个实例，会造成内存浪费。</p>
<h4 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2.饿汉式（静态代码块）"></a>2.饿汉式（静态代码块）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块中创建代理对象</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供一个共有的静态方法，返回实例对象</span></span><br><span class="line">    <span class="keyword">public</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-懒汉式（线程不安全）-不推荐使用"><a href="#3-懒汉式（线程不安全）-不推荐使用" class="headerlink" title="3.懒汉式（线程不安全）- 不推荐使用"></a>3.懒汉式（线程不安全）- 不推荐使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点</p>
<p>1）实现了lazy loading，但是只能在单线程下使用</p>
<p>2）如果在多线程下，如果一个线程进入了if判断，还未来得及往下执行，另一个线程也通过了这个判断语句，这时会产生多个实例</p>
<h4 id="4-懒汉式（线程安全）-不推荐使用"><a href="#4-懒汉式（线程安全）-不推荐使用" class="headerlink" title="4.懒汉式（线程安全）- 不推荐使用"></a>4.懒汉式（线程安全）- 不推荐使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，当使用到该方法时，才去创建instance</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-双重检查-实际开发推荐"><a href="#5-双重检查-实际开发推荐" class="headerlink" title="5.双重检查-实际开发推荐"></a>5.双重检查-实际开发推荐</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态的共有方法，加入双重检查代码，解决线程问题，同时解决懒加载问题</span></span><br><span class="line">    <span class="comment">//即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优缺点：</p>
<p>1）双重检查在多线程常用，进行两次if判读，可以保证线程安全</p>
<p>2）实例化代码只用执行一次，后面再次访问时，判断if成立，直接return实例化对象</p>
<h4 id="6-静态内部类"><a href="#6-静态内部类" class="headerlink" title="6.静态内部类"></a>6.静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写一个静态内部类，该类中有一个静态属性 Singleton</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个静态共有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-枚举"><a href="#7-枚举" class="headerlink" title="7.枚举"></a>7.枚举</h4><p>推荐使用</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1）单例模式保证了系统内存中只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</p>
<p>2）当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</p>
<p>3）使用场景：需要频繁进行创建销毁的对象、创建对象时耗时过多或耗费资源过多但又经常用到的对象</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>1.简单工厂模式是属于创建型模式，是工厂模式的一种。<strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。简单工厂模式是工厂模式家族中最简单实用的模式。</p>
<p>2.简单工厂模式：定义了一个创建对象的类，由这个类来<strong>封装实例化对象的行为</strong>(代码)</p>
<p>3.在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将pizza类做成抽象的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//准备原材料，不同的披萨不一样，所以用抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bake</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; baking;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; cutting;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">box</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; boxing;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  11:35</span></span><br><span class="line"><span class="comment"> * 简单工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用简单工厂模式&quot;</span>);</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;greek&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">GreekPizza</span>();</span><br><span class="line">            pizza.setName(orderType);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;chess&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">ChessPizza</span>();</span><br><span class="line">            pizza.setName(orderType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出pizza制作过程</span></span><br><span class="line">        pizza.prepare();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong>工厂方法模式设计方案</strong>：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。</p>
<p><strong>工厂方法模式</strong>：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将<strong>对象的实例化推迟到子类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个抽象方法,createPizza,让各个工厂子类自己实现</span></span><br><span class="line">    <span class="keyword">abstract</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String orderType;<span class="comment">//订购pizza的类型</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = createPizza(orderType);<span class="comment">//抽象方法，由工厂子类完成</span></span><br><span class="line">            <span class="comment">//输出pizza制作过程</span></span><br><span class="line">            pizza.prepare();</span><br><span class="line">            pizza.bake();</span><br><span class="line">            pizza.cut();</span><br><span class="line">            pizza.box();</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个简单工厂对象</span></span><br><span class="line"><span class="comment">//    SimpleFactory simpleFactory;</span></span><br><span class="line"><span class="comment">//    Pizza pizza = null;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    //构造器</span></span><br><span class="line"><span class="comment">//    public OrderPizza(SimpleFactory simpleFactory)&#123;</span></span><br><span class="line"><span class="comment">//        setFactory(simpleFactory);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    public void setFactory(SimpleFactory simpleFactory)&#123;</span></span><br><span class="line"><span class="comment">//        String orderType = &quot;&quot;;//用户输入</span></span><br><span class="line"><span class="comment">//        this.simpleFactory = simpleFactory;//设置简单工厂对象</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        do &#123;</span></span><br><span class="line"><span class="comment">//            orderType = getType();</span></span><br><span class="line"><span class="comment">//            pizza = this.simpleFactory.createPizza(orderType);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            if (pizza != null)&#123;</span></span><br><span class="line"><span class="comment">//                //成功</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125; while (true);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//写一个方法可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;chess&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJOrderPizza</span> <span class="keyword">extends</span> <span class="title class_">OrderPizza</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;chess&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PizzaStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建北京口味的各种披萨</span></span><br><span class="line"><span class="comment">//        new BJOrderPizza();</span></span><br><span class="line">        <span class="comment">//创建伦敦口味的各种披萨</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LDOrderPizza</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><ol>
<li><p>抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类</p>
</li>
<li><p>抽象工厂模式可以将<strong>简单工厂模式</strong>和<strong>工厂方法模式</strong>进行整合。</p>
</li>
<li><p>从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。</p>
</li>
<li><p>将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了<strong>工厂簇</strong>，更利于代码的维护和扩展。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  16:47</span></span><br><span class="line"><span class="comment"> * 一个抽象工厂模式的抽象层（接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//让下面的工厂子类来具体实现</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  16:59</span></span><br><span class="line"><span class="comment"> * 工厂子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BJFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">BJPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  16:59</span></span><br><span class="line"><span class="comment"> * 工厂子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LDFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsFactory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pizza <span class="title function_">createPizza</span><span class="params">(String orderType)</span> &#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;cheese&quot;</span>))&#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDChessPizza</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType.equals(<span class="string">&quot;pepper&quot;</span>)) &#123;</span><br><span class="line">            pizza = <span class="keyword">new</span> <span class="title class_">LDPepperPizza</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/09  17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderPizza</span> &#123;</span><br><span class="line"></span><br><span class="line">    AbsFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderPizza</span><span class="params">(AbsFactory factory)</span>&#123;</span><br><span class="line">        setFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(AbsFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">Pizza</span> <span class="variable">pizza</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">orderType</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            orderType = getType();</span><br><span class="line">            pizza = factory.createPizza(orderType);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> != pizza)&#123;</span><br><span class="line">                pizza.prepare();</span><br><span class="line">                pizza.bake();</span><br><span class="line">                pizza.cut();</span><br><span class="line">                pizza.box();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;订购失败&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法可以获取客户希望订购的披萨种类</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">strin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">            System.out.println(<span class="string">&quot;input pizza type:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> strin.readLine();</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>深拷贝和浅拷贝区别是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误。</p>
<p>浅拷贝是使用默认的clone方法来实现。</p>
<p><strong>深拷贝的实现方式</strong></p>
<p>1）重写clone方法</p>
<p>2）通过对象序列化实现深拷贝</p>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p><strong>1)</strong> <strong>建造者模式（</strong>Builder Pattern<strong>）</strong> 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p><strong>2)</strong> <strong>建造者模式</strong> 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>
<p>建造者模式的四个角色</p>
<p><strong>1) Product</strong>（产品角色）： 一个具体的产品对象。</p>
<p><strong>2) Builder</strong>（抽象建造者）： 创建一个Product对象的各个部件指定的 接口&#x2F;<strong>抽象类</strong>。</p>
<p><strong>3) ConcreteBuilder</strong>（具体建造者）： 实现接口，构建和装配各个部件。</p>
<p><strong>4) Director</strong>（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</p>
<img src="/Users/dongnan/Library/Application Support/typora-user-images/image-20230111154707417.png" alt="image-20230111154707417" style="zoom:50%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/11  16:22</span></span><br><span class="line"><span class="comment"> * 产品-&gt;product</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">House</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String baise;</span><br><span class="line">    <span class="keyword">private</span> String wall;</span><br><span class="line">    <span class="keyword">private</span> String roofed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBaise</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBaise</span><span class="params">(String baise)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.baise = baise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getWall</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWall</span><span class="params">(String wall)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wall = wall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getRoofed</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roofed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoofed</span><span class="params">(String roofed)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roofed = roofed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/11  16:25</span></span><br><span class="line"><span class="comment"> * 抽象的建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">House</span> <span class="variable">house</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">House</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将建造的流程写好，抽象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildWall</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造房子,将产品返回</span></span><br><span class="line">    <span class="keyword">public</span> House <span class="title function_">buildHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> house;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: dongnan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@CreateTime</span>: 2023/01/11  16:28</span></span><br><span class="line"><span class="comment"> * 具体的建造类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonHouse</span> <span class="keyword">extends</span> <span class="title class_">HouseBuilder</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildBasic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子打地基5m&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildWall</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子砌墙10cm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">roofed</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通房子屋顶&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>基本介绍</p>
<ol>
<li><p>适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)</p>
</li>
<li><p>适配器模式属于结构型模式</p>
</li>
<li><p>主要分为三类：类适配器模式、对象适配器模式、接口适配器模式</p>
</li>
</ol>
<h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>类适配器的原理就是通过继承来实现适配器功能。具体做法：让Adapter实现Target接口，并且继承Adaptee，这样Adapter就具备Target和Adaptee可以将两者进行转化。</p>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/adapter.png" alt="adapter" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adaptee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specialRequest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理特殊请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理普通请求&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.specialRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>对象适配器的原理就是通过组合来实现适配器功能。具体做法：让Adapter实现Target接口，然后内部持有Adaptee实例，然后在Target接口规定的方法内转换Adaptee。</p>
<p>具体代码实现很简单就是将<code>Adapter</code>代码修改一下，原来是继承 <code>Adaptee</code>，现在是持有 <code>Adaptee</code>示例 具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Target</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Adapter</span><span class="params">(Adaptee adaptee)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理普通请求&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.adaptee.specialRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Adaptee</span> <span class="variable">adaptee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adaptee</span>();</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Adapter</span>(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image/class.webp" alt="interface"></p>
<h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><p>​		接口适配器的关注点与类适配器和对象适配器的关注点不太一样，类适配器和对象适配器着重于将系统存在的一个角色(Adaptee）转化成目标接口（Target）所需内容，而接口适配器的使用场景是解决接口方法过多，如果直接实现接口，那么类会多出许多空实现的方法，类显得很臃肿。此时，使用接口适配器就能让我们只实现我们需要的接口方法，目标更清晰。</p>
<p>​		其实接口适配器和对象适配器就很像了无非是对象适配器关注点是一个对象的转换，接口可能是多个他的关注点不再是对象转换而是接口转换，这些接口可能需要用到很多个源对象，也就是说这样设计之后转换器中持有的对象就可能是多个了。</p>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/interface.png" alt="interface" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILoginService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginService</span> <span class="keyword">implements</span> <span class="title class_">ILoginService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;登录成功：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户：&quot;</span> + username);</span><br><span class="line">        System.out.println(<span class="string">&quot;密码：&quot;</span> + password);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IThirdLoginAdapter</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(IThirdLoginAdapter adapter)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName,String openId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ThirdLoginAdapter</span> <span class="keyword">implements</span> <span class="title class_">IThirdLoginAdapter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ILoginService loginService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThirdLoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginService = loginService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QQLoginAdapter</span> <span class="keyword">extends</span> <span class="title class_">ThirdLoginAdapter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QQLoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(loginService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(IThirdLoginAdapter adapter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adapter <span class="keyword">instanceof</span> QQLoginAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, String openId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatLoginAdapter</span> <span class="keyword">extends</span> <span class="title class_">ThirdLoginAdapter</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeChatLoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(loginService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">support</span><span class="params">(IThirdLoginAdapter adapter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adapter <span class="keyword">instanceof</span> WeChatLoginAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, String openId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信登录:&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.loginService.login(userName, openId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginAdapter</span> <span class="keyword">implements</span> <span class="title class_">ILoginAdapter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ILoginService loginService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginAdapter</span><span class="params">(ILoginService loginService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loginService = loginService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">qqLogin</span><span class="params">(String userName,String openId)</span> &#123;</span><br><span class="line">        login(userName,openId,WeChatLoginAdapter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">weChatLogin</span><span class="params">(String userName,String openId)</span> &#123;</span><br><span class="line">        login(userName,openId,WeChatLoginAdapter.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String userName, String openId, Class&lt;? extends IThirdLoginAdapter&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">IThirdLoginAdapter</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getDeclaredConstructor(ILoginService.class).newInstance(<span class="built_in">this</span>.loginService);</span><br><span class="line">            <span class="keyword">if</span>(instance.support(instance))&#123;</span><br><span class="line">                instance.login(userName,openId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ILoginService</span> <span class="variable">loginService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginService</span>();</span><br><span class="line">        loginService.login(<span class="string">&quot;土豆&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ILoginAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginAdapter</span>(loginService);</span><br><span class="line">        adapter.qqLogin(<span class="string">&quot;qwe&quot;</span>,<span class="string">&quot;123qwe234234&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><ul>
<li><p>桥接模式是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。</p>
</li>
<li><p>是一种结构型设计模式</p>
</li>
<li><p>Bridge模式基于类的<code>最小设计原则</code>，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展</p>
<p><img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image/bridge.png" alt="bridge"></p>
</li>
</ul>
<p>桥接模式分为一下四个角色：</p>
<ul>
<li><strong>Abstract</strong>：定义抽象接口，拥有一个Implementor类型的对象引用</li>
<li><strong>RefinedAbstraction</strong>：扩展Abstraction中的接口定义</li>
<li><strong>Implementor</strong>：实现部分，可以为接口或者是抽象类，其方法不一定要与抽象部分中的一致，一般情况下是由实现部分提供基本的操作，而抽象部分定义的则是基于实现部分操作的业务方法</li>
<li><strong>ConcreteImplementorA &#x2F;B</strong>： 实现Implementor接口，给出具体实现</li>
</ul>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/Phone.png" alt="Phone" style="zoom:67%;">



<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p><strong>装饰者模式定义</strong></p>
<ol>
<li><p>装饰者模式：<strong>动态的</strong>将新功能<strong>附加到对象上</strong>。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)</p>
</li>
<li><p>这里提到的<strong>动态的将新功能附加到对象</strong>和<strong>ocp****原则</strong>，在后面的应用实例上会以代码的形式体现，请同学们注意体会。</p>
</li>
</ol>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>基本介绍</p>
<ol>
<li><p>组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。</p>
</li>
<li><p>组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p>
</li>
<li><p>这种类型的设计模式属于结构型模式。</p>
</li>
<li><p>组合模式使得用户对单个对象和组合对象的访问具有一致性，<strong>即</strong>：组合能让客户以一致的方式处理个别对象以及组合对象</p>
</li>
</ol>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/screenshot-20230308-171645.png" alt="screenshot-20230308-171645" style="zoom:67%;">

<p>对原理结构图的说明-即(组合模式的角色及职责)</p>
<ol>
<li><p>Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component 可以是抽象类或者接口</p>
</li>
<li><p>Leaf : 在组合中表示叶子节点，叶子节点没有子节点</p>
</li>
<li><p>Composite:非叶子节点，用于存储子部件，在Component接口中实现子部件的相关操作，比如增加、删除</p>
</li>
</ol>
<p><strong>组合模式注意事项</strong></p>
<ul>
<li>简化客户端操作。客户端只需要面向一致的对象而不用考虑整体部分或者节点叶子的部分</li>
<li>具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动</li>
<li>需要&#x3D;&#x3D;遍历组织结构，或者处理的对象具有树形结构时，非常适用组合模式&#x3D;&#x3D;</li>
<li>要求较高的抽象性，&#x3D;&#x3D;如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式&#x3D;&#x3D;</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p><strong>基本介绍</strong></p>
<ol>
<li><p>外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p>
</li>
<li><p>外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节</p>
</li>
</ol>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/:Users:dongnan:Library:Application Support:typora-user-images:image-20230309112648315.png" alt="image-20230309112648315" style="zoom:67%;">

<p><strong>原理类图的说明(外观模式的角色)</strong></p>
<ol>
<li><p>外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象</p>
</li>
<li><p>调用者(Client): 外观接口的调用者</p>
</li>
<li><p>子系统的集合：指模块或者子系统，处理Facade 对象指派的任务，他是功能的实际提供者</p>
</li>
</ol>
<p><strong>外观模式的注意事项和细节</strong></p>
<ol>
<li><p>外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性</p>
</li>
<li><p>外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展</p>
</li>
<li><p>通过合理的使用外观模式，可以帮我们更好的划分访问的层次</p>
</li>
<li><p>当系统需要进行分层设计时，可以考虑使用Facade模式</p>
</li>
<li><p>在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性</p>
</li>
<li><p>不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。</p>
</li>
</ol>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>基本介绍</p>
<ol>
<li><p>享元模式（Flyweight Pattern） 也叫 蝇量模式: 运用共享技术有效地支持大量细粒度的对象</p>
</li>
<li><p>常用于系统底层开发，解决系统的性能问题。像<strong>数据库连接池</strong>，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个</p>
</li>
<li><p>享元模式能够解决<strong>重复对象的内存浪费的问题</strong>，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率</p>
</li>
<li><p>享元模式<strong>经典的应用场景</strong>就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式</p>
</li>
<li><p>享元模式把一个对象的状态分为内部状态和外部状态，<strong>内部状态是不变的可以共享的相同内容</strong>，<strong>外部状态是变化的是需要外部环境来设置的不能共享的内容</strong>，需要注意内部状态和外部状态的区分</p>
</li>
</ol>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/WX20230328-162411@2x.png" alt="WX20230328-162411@2x" style="zoom:50%;">

<ol>
<li><p>FlyWeight 是抽象的享元角色, 他是产品的抽象类, 同时定义出对象的外部状态和内部状态(后面介绍) 的接口或实现</p>
</li>
<li><p>ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务</p>
</li>
<li><p>UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂</p>
</li>
<li><p>FlyWeightFactory 享元工厂类，用于构建一个池容器，同时提供从池中获取对象</p>
</li>
</ol>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p><strong>代理模式</strong>(Proxy Pattern) 是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。代理模式给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做Proxy或Surrogate，它是一种对象结构型模式。</p>
</blockquote>
<p><img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image/proxy.webp" alt="proxy"></p>
<p>主要包含三种角色：</p>
<p>1.抽象主题角色（Subject）：主要职责是声明真实主题与代理的共同接口方法，该类可以是接口也可以是抽象类</p>
<p>2.真实主题角色（RealSubject）：也被称为被代理类，该类定义的代理所表示的真实对象，是负责执行系统真正的逻辑业务对象</p>
<p>3.代理主题角色（Proxy）：也被称为代理类，其内部持有RealSubject的引用，因此具备完全的对Real Subject的代理权，客户端调用代理对象的方法，同时也调用被代理对象的方法，但是会在代理对象前后增加一些处理代码</p>
<h3 id="代理模式的通用写法"><a href="#代理模式的通用写法" class="headerlink" title="代理模式的通用写法"></a>代理模式的通用写法</h3><p><strong>Subject：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RealSubject:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原始类处理请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Proxy:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Subject subject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="built_in">this</span>.subject.request();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理请求之前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理请求之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(realSubject);</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>这种代理方式需要代理对象和目标对象实现一样的接口，且代理类的代码是在运行之前就需要写好的 优点是：可以在不修改目标对象的前提下扩展目标对象的功能。</p>
<p>缺点也很明显</p>
<ol>
<li>如果接口需要增加一个方法对应的代理类和被代理类都需要添加新的实现。</li>
<li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>比如买房，通常卖家只有房源，而卖家一般是没有房源的所以需要找到中介提供房源然后卖房。其中卖房的人就是被代理类，中介相当于代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sellHouse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Seller</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要卖房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intermediary</span> <span class="keyword">implements</span> <span class="title class_">IPerson</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IPerson person;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Intermediary</span><span class="params">(IPerson person)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellHouse</span><span class="params">()</span> &#123;</span><br><span class="line">        before();</span><br><span class="line">        person.sellHouse();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发布房源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;交易完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基于JDK实现动态代理"><a href="#基于JDK实现动态代理" class="headerlink" title="基于JDK实现动态代理"></a>基于JDK实现动态代理</h4><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>还是上述的例子我们用JDK动态代理来实现(接口以及卖家代码都不变,新增代理处理类)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkIntermediary</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">IPerson</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">IPerson</span> <span class="title function_">getInstance</span>(<span class="params">IPerson target</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">target</span> = target;</span><br><span class="line">        <span class="title class_">Class</span>&lt;?&gt; clz = target.<span class="title function_">getClass</span>();</span><br><span class="line">        <span class="keyword">return</span> (<span class="title class_">IPerson</span>)<span class="title class_">Proxy</span>.<span class="title function_">newProxyInstance</span>(clz.<span class="title function_">getClassLoader</span>(),clz.<span class="title function_">getInterfaces</span>(),<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">before</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;发布房源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">void</span> <span class="title function_">after</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;交易完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">invoke</span>(<span class="title class_">Object</span> proxy, <span class="title class_">Method</span> method, <span class="title class_">Object</span>[] args) throws <span class="title class_">Throwable</span> &#123;</span><br><span class="line">        <span class="title function_">before</span>();</span><br><span class="line">        <span class="title class_">Object</span> result = method.<span class="title function_">invoke</span>(<span class="variable language_">this</span>.<span class="property">target</span>, args);</span><br><span class="line">        <span class="title function_">after</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">        <span class="title class_">IPerson</span> person = <span class="keyword">new</span> <span class="title class_">Seller</span>();</span><br><span class="line">        <span class="title class_">JdkIntermediary</span> jdkIntermediary = <span class="keyword">new</span> <span class="title class_">JdkIntermediary</span>();</span><br><span class="line">        <span class="title class_">IPerson</span> instance = jdkIntermediary.<span class="title function_">getInstance</span>(person);</span><br><span class="line">        instance.<span class="title function_">sellHouse</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去可能有些人说<code>JdkIntermediary</code>不就是代理类吗不也是在运行之前生成的吗，但是其实<code>JdkIntermediary</code>并不是代理类，它可以理解成代理处理程序我们可以断点看一下真正的代 理类是<code>$Proxy0</code>这个类是在运行时生成的。</p>
<p>优点：接口中新增方法不需要再像静态代理来一样每个方法都实现一遍了，维护比较方便<br>缺点：被代理类必须实现接口</p>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/13812aba28ed4a9db14eb1b98a48fc0c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.png" alt="13812aba28ed4a9db14eb1b98a48fc0c~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;">













<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式使用的就是面向对象的继承和多态机制，从未实现同一行为在不同场景下具备不同实现。</p>
<p>通俗点将就是在我们业务逻辑中肯定有很多<code>switch case</code>或者是很多<code>if else</code>,我们的业务是需要通过场景判断选择其中一个逻辑执行，这个时候就可以使用策略模式（需要注意的是策略模式一定是只需要执行很多逻辑算法中的一个，而不是执行多个逻辑算法，如果是执行多个就不太适合使用策略模式）</p>
<p>总结一下：策略模式适用场景：</p>
<ol>
<li>针对一个问题有多个不同的处理方式，每种方式之间没有耦合（可以独立解决问题）</li>
<li>算法逻辑需要自由切换的情况下</li>
<li>需要屏蔽算法逻辑规则的场景（应为高层是不接触算法逻辑的实现的）</li>
</ol>
<p><img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image/83bb6f26a4ff4e2686a60e7ebefa88cc~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.png" alt="83bb6f26a4ff4e2686a60e7ebefa88cc~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></p>
<p>其中：</p>
<ul>
<li>上下文角色（Context）:主要使用来操作策略上下文，做到屏蔽高层模块对策略、算法直接访问，也可以在这里封装可能存在的变化</li>
<li>抽象策略角色（Strategy）:主要是规定策略或者算法的行为</li>
<li>具体策略角色（ConcreteStrategy）：策略或者是算法的实现</li>
</ul>
<h4 id="支付案例实现（策略设计模式）"><a href="#支付案例实现（策略设计模式）" class="headerlink" title="支付案例实现（策略设计模式）"></a>支付案例实现（策略设计模式）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String uid, String orderId, <span class="type">double</span> amount)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.uid = uid;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String payType)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.equals(payType, <span class="string">&quot;AliPay&quot;</span>))&#123;</span><br><span class="line">            <span class="type">AliPay</span> <span class="variable">aliPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AliPay</span>();</span><br><span class="line">            <span class="type">PayContext</span> <span class="variable">payContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayContext</span>(aliPay);</span><br><span class="line">            payContext.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Objects.equals(payType, <span class="string">&quot;WeChatPay&quot;</span>))&#123;</span><br><span class="line">            <span class="type">WeChatPay</span> <span class="variable">weChatPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeChatPay</span>();</span><br><span class="line">            <span class="type">PayContext</span> <span class="variable">payContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayContext</span>(weChatPay);</span><br><span class="line">            payContext.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Objects.equals(payType, <span class="string">&quot;UnionPay&quot;</span>))&#123;</span><br><span class="line">            <span class="type">UnionPay</span> <span class="variable">unionPay</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionPay</span>();</span><br><span class="line">            <span class="type">PayContext</span> <span class="variable">payContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayContext</span>(unionPay);</span><br><span class="line">            payContext.pay(<span class="built_in">this</span>.uid, <span class="built_in">this</span>.amount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IPay</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">pay</span><span class="params">(String uid,Double price)</span>&#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">currentAmount</span>  <span class="operator">=</span> queryBalance(uid);</span><br><span class="line">        <span class="keyword">if</span>(currentAmount &lt; price)&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;支付成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AliPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;支付宝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">900.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeChatPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;微信支付&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">200.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.demo.test.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionPay</span> <span class="keyword">implements</span> <span class="title class_">IPay</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;银行卡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">queryBalance</span><span class="params">(String uid)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式是将链中的每一个节点看做是一个对象，每个节点处理的请求均不相同，且内部自动维护下一个节点对象，当一个请求从链式的首段发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求位置，属于行为模式。</p>
<p>这里需要注意的是每个节点都能对对象进行一定的处理(也可以不处理)，处理完成之后节点再进行判断还要进行后续处理还是说传递给下一个节点。</p>
<p>首先举一个日常的例子，比如我们申请开发票，首先我们要写好报销单，首先要你的部门领导审批，部门领导审批不通过直接打回，审批通过再由公司的总经理审批这里审批通过才算成审批完成。这种情况就很适合使用责任链模式。</p>
<p>总结一下责任链主要适用一下几种情况：</p>
<ol>
<li>多个对象可以处理同一个请求，但是具体由那个对象处理完成则在运行时决定。</li>
<li>不明确指定接收者的情况下，向多个对象中的一个提交一个请求</li>
</ol>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/5555afc019f84091aa585a5e27484910~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="5555afc019f84091aa585a5e27484910~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;">

<p>通过类图可以看到总共包含以下角色：</p>
<ul>
<li>抽象处理者：主要是定义处理请求的方法以及维护下一个处理结点的对象的引用</li>
<li>具体处理者：处理的具体实现</li>
</ul>
<p>首先创建抽象类规定抽象方法以及维护下一个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Handler next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是创建多个实现逻辑的节点对象:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidatedHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(user.getUsername() == <span class="literal">null</span> || user.getPassword() == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;账户或者密码为null&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.next.doHandler(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        queryUserInfo(user);</span><br><span class="line">        <span class="keyword">if</span>(user.getRoleName() == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到用户&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.next.doHandler(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">queryUserInfo</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Objects.equals(user.getUsername(), <span class="string">&quot;土豆&quot;</span>) &amp;&amp; Objects.equals(user.getPassword(), <span class="string">&quot;666666&quot;</span>)) &#123;</span><br><span class="line">            user.setRoleName(<span class="string">&quot;超管&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Objects.equals(user.getUsername(), <span class="string">&quot;土豆2号&quot;</span>) &amp;&amp; Objects.equals(user.getPassword(), <span class="string">&quot;666666&quot;</span>))&#123;</span><br><span class="line">            user.setRoleName(<span class="string">&quot;普通员工&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doHandler</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Objects.equals(user.getRoleName(), <span class="string">&quot;超管&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;登入成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;土豆&quot;</span>,<span class="string">&quot;666666&quot;</span>);</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">validatedHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ValidatedHandler</span>();</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">userHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserHandler</span>();</span><br><span class="line">    <span class="type">Handler</span> <span class="variable">authHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AuthHandler</span>();</span><br><span class="line">    validatedHandler.setNext(userHandler);</span><br><span class="line">    userHandler.setNext(authHandler);</span><br><span class="line">    validatedHandler.doHandler(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><blockquote>
<p>门面模式，是指提供一个统一的接口去访问多个子系统的多个不同的接口，它为子系统中的一组接口提供一个统一的高层接口。使得子系统更容易使用。</p>
</blockquote>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/e5d4180f5ddc475ea572241f53e9a40a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="e5d4180f5ddc475ea572241f53e9a40a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;">

<p>主要角色有：</p>
<ol>
<li>外观角色（Facade）:也称门面角色，系统对外的统一接口</li>
<li>子系统角色（SubSystem）:可以同时有一个或者多个SubSystem，SubSystem并不知道Facade的存在，Facade对于SubSystem而言仅仅只是一个客户端</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SystemA</span> <span class="variable">systemA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemA</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SystemB</span> <span class="variable">systemB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemB</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">SystemC</span> <span class="variable">systemC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemC</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        systemA.doSomething();</span><br><span class="line">        systemB.doSomething();</span><br><span class="line">        systemC.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用A系统&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用B系统&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用C系统&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">        facade.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="门面模式应用场景"><a href="#门面模式应用场景" class="headerlink" title="门面模式应用场景"></a>门面模式应用场景</h4><ol>
<li>对分层结构系统构建时，使用门面模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外门面模式可以为系统设计一个简单的接口供外界访问</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入门面模式可将它们分离，从而提高子系统的独立性和可移植性</li>
</ol>
<h4 id="门面模式优缺点"><a href="#门面模式优缺点" class="headerlink" title="门面模式优缺点"></a>门面模式优缺点</h4><p>优点：</p>
<ol>
<li>简化了调用过程，无需深入了解子系统</li>
<li>减少系统依赖</li>
<li>更好的划分层次</li>
<li>遵循迪米特法则</li>
</ol>
<p>缺点：</p>
<ol>
<li>不符合开闭原则</li>
<li>有可能出现违背单一职责原则</li>
</ol>
<h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><blockquote>
<p>模板方法模式(Template Method Pattern）又叫模板模式，是指定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤，属于行为型设计模式。</p>
</blockquote>
<p><img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image/fd77cdf01287446dbbb4123e45e8eea5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="fd77cdf01287446dbbb4123e45e8eea5~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></p>
<p>具体代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractTemplate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">step3</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">templateMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        step1();</span><br><span class="line">        step2();</span><br><span class="line">        <span class="keyword">if</span>(hookMethod())&#123;</span><br><span class="line">            step3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreateTemplate</span> <span class="keyword">extends</span> <span class="title class_">AbstractTemplate</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">step1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">step2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">step3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;step3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hookMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreateTemplate</span> <span class="variable">concreateTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreateTemplate</span>();</span><br><span class="line">        concreateTemplate.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是这个<code>hookMethod</code>钩子函数可有可无，设计钩子方法的主要目的是用来干预执行流程，使得我们控制行为流程更加灵活，更符合实际业务的需求。钩子方法的返回值一般为适合条件分支语句的返回值（如 boolean、 int等）。具体可以根据自己的业务场景来决定是否需要使用钩子方法</p>
<p>我们封装一下rocketmq发送下消息的流程，rocketmq的流程是比较固定的，大致分为三步，启动生产者、发送消息、关闭应用程序，我们可以吧这三步固定在抽象类中，让子类去实现：</p>
<p>抽象模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">RocketMQProducerTemplate</span> &#123;</span><br><span class="line">    DefaultMQProducer producer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RocketMQProducerTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.producer = <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;tudou1&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        start();</span><br><span class="line">        send(message);</span><br><span class="line">        close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实际实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerA</span> <span class="keyword">extends</span> <span class="title class_">RocketMQProducerTemplate</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            producer.start();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;TestA&quot;</span>, message.getBytes());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="built_in">super</span>.producer.send(msg);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板方法优缺点"><a href="#模板方法优缺点" class="headerlink" title="模板方法优缺点"></a>模板方法优缺点</h3><p>优点：</p>
<ol>
<li>利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。</li>
<li>将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。</li>
<li>把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台，符合开闭原则。</li>
</ol>
<p>缺点：</p>
<ol>
<li>类的个数增加，应为每种逻辑都需要新增一个实现类</li>
<li>系统复杂度增加</li>
<li>如果父类新增抽象方法，子类都需要实现一遍</li>
</ol>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p>迭代器模式 （Iterator Pattern）又称为游标模式(Cursor Pattern)，它提供一种顺序访问集合&#x2F; 容器对象元素的方法，而又无须暴露集合内部表示(到底是列表、栈还是树等)。迭代器模式可以为不同的容器提供一致的 遍历行为，而不用关心容器内容元素组成结构，属于行为型模式。</p>
</blockquote>
<p><img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image/94fa013a840949a68a5541a00840a3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="94fa013a840949a68a5541a00840a3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0"></p>
<p>实现代码如下（这里使用的集合是list,也可以使用其他集合这里就不一一展示了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteIterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">cursor</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteIterator</span><span class="params">(List&lt;T&gt; list)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(cursor++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list.size() &gt; cursor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(User user)</span>;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;User&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title class_">IAggregate</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        users.remove(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;User&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteIterator</span>&lt;&gt;(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三2&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三3&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三4&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三5&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三6&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三7&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="type">ConcreteAggregate</span> <span class="variable">concreteAggregate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteAggregate</span>();</span><br><span class="line">        concreteAggregate.add(user1);</span><br><span class="line">        concreteAggregate.add(user2);</span><br><span class="line">        concreteAggregate.add(user3);</span><br><span class="line">        concreteAggregate.add(user4);</span><br><span class="line">        concreteAggregate.add(user5);</span><br><span class="line">        concreteAggregate.add(user6);</span><br><span class="line">        concreteAggregate.add(user7);</span><br><span class="line">        Iterator&lt;User&gt; iterator = concreteAggregate.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="迭代器模式的优缺点"><a href="#迭代器模式的优缺点" class="headerlink" title="迭代器模式的优缺点"></a>迭代器模式的优缺点</h3><p>优点：</p>
<ol>
<li>多态迭代：为不同的聚合结构提供一致的遍历接口，即一个迭代接口可以访问不同的集合对象</li>
<li>简化集合对象接口：迭代器模式将集合对象本身应该提供的元索迭代接口抽取到了迭代器 中，使集合对象无须关心具体迭代行为</li>
<li>元素迭代功能多样化：每个集合对象都可以提供一个或多个不同的迭代器，使的同种元素聚 合结构可以有不同的迭代行为；</li>
<li>解耦迭代与集合：迭代器模式封装了具体的迭代算法，迭代算法的变化，不会影响到集合 对象的架构</li>
</ol>
<p>缺点：<br> 对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作</p>
</blockquote>
<p>命令模式( Command Pattern) 是对命令的封装，每一个命令都是一个操作：请求的一方 发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式解耦了请求方和接 收方，请求方只需请求执行命令，不用关心命令是怎样被接收，怎样被操作以及是否被执行⋯等。<br>命令模式属于行为型模式。</p>
<h3 id="命令模式的应用层场景"><a href="#命令模式的应用层场景" class="headerlink" title="命令模式的应用层场景"></a>命令模式的应用层场景</h3><p>当系统的某项操作具备命令语义时，且命令实现不稳定（变化），那么可以通过命令模式解 耦请求与实现，利用抽象命令接口使请求方代码架构稳定，封装接收方具体命令实现细节。接 收方与抽象命令接口呈现弱耦合（内部方法无需一致），具备良好的扩展性。命令模式适用于 以下应用场景：</p>
<ol>
<li>现实语义中具备 “命令”的操作（如命令菜单，shell 命令⋯）；</li>
<li>请求调用者和请求的接收者需要解耦，使得调用者和接收者不直接交互；</li>
<li>需要抽象出等待执行的行为，比如撤销(Undo)操作和恢复(Redo)等操作；</li>
<li>需要支持命令宏（即命令组合操作）。</li>
</ol>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/fd026f9b958a4e0087c6d42c65223fd7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp" alt="fd026f9b958a4e0087c6d42c65223fd7~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:67%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ICommand</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title class_">ICommand</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteCommand</span><span class="params">(Receiver receiver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收方接收到命令并执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ICommand command;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Invoker</span><span class="params">(ICommand command)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">()</span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteCommand</span> <span class="variable">concreteCommand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteCommand</span>(<span class="keyword">new</span> <span class="title class_">Receiver</span>());</span><br><span class="line">        <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Invoker</span>(concreteCommand);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的类图中就可以发现<code>Invoker</code>和<code>Receiver</code>是没有耦合的，<code>Invoker</code>通过<code>Command</code>和<code>Receiver</code>建立联系的，这里 <code>Invoker</code>就相当于我们平时写业务中的一个业务逻辑的实现，你可以理解成是一个 <code>service</code>,而 <code>Receiver</code>相当于这个业务中的具体某个功能的实现，如果此时业务的需求需要变动，此时我们只需要更改<code>Command</code>中<code>Receiver</code>的应用或者为了符合开闭原则我们完全可以重新创建一个<code>Command</code>,对应者新的<code>Receiver</code>即可，这样对该对于我们整体的业务逻辑是没有改动的。</p>
<p>同时也可以结合装饰器模式，在原有的功能基础上增加一些其他的功能比如日志的收集等等，如果命令不是一个单独的命令而是一个命令的集合 <code>Command</code>会对应着多个命令，同时 <code>Receiver</code>也对应这多个方法，如果能对 <code>Receiver</code>进行抽象，这不就演变成了桥接模式，变成了command和Receiver两个变化的维度，这样扩展性更好</p>
<h3 id="命令模式优缺点"><a href="#命令模式优缺点" class="headerlink" title="命令模式优缺点"></a>命令模式优缺点</h3><p>优点：</p>
<ol>
<li>通过引入中间件（抽象接口），解耦了命令请求与实现；</li>
<li>扩展性良好，可以很容易地增加新命令；</li>
<li>支持组合命令，支持命令队列；</li>
<li>可以在现有命令的基础上，增加额外功能（比如日志记录…，结合装饰器模式更酸爽）。</li>
</ol>
<p>缺点：</p>
<ol>
<li>具体命令类可能过多；</li>
<li>命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构，解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难（不过这 也是设计模式带来的一个通病，抽象必然会引入额外类型；抽象肯定比紧密难理解）。</li>
</ol>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>观察者模式(Observer Pattern），又叫发布-订阅（Publish&#x2F;Subscribe）模式、模型-视图 Model&#x2F;View ） 模式、源-监听器（Source&#x2F;Listener）模式或从属者(Dependents）模式。定义一种一对多的依赖关系，一个主题对象可被多个观察者对象同时监听，使得每当主题对象状态变化时，所有依赖于它的对象都会得到通知并被自动更新。属于行为型模式。</p>
<p>ex：比如MQ、异步队列</p>
</blockquote>
<p>以下几点适合该模式</p>
<p>1.当一个抽象模型包含两个方面内容，其中一个方面依赖于另一个方面</p>
<p>2.其他一个或多个对象的变化依赖于另一个对象的变化</p>
<p>3.实现类似广播机制的功能，无需知道具体收听者，只需分发广播，系统中感兴趣的对象会自动接收广播</p>
<p>4.多层次嵌套使用，形成一种链式触发机制，使得事件具备跨域（跨越两种观察者类型）通知</p>
<img src="/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/dongnan/Desktop/code/Note/设计模式/image/观察者模式.webp" alt="观察者模式" style="zoom:67%;">

<p>具体代码如下： 首先是被观察者它主要的功能是：</p>
<ol>
<li>一个目标可以被多个观察者观察</li>
<li>目标提供对观察者注册和退订的维护</li>
<li>当目标的状态发生变化时，目标负责通知所有注册的、有效的观察者</li>
</ol>
<p><code>ISubject</code>它的主要作用就是定义接口（主要是订阅和取消订阅以及通知的接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ISubject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(IObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(IObserver observer)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是具体的被观察对象<code>ConcreteSubject</code>这里主要实现具体方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title class_">ISubject</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;IObserver&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(IObserver observer)</span> &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(IObserver observer)</span> &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (IObserver observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是观察者，观察者的功能就比较少了就是实现方法等待被通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IObserver</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">IObserver</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;被观察者更新了数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后再看一下客户端的使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ISubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteSubject</span>();</span><br><span class="line">        <span class="type">IObserver</span> <span class="variable">observer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>();</span><br><span class="line">        subject.attach(observer);</span><br><span class="line">        subject.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式的优缺点"><a href="#观察者模式的优缺点" class="headerlink" title="观察者模式的优缺点"></a>观察者模式的优缺点</h3><p>优点：</p>
<ol>
<li>观察者和被观察者是松耦合（抽象耦合）的，符合依赖倒置原则</li>
<li>分离了表示层（观察者） 和数据逻辑层（被观察者），并且建立了一套触发机制，使得数据的变 化可以响应到多个表示层上；</li>
<li>实现了一对多的通讯机制，支持事件注册机制，支持兴趣分发机制，当被观察者触发事件时，只 有感兴趣的观察者可以接收到通知。</li>
</ol>
<p>缺点：</p>
<ol>
<li>如果观察者数量过多，则事件通知会耗时较长；</li>
<li>事件通知呈线性关系，如果其中一个观察者处理事件卡壳，会影响后续的观察者接收该事件；</li>
<li>如果观察者和被观察者之间存在循环依赖，则可能造成两者之间的循环调用，导致系统崩溃。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Miller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">http://example.com/2023/11/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Miller</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/" title="队列"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">队列</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/27/RocketMQ/RocketMQ/" title="RocketMQ"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RocketMQ</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Miller</div><div class="author-info__description">Miller</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dongxiaopipi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dongxiaopipi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99"><span class="toc-number">1.0.1.</span> <span class="toc-text">单一职责原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">1.0.2.</span> <span class="toc-text">接口隔离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">1.0.3.</span> <span class="toc-text">依赖倒置原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E4%BC%A0%E9%80%92%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">依赖关系传递的三种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99"><span class="toc-number">1.0.4.</span> <span class="toc-text">迪米特法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UML"><span class="toc-number">1.1.</span> <span class="toc-text">UML</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">1.饿汉式（静态常量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">2.饿汉式（静态代码块）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%89-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">3.懒汉式（线程不安全）- 不推荐使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.0.4.</span> <span class="toc-text">4.懒汉式（线程安全）- 不推荐使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5-%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E6%8E%A8%E8%8D%90"><span class="toc-number">2.1.0.5.</span> <span class="toc-text">5.双重检查-实际开发推荐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.1.0.6.</span> <span class="toc-text">6.静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.1.0.7.</span> <span class="toc-text">7.枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.0.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">简单工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">抽象工厂模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.3.1.</span> <span class="toc-text">深拷贝和浅拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">建造者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">类适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">对象适配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">接口适配器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">桥接模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.</span> <span class="toc-text">装饰者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.8.</span> <span class="toc-text">组合模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.9.</span> <span class="toc-text">外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.9.1.</span> <span class="toc-text">享元模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.10.</span> <span class="toc-text">代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%80%9A%E7%94%A8%E5%86%99%E6%B3%95"><span class="toc-number">2.10.1.</span> <span class="toc-text">代理模式的通用写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.10.2.</span> <span class="toc-text">静态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EJDK%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">2.10.2.2.</span> <span class="toc-text">基于JDK实现动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.10.2.2.1.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.11.</span> <span class="toc-text">策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E4%BB%98%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">2.11.0.1.</span> <span class="toc-text">支付案例实现（策略设计模式）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.12.</span> <span class="toc-text">责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.13.</span> <span class="toc-text">门面模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.13.0.1.</span> <span class="toc-text">门面模式应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.13.0.2.</span> <span class="toc-text">门面模式优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.14.</span> <span class="toc-text">模版方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.14.1.</span> <span class="toc-text">模板方法优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.15.</span> <span class="toc-text">迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.15.1.</span> <span class="toc-text">迭代器模式的优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.16.</span> <span class="toc-text">命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%B1%82%E5%9C%BA%E6%99%AF"><span class="toc-number">2.16.1.</span> <span class="toc-text">命令模式的应用层场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.16.2.</span> <span class="toc-text">命令模式优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.17.</span> <span class="toc-text">观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.17.1.</span> <span class="toc-text">观察者模式的优缺点</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="Mysql主从复制"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql主从复制"/></a><div class="content"><a class="title" href="/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="Mysql主从复制">Mysql主从复制</a><time datetime="2023-11-29T02:15:37.000Z" title="发表于 2023-11-29 10:15:37">2023-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/ElasticSearch/" title="ElasticSearch"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch"/></a><div class="content"><a class="title" href="/2023/11/27/ElasticSearch/" title="ElasticSearch">ElasticSearch</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/JDK/" title="JDK1.8新特性"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK1.8新特性"/></a><div class="content"><a class="title" href="/2023/11/27/JDK/" title="JDK1.8新特性">JDK1.8新特性</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/JVM/3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/" title="JVM运行时内存"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM运行时内存"/></a><div class="content"><a class="title" href="/2023/11/27/JVM/3%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98/" title="JVM运行时内存">JVM运行时内存</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/" title="匿名内部类"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="匿名内部类"/></a><div class="content"><a class="title" href="/2023/11/27/Java/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/" title="匿名内部类">匿名内部类</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Miller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>