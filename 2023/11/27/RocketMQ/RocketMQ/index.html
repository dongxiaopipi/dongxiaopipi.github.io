<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RocketMQ | 但行前路，不负韶华！</title><meta name="author" content="Miller"><meta name="copyright" content="Miller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、基本概念1、消息(Message) 消息是指，消息系统所传输的物理载体，生产和消费数据的最小单位，每个消息必须属于一个主题。 2、主题(Topic) Topic表示一类消息的集合，每个主题包含若干条消息，是RocketMQ进行消息订阅的基本单位。 一个生产者可以同时发送多种Topic的消息，而一个消费者只能订阅和消费一种Topic的消息   3、标签（TAG） 4、队列（Queue） 存储消息">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ">
<meta property="og:url" content="http://example.com/2023/11/27/RocketMQ/RocketMQ/index.html">
<meta property="og:site_name" content="但行前路，不负韶华！">
<meta property="og:description" content="一、基本概念1、消息(Message) 消息是指，消息系统所传输的物理载体，生产和消费数据的最小单位，每个消息必须属于一个主题。 2、主题(Topic) Topic表示一类消息的集合，每个主题包含若干条消息，是RocketMQ进行消息订阅的基本单位。 一个生产者可以同时发送多种Topic的消息，而一个消费者只能订阅和消费一种Topic的消息   3、标签（TAG） 4、队列（Queue） 存储消息">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2023-11-27T14:15:37.000Z">
<meta property="article:modified_time" content="2023-11-30T13:16:55.076Z">
<meta property="article:author" content="Miller">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/27/RocketMQ/RocketMQ/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Miller","link":"链接: ","source":"来源: 但行前路，不负韶华！","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-30 21:16:55'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://file.crazywong.com/gh/jerryc127/CDN@latest/Photo/tags.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="但行前路，不负韶华！"><span class="site-name">但行前路，不负韶华！</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RocketMQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-30T13:16:55.076Z" title="更新于 2023-11-30 21:16:55">2023-11-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RocketMQ/">RocketMQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>58分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><strong>1、消息(Message)</strong></p>
<p>消息是指，消息系统所传输的物理载体，生产和消费数据的最小单位，每个消息必须属于一个主题。</p>
<p><strong>2、主题(Topic)</strong></p>
<p>Topic表示一类消息的集合，每个主题包含若干条消息，是RocketMQ进行消息订阅的基本单位。</p>
<p>一个生产者可以同时发送多种Topic的消息，而一个消费者只能订阅和消费一种Topic的消息</p>
<img src="image-20221230102324138.png" alt="image-20221230102324138" style="zoom: 50%;">

<p><strong>3、标签（TAG）</strong></p>
<p><strong>4、队列（Queue）</strong></p>
<p>存储消息的物理实体。一个Topic中可以包含多个Queue，每个Queue中存放的就是该Topic的消息。一个Topic的Queue也被称为一个Topic中消息的分区。</p>
<p>一个Topic中Queue中的消息只能被一个消费者组中的一个消费者消费。一个Queue中的消息不允许同一个消费者组中的多个消费者同时消费。</p>
<img src="image-20221230102413690.png" alt="image-20221230102413690" style="zoom:50%;">

<img src="image-20221230102441974.png" alt="image-20221230102441974" style="zoom:50%;">

<p><strong>5、消息标识（MessageId&#x2F;Key）</strong></p>
<p>RocketMQ中每个消息都拥有唯一的MessageId，且可以携带具有业务标识的Key，以方便对消息的查询。不过需要注意的是，MessageId有两个：在生产者send()消息时会自动生成一个MessageId(msgId)，当消息达到Broker之后，Broker也会自动生成一个MessageId(offsetMsgId)。msgId、offsetMsgId与key都称为消息标识。</p>
<ul>
<li><p>msgId：由producer生成，其生成规则为：</p>
<p>producerIp + 进程pid + messageClientIDSetter的ClassLoader的hashCode + 当前时间 + AutomicInteger自增计数器</p>
</li>
<li><p>offsetMsgId：由broker端生成，其生成规则为：brokerIp + 物理分区的offset（也就是queue中的偏移量）</p>
</li>
<li><p>key: 由用户指定的业务相关的唯一标识</p>
</li>
</ul>
<h3 id="二、系统架构"><a href="#二、系统架构" class="headerlink" title="二、系统架构"></a>二、系统架构</h3><img src="image-20221230103543148.png" alt="image-20221230103543148">

<p>RocketMQ架构上主要分为四部分构成：</p>
<h4 id="1-Producer"><a href="#1-Producer" class="headerlink" title="1 Producer"></a>1 Producer</h4><p>消息生产者，负责生产消息。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<p>RocketMQ中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类Producer发送相同Topic类型的消息。一个生产者组可以同时发送多个主题的消息。</p>
<h4 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2 Consumer"></a>2 Consumer</h4><p>消息消费者，负责消费消息。一个消息消费者会从Broker服务器中获取到消息，并对消息进行相关业务处理。</p>
<p>RocketMQ中的消息消费者都是以消费者组（Consumer Group）的形式出现的。消费者组是同一类消费者的集合，这类Consumer消费的是同一个Topic类型的消息。消费者组使得在消息消费方面，实现负载均衡（将一个Topic中的不同的Queue平均分配给同一个Consumer Group的不同的Consumer，注意，并不是将消息负载均衡）和容错（一个Consmer挂了，该Consumer Group中的其它Consumer可以接着消费原Consumer消费的Queue）的目标变得非常容易。</p>
<img src="image-20221230143803679.png" alt="image-20221230143803679" style="zoom:50%;">



<p>消费者组中Consumer的数量应该小于等于订阅Topic的Queue数量。如果超出Queue数量，则多出的Consumer将不能消费消息。</p>
<img src="image-20221230143837912.png" alt="image-20221230143837912" style="zoom:50%;">

<p>不过，一个Topic类型的消息可以被多个消费者组同时消费。</p>
<blockquote>
<p>注意， </p>
<p><em>1</em>）消费者组只能消费一个<em>Topic</em>的消息，不能同时消费多个<em>Topic</em>消息 </p>
<p><em>2</em>）一个消费者组中的消费者必须订阅完全相同的<em>Topic</em></p>
</blockquote>
<h4 id="3-Name-Server"><a href="#3-Name-Server" class="headerlink" title="3 Name Server"></a>3 Name Server</h4><p>NameServer是一个Broker和Topic路由的注册中心，支持Broker的动态注册和发现。</p>
<p>主要包括两个功能：</p>
<ul>
<li><p>Broker管理</p>
</li>
<li><p>路由信息管理</p>
</li>
</ul>
<h4 id="4-Broker"><a href="#4-Broker" class="headerlink" title="4 Broker"></a>4 Broker</h4><p>Broker充当消息中转角色，负责存储消息、转发消息。Broker在RocketMQ系统中负责接收并存储从生产者发送来的消息，同时为消费者的拉取请求做准备。Broker同时也存储着消息相关的元数据，包括消费者组消费进度偏移offset、主题、队列等。</p>
<img src="image-20221230154313132.png" alt="image-20221230154313132" style="zoom:50%;">

<p>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。而这个Broker实体则由以下模块构成。</p>
<p>Client Manager：客户端管理器。负责接收、解析客户端(Producer&#x2F;Consumer)请求，管理客户端。例如，维护Consumer的Topic订阅信息</p>
<p>Store Service：存储服务。提供方便简单的API接口，处理消息存储到物理硬盘和消息查询功能。</p>
<p>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</p>
<p>Index Service：索引服务。根据特定的Message key，对投递到Broker的消息进行索引服务，同时也提供根据Message Key对消息进行快速查询的功能。</p>
<h3 id="三、Linux启动"><a href="#三、Linux启动" class="headerlink" title="三、Linux启动"></a>三、Linux启动</h3><h4 id="1-启动nameServer和broker"><a href="#1-启动nameServer和broker" class="headerlink" title="1.启动nameServer和broker"></a>1.启动nameServer和broker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 启动nameServer</span></span></span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证namesrv是否启动成功</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/namesrv.log</span></span><br><span class="line">The Name Server boot success...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 先启动broker</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> sh bin/mqbroker -n localhost:9876 &amp;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## 验证broker是否启动成功, 比如, broker的ip是192.168.1.2 然后名字是broker-a</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f ~/logs/rocketmqlogs/Broker.<span class="built_in">log</span></span> </span><br><span class="line">The broker[broker-a,192.169.1.2:10911] boot success...</span><br></pre></td></tr></table></figure>

<h4 id="2-消息收发"><a href="#2-消息收发" class="headerlink" title="2.消息收发"></a>2.消息收发</h4><p>在进行消息收发之前，我们需要告诉客户端NameServer的地址，RocketMQ有多种方式在客户端中设置NameServer地址，这里我们利用环境变量<code>NAMESRV_ADDR</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> NAMESRV_ADDR=localhost:9876</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span></span><br><span class="line"> SendResult [sendStatus=SEND_OK, msgId= ...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span></span><br><span class="line"><span class="meta prompt_"> ConsumeMessageThread_%</span><span class="language-bash">d Receive New Messages: [MessageExt...</span></span><br></pre></td></tr></table></figure>



<h4 id="docker启动"><a href="#docker启动" class="headerlink" title="docker启动"></a>docker启动</h4><p>1.拉取镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull rocketmqinc/rocketmq</span><br></pre></td></tr></table></figure>

<p>2.创建数据挂载目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p  /docker/rocketmq/data/namesrv/logs   /docker/rocketmq/data/namesrv/store</span><br><span class="line">mkdir -p  /docker/rocketmq/data/broker/logs   /docker/rocketmq/data/broker/store /docker/rocketmq/conf</span><br></pre></td></tr></table></figure>

<p>3.启动nameserver</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always --name rmqnamesrv - -p 9876:9876 -v /Users/dongnan/devEnv/docker/rocketmq/data/namesrv/logs:/root/logs -v /Users/dongnan/devEnv/docker/rocketmq/data/namesrv/store:/root/store -e &quot;MAX_POSSIBLE_HEAP=100000000&quot; rocketmqinc/rocketmq sh mqnamesrv</span><br></pre></td></tr></table></figure>

<p>4.编辑配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /docker/rocketmq/conf/broker.conf</span><br><span class="line"></span><br><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">broker名称，master和slave使用相同的名称，表明他们的主从关系</span></span><br><span class="line">brokerName = broker-a</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0表示Master，大于0表示不同的slave</span></span><br><span class="line">brokerId = 0</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示几点做消息删除动作，默认是凌晨4点</span></span><br><span class="line">deleteWhen = 04</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在磁盘上保留消息的时长，单位是小时</span></span><br><span class="line">fileReservedTime = 48</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有三个值：SYNC_MASTER，ASYNC_MASTER，SLAVE；同步和异步表示Master和Slave之间同步数据的机制；</span></span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">刷盘策略，取值为：ASYNC_FLUSH，SYNC_FLUSH表示同步刷盘和异步刷盘；SYNC_FLUSH消息写入磁盘后才返回成功状态，ASYNC_FLUSH不需要；</span></span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置broker节点所在服务器的ip地址</span></span><br><span class="line">brokerIP1 = 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>5.启动broker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d  \                                                                                   </span><br><span class="line">--restart=always \</span><br><span class="line">--name rmqbroker \</span><br><span class="line">--link rmqnamesrv:namesrv \</span><br><span class="line">-p 10911:10911 \</span><br><span class="line">-p 10909:10909 \</span><br><span class="line">-v  /Users/dongnan/devEnv/docker/rocketmq/data/broker/logs:/root/logs \</span><br><span class="line">-v  /Users/dongnan/devEnv/docker/rocketmq/data/broker/store:/root/store \</span><br><span class="line">-v  /Users/dongnan/devEnv/docker/rocketmq/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf \</span><br><span class="line">-e &quot;NAMESRV_ADDR=namesrv:9876&quot; \</span><br><span class="line">-e &quot;MAX_POSSIBLE_HEAP=200000000&quot; \</span><br><span class="line">rocketmqinc/rocketmq \</span><br><span class="line">sh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf</span><br></pre></td></tr></table></figure>

<p>6.部署rocketmq界面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull styletang/rocketmq-console-ng</span><br><span class="line"></span><br><span class="line">docker run -d -p 8082:8080 -e &quot;JAVA_OPTS=-Drocketmq.config.namesrvAddr=rmqnamesrv:9876 -Drocketmq.config.isVIPChannel=false&quot; styletang/rocketmq-console-ng</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="四、集群搭建"><a href="#四、集群搭建" class="headerlink" title="四、集群搭建"></a>四、集群搭建</h3><h4 id="1-数据复制和刷盘策略"><a href="#1-数据复制和刷盘策略" class="headerlink" title="1.数据复制和刷盘策略"></a>1.数据复制和刷盘策略</h4><img src="image-20230103111235999.png" alt="image-20230103111235999" style="zoom:50%;">

<p><strong>复制策略</strong></p>
<p>复制策略是Broker的Master与Slave间的数据同步方式。分为同步复制与异步复制：</p>
<ul>
<li><p>同步复制：消息写入master后，master会等待slave同步数据成功后才向producer返回成功ACK</p>
</li>
<li><p>异步复制：消息写入master后，master立即向producer返回成功ACK，无需等待slave同步数据成功</p>
</li>
</ul>
<blockquote>
<p>异步复制策略会降低系统的写入延迟，RT变小，提高了系统的吞吐量</p>
</blockquote>
<p><strong>刷盘策略</strong></p>
<p>刷盘策略指的是broker中消息的落盘方式，即消息发送到broker内存后消息持久化到磁盘的方式。分为同步刷盘与异步刷盘：</p>
<ul>
<li>同步刷盘：当消息持久化到broker的磁盘后才算是消息写入成功</li>
<li>异步刷盘：当消息写入到broker的内存后即表示消息写入成功，无需等待消息持久化到磁盘。</li>
</ul>
<p><strong>最佳实践</strong></p>
<p>一般会为Master配置RAID10磁盘阵列，然后再为其配置一个slave。即利用了RAID10磁盘阵列的高效、安全性，又解决了可能会影响订阅的问题</p>
<h3 id="五、工作原理"><a href="#五、工作原理" class="headerlink" title="五、工作原理"></a>五、工作原理</h3><h4 id="1-消息的生产"><a href="#1-消息的生产" class="headerlink" title="1.消息的生产"></a>1.消息的生产</h4><h5 id="消息的生产过程"><a href="#消息的生产过程" class="headerlink" title="消息的生产过程"></a>消息的生产过程</h5><p>Producer可以将消息写入到某broker中的某Queue中，过程如下</p>
<ul>
<li><p>Producer发送消息之前，会先向NameServer发出获取<code>消息Topic的路由信息</code>的请求</p>
</li>
<li><p>NameServer返回该<code>Topic的路由表</code>及<code>Broker列表</code></p>
</li>
<li><p>Producer根据代码中指定的Queue选择策略，从Queue列表中选出一个队列，用于后续存储消息</p>
</li>
<li><p>Producer对消息做一些特殊的处理，例如，消息本身超过4M，则进行压缩</p>
</li>
<li><p>Producer向选择出的Queue所在的broker发出RPC请求，将消息发送到选择出的Queue</p>
<blockquote>
<p>路由表：实际是一个Map，key为Topic的名称，value是一个QueueData实例列表，QueueData并不是一个Queue对应一个QueueData，而是一个Broker中该Topic的所有Queue对应一个QueueData。即，只要涉及到该<em>Topic</em>的<em>Broker</em>，一个<em>Broker</em>对应一个<em>QueueData</em>。<em>QueueData</em>中包含<em>brokerName</em>。简单来说，路由表的<em>key</em>为<em>Topic</em>名称，<em>value</em>则为所有涉及该<em>Topic</em>的 </p>
<p><em>BrokerName</em>列表。</p>
</blockquote>
<blockquote>
<p>一套<em>brokerName</em>名称相同的<em>Master-Slave</em>小集群对应一个 <em>BrokerData</em>。<em>BrokerData</em>中包含<em>brokerName</em>及一个<em>map</em>。该<em>map</em>的<em>key</em>为<em>brokerId</em>，<em>value</em>为该 <em>broker</em>对应的地址。<em>brokerId</em>为<em>0</em>表示该<em>broker</em>为<em>Master</em>，非<em>0</em>表示<em>Slave</em>。</p>
</blockquote>
</li>
</ul>
<h5 id="Queue选择算法"><a href="#Queue选择算法" class="headerlink" title="Queue选择算法"></a>Queue选择算法</h5><p>轮询算法</p>
<p>最小投递延迟算法</p>
<h4 id="2-消息的存储"><a href="#2-消息的存储" class="headerlink" title="2.消息的存储"></a>2.消息的存储</h4><ul>
<li><p>abort：该文件在Broker启动后会自动创建，正常关闭Broker，该文件会自动消失。若在没有启动Broker的情况下，发现这个文件是存在的，则说明之前Broker的关闭是非正常关闭。</p>
</li>
<li><p>checkpoint：其中存储着commitlog、consumequeue、index文件的最后刷盘时间戳</p>
</li>
<li><p>commitlog：其中存放着commitlog文件，而消息是写在commitlog文件中的</p>
</li>
<li><p>config：存放着Broker运行期间的一些配置数据</p>
</li>
<li><p>consumequeue：其中存放着consumequeue文件，队列就存放在这个目录中</p>
</li>
<li><p>index：其中存放着消息索引文件indexFile </p>
</li>
<li><p>lock：运行期间使用到的全局资源锁</p>
</li>
</ul>
<h4 id="3-Rebalance机制"><a href="#3-Rebalance机制" class="headerlink" title="3.Rebalance机制"></a>3.Rebalance机制</h4><p>​		rebalance即再均衡，指的是，将一个topic下的多个Queue在同一个Consumer Group中的多个Consumer间进行重新分配的过程。</p>
<p><strong>Rebalance限制</strong></p>
<p>​		由于⼀个队列最多分配给⼀个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列</p>
<h4 id="4-Queue分配算法"><a href="#4-Queue分配算法" class="headerlink" title="4.Queue分配算法"></a>4.Queue分配算法</h4><ul>
<li><p>平均分配策略</p>
<img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113458947.png" alt="image-20230209113458947" style="zoom:67%;">

<p>该算法是要根据<code>avg = QueueCount / ConsumerCount</code> 的计算结果进行分配的。如果能够整除，则按顺序将avg个Queue逐个分配Consumer；如果不能整除，则将多余出的Queue按照Consumer顺序逐个分配。</p>
</li>
<li><p>环形平均策略</p>
<img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113715812.png" alt="image-20230209113715812" style="zoom: 50%;">

<p>环形平均算法是指，根据消费者的顺序，依次在由queue队列组成的环形图中逐个分配。</p>
</li>
<li><p>一致性hash策略</p>
<img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113809700.png" alt="image-20230209113809700" style="zoom:50%;">

<p>该算法会将consumer的hash值作为Node节点存放到hash环上，然后将queue的hash值也放到hash环上，通过顺时针方向，距离queue最近的那个consumer就是该queue要分配的consumer。 </p>
</li>
<li><p>同机房策略</p>
<img src=":Users:dongnan:Library:Application Support:typora-user-images:image-20230209113847285.png" alt="image-20230209113847285" style="zoom:50%;"></li>
</ul>
<p>该算法会根据queue的部署机房位置和consumer的位置，过滤出当前consumer相同机房的queue。然后按照平均分配策略或环形平均策略对同机房queue进行分配。如果没有同机房queue，则按照平均分配策略或环形平均策略对所有queue进行分配。</p>
<h2 id="六、offset管理"><a href="#六、offset管理" class="headerlink" title="六、offset管理"></a>六、offset管理</h2><p>这里的offset指的是Consumer的消费进度offset。消费进度offset是用来记录每个Queue的不同消费组的消费进度的。根据消费进度记录器的不同，可以分为两种模式：本地模式和远程模式。</p>
<h3 id="1-offset本地管理模式"><a href="#1-offset本地管理模式" class="headerlink" title="1 offset本地管理模式"></a>1 offset本地管理模式</h3><p>当消费模式为广播消费时，offset使用本地模式存储。因为每条消息会被所有的消费者消费，每个消费者管理自己的消费进度，各个消费者之间不存在消费进度的交集。Consumer在广播消费模式下offset相关数据以json的形式持久化到Consumer本地磁盘文件中，默认文件路径为当前用户主目录下的.rocketmq_offsets&#x2F;${clientId}&#x2F;${group}&#x2F;Offsets.json。其中${clientId}为当前消费者id，默认为ip@DEFAULT；${group}为消费者组名称。</p>
<h3 id="2-offset远程管理模式"><a href="#2-offset远程管理模式" class="headerlink" title="2 offset远程管理模式"></a>2 offset远程管理模式</h3><p>当消费模式为集群消费时，offset使用远程模式管理。因为所有Cosnumer实例对消息采用的是均衡消费，所有Consumer共享Queue的消费进度。Consumer在集群消费模式下offset相关数据以json的形式持久化到Broker磁盘文件中，文件路径为当前用户主目录下的store&#x2F;config&#x2F;consumerOffset.json。</p>
<p>Broker启动时会加载这个文件，并写入到一个双层Map（ConsumerOffsetManager）。外层map的key为topic@group，value为内层map。内层map的key为queueId，value为offset。当发生Rebalance时，新的Consumer会从该Map中获取到相应的数据来继续消费。</p>
<p>集群模式下offset采用远程管理模式，主要是为了保证Rebalance机制。</p>
<h3 id="3-offset用途"><a href="#3-offset用途" class="headerlink" title="3 offset用途"></a>3 offset用途</h3><p>消费者是如何从最开始持续消费消息的？消费者要消费的第一条消息的起始位置是用户自己通过consumer.setConsumeFromWhere()方法指定的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.put(PropertyKeyConst.GROUP_ID, &quot;GID_jodie_test_3&quot;);</span><br><span class="line">Consumer consumer = ONSFactory.createConsumer(properties);</span><br><span class="line">consumer.subscribe(&quot;jodie_test_A&quot;, &quot;TagB&quot;, new MessageListener() &#123;</span><br><span class="line">public Action consume(Message message, ConsumeContext context) &#123;</span><br><span class="line">System.out.println(message.getMsgID());</span><br><span class="line">return Action.CommitMessage;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>在Consumer启动后，其要消费的第一条消息的起始位置常用的有三种，这三种位置可以通过枚举类型常量设置。这个枚举类型为ConsumeFromWhere。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSUME_FROM_LAST_OFFSET：从queue的当前最后一条消息开始消费</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSUME_FROM_FIRST_OFFSET：从queue的第一条消息开始消费</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONSUME_FROM_TIMESTAMP：从指定的具 体时间戳位置的消息开始消费。这个具体时间戳</span><br><span class="line">是通过另外一个语句指定的 。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeTimestamp(“20210701080000”) yyyyMMddHHmmss</span><br></pre></td></tr></table></figure>

<p>当消费完一批消息后，Consumer会提交其消费进度offset给Broker，Broker在收到消费进度后会将其更新到那个双层Map（ConsumerOffsetManager）及consumerOffset.json文件中，然后向该Consumer进行ACK，而ACK内容中包含三项数据：当前消费队列的最小offset（minOffset）、最大offset（maxOffset）、及下次消费的起始offset（nextBeginOffset）。</p>
<h3 id="4-重试队列"><a href="#4-重试队列" class="headerlink" title="4 重试队列"></a>4 重试队列</h3><p>当rocketMQ对消息的消费出现异常时，会将发生异常的消息的offset提交到Broker中的重试队列。系统在发生消息消费异常时会为当前的topic@group创建一个重试队列，该队列以%RETRY%开头，到达重试时间后进行消费重试。</p>
<h3 id="5-offset的同步提交与异步提交"><a href="#5-offset的同步提交与异步提交" class="headerlink" title="5 offset的同步提交与异步提交"></a>5 offset的同步提交与异步提交</h3><p>集群消费模式下，Consumer消费完消息后会向Broker提交消费进度offset，其提交方式分为两种：</p>
<p>​		同步提交：消费者在消费完一批消息后会向broker提交这些消息的offset，然后等待broker的成功响应。若在等待超时之前收到了成功响应，则继续读取下一批消息进行消费（从ACK中获取nextBeginOffset）。若没有收到响应，则会重新提交，直到获取到响应。而在这个等待过程中，消费者是阻塞的。其严重影响了消费者的吞吐量。</p>
<p>​		异步提交：消费者在消费完一批消息后向broker提交offset，但无需等待Broker的成功响应，可以继续读取并消费下一批消息。这种方式增加了消费者的吞吐量。但需要注意，broker在收到提交的offset后，还是会向消费者进行响应的。可能还没有收到ACK，此时Consumer会从Broker中直接获取nextBeginOffset。</p>
<h2 id="七、消费幂等"><a href="#七、消费幂等" class="headerlink" title="七、消费幂等"></a>七、消费幂等</h2><h3 id="1-什么是消费幂等"><a href="#1-什么是消费幂等" class="headerlink" title="1 什么是消费幂等"></a>1 什么是消费幂等</h3><p>​		当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。</p>
<p>​		幂等：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。</p>
<h3 id="2-消息重复的场景分析"><a href="#2-消息重复的场景分析" class="headerlink" title="2 消息重复的场景分析"></a>2 消息重复的场景分析</h3><p>什么情况下可能会出现消息被重复消费呢？最常见的有以下三种情况：</p>
<h4 id="发送时消息重复"><a href="#发送时消息重复" class="headerlink" title="发送时消息重复"></a>发送时消息重复</h4><p>当一条消息已被成功发送到Broker并完成持久化，此时出现了网络闪断，从而导致Broker对Producer应答失败。 如果此时Producer意识到消息发送失败并尝试再次发送消息，此时Broker中就可能会出现两条内容相同并且Message ID也相同的消息，那么后续Consumer就一定会消费两次该消息。</p>
<h4 id="消费时消息重复"><a href="#消费时消息重复" class="headerlink" title="消费时消息重复"></a>消费时消息重复</h4><p>消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，Broker没有接收到消费成功响应。为了保证消息至少被消费一次的原则，Broker将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。Rebalance时消息重复当Consumer Group中的Consumer数量发生变化时，或其订阅的Topic的Queue数量发生变化时，会触发Rebalance，此时Consumer可能会收到曾经被消费过的消息。</p>
<h3 id="3-通用解决方案"><a href="#3-通用解决方案" class="headerlink" title="3 通用解决方案"></a>3 通用解决方案</h3><p>两要素</p>
<p>幂等解决方案的设计中涉及到两项要素：幂等令牌，与唯一性处理。只要充分利用好这两要素，就可以设计出好的幂等解决方案。</p>
<p>幂等令牌：是生产者和消费者两者中的既定协议，通常指具备唯一业务标识的字符串。例如，订单号、流水号。一般由Producer随着消息一同发送来的。<br>唯一性处理：服务端通过采用一定的算法策略，保证同一个业务逻辑不会被重复执行成功多次。<br>例如，对同一笔订单的多次支付操作，只会成功一次。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>对于常见的系统，幂等性操作的通用性解决方案是：</p>
<ol>
<li><p>首先通过缓存去重。在缓存中如果已经存在了某幂等令牌，则说明本次操作是重复性操作；若缓存没有命中，则进入下一步。</p>
</li>
<li><p>在唯一性处理之前，先在数据库中查询幂等令牌作为索引的数据是否存在。若存在，则说明本次操作为重复性操作；若不存在，则进入下一步。</p>
</li>
<li><p>在同一事务中完成三项操作：唯一性处理后，将幂等令牌写入到缓存，并将幂等令牌作为唯一索引的数据写入到DB中。</p>
</li>
</ol>
<p>第 1 步已经判断过是否是重复性操作了，为什么第 2 步还要再次判断？能够进入第 2 步，说明已经不是重复操作了，第 2 次判断是否重复？当然不重复。一般缓存中的数据是具有有效期的。缓存中数据的有效期一旦过期，就是发生缓存穿透，使请求直接就到达了DBMS。</p>
<h4 id="解决方案举例"><a href="#解决方案举例" class="headerlink" title="解决方案举例"></a>解决方案举例</h4><h4 id="以支付场景为例："><a href="#以支付场景为例：" class="headerlink" title="以支付场景为例："></a>以支付场景为例：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 当支付请求到达后，首先在Redis缓存中却获取key为支付流水号的缓存value。若value不空，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若value为空，则进入下一步操作</span><br><span class="line">2. 到DBMS中根据支付流水号查询是否存在相应实例。若存在，则说明本次支付是重复操作，业务系统直接返回调用侧重复支付标识；若不存在，则说明本次操作是首次操作，进入下一步完成唯一性处理</span><br><span class="line">3. 在分布式事务中完成三项操作：</span><br><span class="line">	完成支付任务</span><br><span class="line">	将当前支付流水号作为key，任意字符串作为value，通过set(key, value, expireTime)将数据写入到Redis缓存</span><br><span class="line">	将当前支付流水号作为主键，与其它相关数据共同写入到DBMS</span><br></pre></td></tr></table></figure>

<h3 id="4-消费幂等的实现"><a href="#4-消费幂等的实现" class="headerlink" title="4 消费幂等的实现"></a>4 消费幂等的实现</h3><p>消费幂等的解决方案很简单：为消息指定不会重复的唯一标识。因为Message ID有可能出现重复的情况，所以真正安全的幂等处理，不建议以Message ID作为处理依据。最好的方式是以业务唯一标识作为幂等处理的关键依据，而业务的唯一标识可以通过消息Key设置。</p>
<p>以支付场景为例，可以将消息的Key设置为订单号，作为幂等处理的依据。具体代码示例如下：</p>
<p>消费者收到消息时可以根据消息的Key即订单号来实现消费幂等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Message message = new Message();</span><br><span class="line">message.setKey(&quot;ORDERID_100&quot;);</span><br><span class="line">SendResult sendResult = producer.send(message);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>RocketMQ能够保证消息不丢失，但不能保证消息不重复。</p>
<h2 id="八、消息堆积与消费延迟"><a href="#八、消息堆积与消费延迟" class="headerlink" title="八、消息堆积与消费延迟"></a>八、消息堆积与消费延迟</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><p>消息处理流程中，如果Consumer的消费速度跟不上Producer的发送速度，MQ中未处理的消息会越来越多（进的多出的少），这部分消息就被称为堆积消息。消息出现堆积进而会造成消息的消费延迟。</p>
<p>以下场景需要重点关注消息堆积和消费延迟问题：</p>
<p>​		业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</p>
<p>​		业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消费延迟也无法接受。</p>
<h3 id="2-产生原因分析"><a href="#2-产生原因分析" class="headerlink" title="2 产生原因分析"></a>2 产生原因分析</h3><p>Consumer使用长轮询Pull模式消费消息时，分为以下两个阶段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt;</span><br><span class="line">msgs,</span><br><span class="line">ConsumeConcurrentlyContext</span><br><span class="line">context) &#123;</span><br><span class="line">for(MessageExt msg:msgs)&#123;</span><br><span class="line">String key = msg.getKeys();</span><br><span class="line">// 根据业务唯一标识Key做幂等处理</span><br><span class="line">// ......</span><br><span class="line">&#125;</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h4 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h4><p>Consumer通过长轮询Pull模式批量拉取的方式从服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。对于拉取式消费，在内网环境下会有很高的吞吐量，所以这一阶段一般不会成为消息堆积的瓶颈。</p>
<p>一个单线程单分区的低规格主机(Consumer，4C8G)，其可达到几万的TPS。如果是多个分区多个线程，则可以轻松达到几十万的TPS。</p>
<h4 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a>消息消费</h4><p>Consumer将本地缓存的消息提交到消费线程中，使用业务消费逻辑对消息进行处理，处理完毕后获取到一个结果。这是真正的消息消费过程。此时Consumer的消费能力就完全依赖于消息的消费耗时和消费并发度了。如果由于业务处理逻辑复杂等原因，导致处理单条消息的耗时较长，则整体的消息吞吐量肯定不会高，此时就会导致Consumer本地缓冲队列达到上限，停止从服务端拉取消息。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由消费耗时和消费并发度决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。</p>
<h3 id="3-消费耗时"><a href="#3-消费耗时" class="headerlink" title="3 消费耗时"></a>3 消费耗时</h3><p>​		影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型：CPU内部计算型代码和外部I&#x2F;O操作型代码。通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部I&#x2F;O操作来说几乎可以忽略。所以外部IO型代码是影响消息处理时长的主要症结所在。外部IO操作型代码举例：</p>
<ul>
<li>读写外部数据库，例如对远程MySQL的访问</li>
<li>读写外部缓存系统，例如对远程Redis的访问</li>
<li>下游系统调用，例如Dubbo的RPC远程调用，Spring Cloud的对下游系统的Http接口调用</li>
</ul>
<p>关于下游系统调用逻辑需要进行提前梳理，掌握每个调用操作预期的耗时，这样做是为了能够判断消费逻辑中IO操作的耗时是否合理。通常消息堆积是由于下游系统出现了服务异常或达到了DBMS容量限制，导致消费耗时增加。服务异常，并不仅仅是系统中出现的类似 500 这样的代码错误，而可能是更加隐蔽的问题。例如，网络带宽问题。达到了DBMS容量限制，其也会引发消息的消费耗时增加。</p>
<h3 id="4-消费并发度"><a href="#4-消费并发度" class="headerlink" title="4 消费并发度"></a>4 消费并发度</h3><p>一般情况下，消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为单节点线程数*节点数量。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。</p>
<ul>
<li><p>单节点线程数，即单个Consumer所包含的线程数量</p>
</li>
<li><p>节点数量，即Consumer Group所包含的Consumer数量</p>
</li>
</ul>
<p>对于普通消息、延时消息及事务消息，并发度计算都是单节点线程数*节点数量。但对于顺序消息则是不同的。顺序消息的消费并发度等于Topic的Queue分区数量。</p>
<p>​		1 ）全局顺序消息：该类型消息的Topic只有一个Queue分区。其可以保证该Topic的所有消息被顺序消费。为了保证这个全局顺序性，Consumer Group中在同一时刻只能有一个Consumer的一个线程进行消费。所以其并发度为 1 。</p>
<p>​		2 ）分区顺序消息：该类型消息的Topic有多个Queue分区。其仅可以保证该Topic的每个Queue分区中的消息被顺序消费，不能保证整个Topic中消息的顺序消费。为了保证这个分区顺序性，每个Queue分区中的消息在Consumer Group中的同一时刻只能有一个Consumer的一个线程进行消费。即，在同一时刻最多会出现多个Queue分蘖有多个Consumer的多个线程并行消费。所以其并发度为Topic的分区数量。</p>
<h4 id><a href="#" class="headerlink" title></a></h4><h2 id="九、消息的清理"><a href="#九、消息的清理" class="headerlink" title="九、消息的清理"></a>九、消息的清理</h2><h4 id="消息被消费过后会被清理掉吗？不会的。"><a href="#消息被消费过后会被清理掉吗？不会的。" class="headerlink" title="消息被消费过后会被清理掉吗？不会的。"></a>消息被消费过后会被清理掉吗？不会的。</h4><p>消息是被顺序存储在commitlog文件的，且消息大小不定长，所以消息的清理是不可能以消息为单位进行清理的，而是以commitlog文件为单位进行清理的。否则会急剧下降清理效率，并实现逻辑复杂。commitlog文件存在一个过期时间，默认为 72 小时，即三天。除了用户手动清理外，在以下情况下也会被自动清理，无论文件中的消息是否被消费过：</p>
<p>文件过期，且到达清理时间点（默认为凌晨 4 点）后，自动清理过期文件</p>
<p>文件过期，且磁盘空间占用率已达过期清理警戒线（默认75%）后，无论是否达到清理时间点，都会自动清理过期文件</p>
<p>磁盘占用率达到清理警戒线（默认85%）后，开始按照设定好的规则清理文件，无论是否过期。</p>
<p>默认会从最老的文件开始清理</p>
<p>&#x3D;&#x3D;磁盘占用率达到系统危险警戒线（默认90%）后，Broker将拒绝消息写入&#x3D;&#x3D;</p>
<h4 id="需要注意以下几点："><a href="#需要注意以下几点：" class="headerlink" title="需要注意以下几点："></a>需要注意以下几点：</h4><p>1 ）对于RocketMQ系统来说，删除一个1G大小的文件，是一个压力巨大的IO操作。在删除过程中，系统性能会骤然下降。所以，其默认清理时间点为凌晨 4 点，访问量最小的时间。也正因如果，我们要保障磁盘空间的空闲率，不要使系统出现在其它时间点删除commitlog文件的情况。</p>
<p>2 ）官方建议RocketMQ服务的Linux文件系统采用ext4。因为对于文件删除操作，ext4要比ext3性能更好</p>
<h2 id="第-4-章-RocketMQ应用"><a href="#第-4-章-RocketMQ应用" class="headerlink" title="第 4 章 RocketMQ应用"></a>第 4 章 RocketMQ应用</h2><h2 id="一、普通消息"><a href="#一、普通消息" class="headerlink" title="一、普通消息"></a>一、普通消息</h2><h3 id="1-消息发送分类"><a href="#1-消息发送分类" class="headerlink" title="1 消息发送分类"></a>1 消息发送分类</h3><p>Producer对于消息的发送方式也有多种选择，不同的方式会产生不同的系统效果。</p>
<h4 id="同步发送消息"><a href="#同步发送消息" class="headerlink" title="同步发送消息"></a>同步发送消息</h4><p>同步发送消息是指，Producer发出一条消息后，会在收到MQ返回的ACK之后才发下一条消息。该方式的消息可靠性最高，但消息发送效率太低。</p>
<h4 id="异步发送消息"><a href="#异步发送消息" class="headerlink" title="异步发送消息"></a>异步发送消息</h4><p>异步发送消息是指，Producer发出消息后无需等待MQ返回ACK，直接发送下一条消息。该方式的消息可靠性可以得到保障，消息发送效率也可以。</p>
<h4 id="单向发送消息"><a href="#单向发送消息" class="headerlink" title="单向发送消息"></a>单向发送消息</h4><p>单向发送消息是指，Producer仅负责发送消息，不等待、不处理MQ的ACK。该发送方式时MQ也不返回ACK。该方式的消息发送效率最高，但消息可靠性较差。</p>
<h2 id="二、顺序消息"><a href="#二、顺序消息" class="headerlink" title="二、顺序消息"></a>二、顺序消息</h2><h3 id="1-什么是顺序消息"><a href="#1-什么是顺序消息" class="headerlink" title="1 什么是顺序消息"></a>1 什么是顺序消息</h3><p>顺序消息指的是，严格按照消息的发送顺序进行消费的消息(FIFO)。</p>
<p>默认情况下生产者会把消息以Round Robin轮询方式发送到不同的Queue分区队列；而消费消息时会从多个Queue上拉取消息，这种情况下的发送和消费是不能保证顺序的。如果将消息仅发送到同一个Queue中，消费时也只从这个Queue上拉取消息，就严格保证了消息的顺序性。</p>
<h3 id="2-有序性分类"><a href="#2-有序性分类" class="headerlink" title="2 有序性分类"></a>2 有序性分类</h3><p>根据有序范围的不同，RocketMQ可以严格地保证两种消息的有序性：&#x3D;&#x3D;分区有序与全局有序&#x3D;&#x3D;。</p>
<h4 id="全局有序"><a href="#全局有序" class="headerlink" title="全局有序"></a>全局有序</h4><p>当发送和消费参与的Queue只有一个时所保证的有序是整个Topic中消息的顺序， 称为全局有序。</p>
<p>在创建Topic时指定Queue的数量。有三种指定方式：</p>
<p>1 ）在代码中创建Producer时，可以指定其自动创建的Topic的Queue数量</p>
<p>2 ）在RocketMQ可视化控制台中手动创建Topic时指定Queue数量</p>
<p>3 ）使用mqadmin命令手动创建Topic时指定Queue数量</p>
<h4 id="分区有序"><a href="#分区有序" class="headerlink" title="分区有序"></a>分区有序</h4><p>​		如果有多个Queue参与，其仅可保证在该Queue分区队列上的消息顺序，则称为分区有序。</p>
<p>​		如何实现Queue的选择？在定义Producer时我们可以指定消息队列选择器，而这个选择器是我们自己实现了MessageQueueSelector接口定义的。在定义选择器的选择算法时，一般需要使用选择key。这个选择key可以是消息key也可以是其它数据。但无论谁做选择key，都不能重复，都是唯一的。</p>
<p>​		一般性的选择算法是，让选择key（或其hash值）与该Topic所包含的Queue的数量取模，其结果即为选择出的Queue的QueueId。</p>
<p>​		取模算法存在一个问题：不同选择key与Queue数量取模结果可能会是相同的，即不同选择key的消息可能会出现在相同的Queue，即同一个Consuemr可能会消费到不同选择key的消息。这个问题如何解决？一般性的作法是，从消息中获取到选择key，对其进行判断。若是当前Consumer需要消费的消息，则直接消费，否则，什么也不做。这种做法要求选择key要能够随着消息一起被Consumer获取到。此时使用消息key作为选择key是比较好的做法。</p>
<p>​		以上做法会不会出现如下新的问题呢？不属于那个Consumer的消息被拉取走了，那么应该消费该消息的Consumer是否还能再消费该消息呢？同一个Queue中的消息不可能被同一个Group中的不同Consumer同时消费。所以，消费现一个Queue的不同选择key的消息的Consumer一定属于不同的Group。而不同的Group中的Consumer间的消费是相互隔离的，互不影响的。</p>
<h2 id="三、延时消息"><a href="#三、延时消息" class="headerlink" title="三、延时消息"></a>三、延时消息</h2><h3 id="1-什么是延时消息"><a href="#1-什么是延时消息" class="headerlink" title="1 什么是延时消息"></a>1 什么是延时消息</h3><p>当消息写入到Broker后，在指定的时长后才可被消费处理的消息，称为延时消息。采用RocketMQ的延时消息可以实现定时任务的功能，而无需使用定时器。典型的应用场景是，电商交易中超时未支付关闭订单的场景， 12306 平台订票超时未支付取消订票的场景。</p>
<p>在电商平台中，订单创建时会发送一条延迟消息。这条消息将会在 30 分钟后投递给后台业务系统（Consumer），后台业务系统收到该消息后会判断对应的订单是否已经完成支付。如果未完成，则取消订单，将商品再次放回到库存；如果完成支付，则忽略。</p>
<h3 id="2-延时等级"><a href="#2-延时等级" class="headerlink" title="2 延时等级"></a>2 延时等级</h3><p>延时消息的延迟时长不支持随意时长的延迟，是通过特定的延迟等级来指定的。延时等级定义在RocketMQ服务端MessageStoreConfig类中的如下变量中：</p>
<p>即，若指定的延时等级为 3 ，则表示延迟时长为10s，即延迟等级是从 1 开始计数的。当然，如果需要自定义的延时等级，可以通过在broker加载的配置中新增如下配置（例如下面增加了 1天这个等级1d）。配置文件在RocketMQ安装目录下的conf目录中。</p>
<h3 id="3-延时消息实现原理"><a href="#3-延时消息实现原理" class="headerlink" title="3 延时消息实现原理"></a>3 延时消息实现原理</h3><p>messageDelayLevel &#x3D; 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m1h 2h 1d</p>
<p>1</p>
<h4 id="具体实现方案是："><a href="#具体实现方案是：" class="headerlink" title="具体实现方案是："></a>具体实现方案是：</h4><h4 id="修改消息"><a href="#修改消息" class="headerlink" title="修改消息"></a>修改消息</h4><p>​		Producer将消息发送到Broker后，Broker会首先将消息写入到commitlog文件，然后需要将其分发到相应的consumequeue。不过，在分发之前，系统会先判断消息中是否带有延时等级。若没有，则直接正常分发；若有则需要经历一个复杂的过程：</p>
<p>​		修改消息的Topic为SCHEDULE_TOPIC_XXXX</p>
<p>​		根据延时等级，在consumequeue目录中SCHEDULE_TOPIC_XXXX主题下创建出相应的queueId目录与consumequeue文件（如果没有这些目录与文件的话）。</p>
<p>​		延迟等级delayLevel与queueId的对应关系为queueId &#x3D; delayLevel -1</p>
<p>​		需要注意，在创建queueId目录时，并不是一次性地将所有延迟等级对应的目录全部创建完毕，而是用到哪个延迟等级创建哪个目录</p>
<p>​		修改消息索引单元内容。索引单元中的Message Tag HashCode部分原本存放的是消息的Tag的Hash值。现修改为消息的投递时间。投递时间是指该消息被重新修改为原Topic后再次被写入到commitlog中的时间。投递时间 &#x3D; 消息存储时间 + 延时等级时间。消息存储时间指的是消息被发送到Broker时的时间戳。将消息索引写入到SCHEDULE_TOPIC_XXXX主题下相应的consumequeue中		SCHEDULE_TOPIC_XXXX目录中各个延时等级Queue中的消息是如何排序的？</p>
<p>​		是按照消息投递时间排序的。一个Broker中同一等级的所有延时消息会被写入到consumequeue目录中SCHEDULE_TOPIC_XXXX目录下相同Queue中。即一个Queue中消息投递时间的延迟等级时间是相同的。那么投递时间就取决于于消息存储时间了。即按照消息被发送到Broker的时间进行排序的。</p>
<p>投递延时消息</p>
<p>​		Broker内部有一个延迟消息服务类ScheuleMessageService，其会消费SCHEDULE_TOPIC_XXXX中的消息，即按照每条消息的投递时间，将延时消息投递到目标Topic中。不过，在投递之前会从commitlog中将原来写入的消息再次读出，并将其原来的延时等级设置为 0 ，即原消息变为了一条不延迟的普通消息。然后再次将消息投递到目标Topic中。</p>
<p>​		ScheuleMessageService在Broker启动时，会创建并启动一个定时器TImer，用于执行相应的定时任务。系统会根据延时等级的个数，定义相应数量的TimerTask，每个TimerTask负责一个延迟等级消息的消费与投递。每个TimerTask都会检 测相应Queue队列的第一条消息是否到期。若第一条消息未到期，则后面的所有消息更不会到期（消息是按照投递时间排序的）；若第一条消息到期了，则将该消息投递到目标Topic，即消费该消息。</p>
<p>将消息重新写入commitlog</p>
<p>延迟消息服务类ScheuleMessageService将延迟消息再次发送给了commitlog，并再次形成新的消息索引条目，分发到相应Queue。</p>
<p>这其实就是一次普通消息发送。只不过这次的消息Producer是延迟消息服务类ScheuleMessageService。</p>
<h2 id="四、事务消息"><a href="#四、事务消息" class="headerlink" title="四、事务消息"></a>四、事务消息</h2><h3 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1 问题引入"></a>1 问题引入</h3><p>​		这里的一个需求场景是：工行用户A向建行用户B转账 1 万元。</p>
<p>​		我们可以使用同步消息来处理该需求场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 工行系统发送一个给B增款 1 万元的同步消息M给Broker</span><br><span class="line">2. 消息被Broker成功接收后，向工行系统发送成功ACK</span><br><span class="line">3. 工行系统收到成功ACK后从用户A中扣款 1 万元</span><br><span class="line">4. 建行系统从Broker中获取到消息M</span><br><span class="line">5. 建行系统消费消息M，即向用户B中增加 1 万元</span><br></pre></td></tr></table></figure>

<p>​		这其中是有问题的：若第 3 步中的扣款操作失败，但消息已经成功发送到了Broker。对于MQ来说，只要消息写入成功，那么这个消息就可以被消费。此时建行系统中用户B增加了 1 万元。出现了数据不一致问题。</p>
<h3 id="2-解决思路"><a href="#2-解决思路" class="headerlink" title="2 解决思路"></a>2 解决思路</h3><p>​		解决思路是，让第 1 、 2 、 3 步具有原子性，要么全部成功，要么全部失败。即消息发送成功后，必须要保证扣款成功。如果扣款失败，则回滚发送成功的消息。而该思路即使用事务消息。这里要使用分布式事务解决方案。使用事务消息来处理该需求场景：</p>
<ol>
<li><p>事务管理器TM向事务协调器TC发起指令，开启全局事务</p>
</li>
<li><p>工行系统发一个给B增款 1 万元的事务消息M给TC</p>
</li>
<li><p>TC会向Broker发送半事务消息prepareHalf，将消息M预提交到Broker。此时的建行系统是看不到Broker中的消息M的</p>
</li>
<li><p>Broker会将预提交执行结果Report给TC。</p>
</li>
<li><p>如果预提交失败，则TC会向TM上报预提交失败的响应，全局事务结束；如果预提交成功，TC会调用工行系统的回调操作，去完成工行用户A的预扣款 1 万元的操作</p>
</li>
<li><p>工行系统会向TC发送预扣款执行结果，即本地事务的执行状态</p>
</li>
<li><p>TC收到预扣款执行结果后，会将结果上报给TM。</p>
</li>
<li><p>TM会根据上报结果向TC发出不同的确认指令</p>
</li>
<li><p>TC在接收到指令后会向Broker与工行系统发出确认指令</p>
</li>
</ol>
<h4 id="预扣款执行结果存在三种可能性："><a href="#预扣款执行结果存在三种可能性：" class="headerlink" title="预扣款执行结果存在三种可能性："></a>预扣款执行结果存在三种可能性：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 描述本地事务执行状态</span><br><span class="line">public enum LocalTransactionState &#123;</span><br><span class="line">COMMIT_MESSAGE,  // 本地事务执行成功</span><br><span class="line">ROLLBACK_MESSAGE,  // 本地事务执行失败</span><br><span class="line">UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-TM会根据上报结果向TC发出不同的确认指令"><a href="#8-TM会根据上报结果向TC发出不同的确认指令" class="headerlink" title="8. TM会根据上报结果向TC发出不同的确认指令"></a>8. TM会根据上报结果向TC发出不同的确认指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">若预扣款成功（本地事务状态为COMMIT_MESSAGE），则TM向TC发送Global Commit指令</span><br><span class="line">若预扣款失败（本地事务状态为ROLLBACK_MESSAGE），则TM向TC发送Global Rollback指令</span><br><span class="line">若现未知状态（本地事务状态为UNKNOW），则会触发工行系统的本地事务状态回查操作。回</span><br><span class="line">查操作会将回查结果，即COMMIT_MESSAGE或ROLLBACK_MESSAGE Report给TC。TC将结果上</span><br><span class="line">报给TM，TM会再向TC发送最终确认指令Global Commit或Global Rollback</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TC接收的若是Global Commit指令，则向Broker与工行系统发送Branch Commit指令。此时Broker中的消息M才可被建行系统看到；此时的工行用户A中的扣款操作才真正被确认TC接收到的若是Global Rollback指令，则向Broker与工行系统发送Branch Rollback指令。此时Broker中的消息M将被撤销；工行用户A中的扣款操作将被回滚</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以上方案就是为了确保消息投递与扣款操作能够在一个事务中，要成功都成功，有一个失败，则全部回滚。</span><br></pre></td></tr></table></figure>

<p>以上方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>
<h3 id="3-基础"><a href="#3-基础" class="headerlink" title="3 基础"></a>3 基础</h3><p>分布式事务</p>
<p>对于分布式事务，通俗地说就是，一次操作由若干分支操作组成，这些分支操作分属不同应用，分布在不同服务器上。分布式事务需要保证这些分支操作要么全部成功，要么全部失败。分布式事务与普通事务一样，就是为了保证操作结果的一致性。</p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ提供了类似X&#x2F;Open XA的分布式事务功能，通过事务消息能达到分布式事务的最终一致。XA是一种分布式事务解决方案，一种分布式事务处理模式。</p>
<h4 id="半事务消息"><a href="#半事务消息" class="headerlink" title="半事务消息"></a>半事务消息</h4><p>暂不能投递的消息，发送方已经成功地将消息发送到了Broker，但是Broker未收到最终确认指令，此时该消息被标记成“暂不能投递”状态，即不能被消费者看到。处于该种状态下的消息即半事务消息。</p>
<h4 id="本地事务状态"><a href="#本地事务状态" class="headerlink" title="本地事务状态"></a>本地事务状态</h4><p>Producer回调操作执行的结果为本地事务状态，其会发送给TC，而TC会再发送给TM。TM会根据TC发送来的本地事务状态来决定全局事务确认指令。</p>
<h4 id="消息回查"><a href="#消息回查" class="headerlink" title="消息回查"></a>消息回查</h4><p>消息回查，即重新查询本地事务的执行状态。本例就是重新到DB中查看预扣款操作是否执行成功。注意，消息回查不是重新执行回调操作。回调操作是进行预扣款操作，而消息回查则是查看预扣款操作执行的结果。</p>
<p>引发消息回查的原因最常见的有两个：</p>
<p>1)回调操作返回UNKNWON</p>
<p>2)TC没有接收到TM的最终全局事务确认指令</p>
<p>RocketMQ中的消息回查设置</p>
<p>关于消息回查，有三个常见的属性设置。它们都在broker加载的配置文件中设置，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 描述本地事务执行状态</span><br><span class="line">public enum LocalTransactionState &#123;</span><br><span class="line">COMMIT_MESSAGE,  // 本地事务执行成功</span><br><span class="line">ROLLBACK_MESSAGE,  // 本地事务执行失败</span><br><span class="line">UNKNOW,  // 不确定，表示需要进行回查以确定本地事务的执行结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transactionTimeout=20，指定TM在 20 秒内应将最终确认状态发送给TC，否则引发消息回查。默</span><br><span class="line">认为 60 秒</span><br><span class="line">transactionCheckMax=5，指定最多回查 5 次，超过后将丢弃消息并记录错误日志。默认 15 次。</span><br><span class="line">transactionCheckInterval=10，指定设置的多次消息回查的时间间隔为 10 秒。默认为 60 秒。</span><br></pre></td></tr></table></figure>

<h3 id="4-XA模式三剑客"><a href="#4-XA模式三剑客" class="headerlink" title="4 XA模式三剑客"></a>4 XA模式三剑客</h3><h4 id="XA协议"><a href="#XA协议" class="headerlink" title="XA协议"></a>XA协议</h4><p>XA（Unix Transaction）是一种分布式事务解决方案，一种分布式事务处理模式，是基于XA协议的。XA协议由Tuxedo（Transaction for Unix has been Extended for Distributed Operation，分布式操作扩展之后的Unix事务系统）首先提出的，并交给X&#x2F;Open组织，作为资源管理器与事务管理器的接口标准。</p>
<p>XA模式中有三个重要组件：TC、TM、RM。TC</p>
<p>Transaction Coordinator，事务协调者。维护全局和分支事务的状态，驱动全局事务提交或回滚。RocketMQ中Broker充当着TC。</p>
<h4 id="TM"><a href="#TM" class="headerlink" title="TM"></a>TM</h4><p>Transaction Manager，事务管理器。定义全局事务的范围：开始全局事务、提交或回滚全局事务。它实际是全局事务的发起者。RocketMQ中事务消息的Producer充当着TM。</p>
<h4 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h4><p>Resource Manager，资源管理器。管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。RocketMQ中事务消息的Producer及Broker均是RM。</p>
<h3 id="5-XA模式架构"><a href="#5-XA模式架构" class="headerlink" title="5 XA模式架构"></a>5 XA模式架构</h3><p>XA模式是一个典型的2PC，其执行原理如下：</p>
<ol>
<li><p>TM向TC发起指令，开启一个全局事务。</p>
</li>
<li><p>根据业务要求，各个RM会逐个向TC注册分支事务，然后TC会逐个向RM发出预执行指令。</p>
</li>
<li><p>各个RM在接收到指令后会在进行本地事务预执行。</p>
</li>
<li><p>RM将预执行结果Report给TC。当然，这个结果可能是成功，也可能是失败。</p>
</li>
<li><p>TC在接收到各个RM的Report后会将汇总结果上报给TM，根据汇总结果TM会向TC发出确认指令。若所有结果都是成功响应，则向TC发送Global Commit指令。只要有结果是失败响应，则向TC发送Global Rollback指令。</p>
</li>
<li><p>TC在接收到指令后再次向RM发送确认指令。事务消息方案并不是一个典型的XA模式。因为XA模式中的分支事务是异步的，而事务消息方案中的消息预提交与预扣款操作间是同步的。</p>
</li>
</ol>
<h3 id="6-注意"><a href="#6-注意" class="headerlink" title="6 注意"></a>6 注意</h3><p>事务消息不支持延时消息</p>
<p>对于事务消息要做好幂等性检查，因为事务消息可能不止一次被消费（因为存在回滚后再提交的情况）</p>
<h3 id="7-代码举例"><a href="#7-代码举例" class="headerlink" title="7 代码举例"></a>7 代码举例</h3><p>定义工行事务监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ICBCTransactionListener</span> <span class="keyword">implements</span> <span class="title class_">TransactionListener</span> &#123;</span><br><span class="line"><span class="comment">// 回调操作方法</span></span><br><span class="line"><span class="comment">// 消息预提交成功就会触发该方法的执行，用于完成本地事务</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> LocalTransactionState <span class="title function_">executeLocalTransaction</span><span class="params">(Message msg,</span></span><br><span class="line"><span class="params">Object arg)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;预提交消息成功：&quot;</span> + msg);</span><br><span class="line"><span class="comment">// 假设接收到TAGA的消息就表示扣款操作成功，TAGB的消息表示扣款失败，</span></span><br><span class="line"><span class="comment">// TAGC表示扣款结果不清楚，需要执行消息回查</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGA&quot;</span>, msg.getTags())) &#123;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGB&quot;</span>, msg.getTags())) &#123;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(<span class="string">&quot;TAGC&quot;</span>, msg.getTags())) &#123;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息回查方法</span><br><span class="line">// 引发消息回查的原因最常见的有两个：</span><br><span class="line">// 1)回调操作返回UNKNWON</span><br><span class="line">// 2)TC没有接收到TM的最终全局事务确认指令</span><br><span class="line">@Override</span><br><span class="line">public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">System.out.println(&quot;执行消息回查&quot; + msg.getTags());</span><br><span class="line">return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义事物消息生产者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TransactionProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">TransactionMQProducer producer = new</span><br><span class="line">TransactionMQProducer(&quot;tpg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义一个线程池</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> corePoolSize 线程池中核心线程数量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> maximumPoolSize 线程池中最多线程数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> keepAliveTime 这是一个时间。当线程池中线程数量大于核心线程数量</span></span><br><span class="line"><span class="comment">是，直接使用普通消息的SomeConsumer作为消费者即可。</span></span><br><span class="line"><span class="comment">* 多余空闲线程的存活时长</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> workQueue 临时存放任务的队列，其参数就是队列的长度</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>( <span class="number">2</span> , <span class="number">5</span> ,</span><br><span class="line"><span class="number">100</span> , TimeUnit.SECONDS,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;( <span class="number">2000</span> ), <span class="keyword">new</span></span><br><span class="line"><span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">thread.setName(<span class="string">&quot;client-transaction-msg-check-thread&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="定义消费者"><a href="#定义消费者" class="headerlink" title="定义消费者"></a>定义消费者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 为生产者指定一个线程池</span><br><span class="line">producer.setExecutorService(executorService);</span><br><span class="line">// 为生产者添加事务监听器</span><br><span class="line">producer.setTransactionListener(new ICBCTransactionListener());</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String[] tags = &#123;&quot;TAGA&quot;,&quot;TAGB&quot;,&quot;TAGC&quot;&#125;;</span><br><span class="line">for (int i = 0 ; i &lt; 3 ; i++) &#123;</span><br><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">Message msg = new Message(&quot;TTopic&quot;, tags[i], body);</span><br><span class="line">// 发送事务消息</span><br><span class="line">// 第二个参数用于指定在执行本地事务时要使用的业务参数</span><br><span class="line">SendResult sendResult =</span><br><span class="line">producer.sendMessageInTransaction(msg,null);</span><br><span class="line">System.out.println(&quot;发送结果为：&quot; +</span><br><span class="line">sendResult.getSendStatus());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SomeConsumer &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">// 定义一个pull消费者</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title></a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// DefaultLitePullConsumer consumer = new</span><br><span class="line">DefaultLitePullConsumer(&quot;cg&quot;);</span><br><span class="line">// 定义一个push消费者</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">// 指定nameServer</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 指定从第一条消息开始消费</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">// 指定消费topic与tag</span><br><span class="line">consumer.subscribe(&quot;TTopic&quot;, &quot;*&quot;);</span><br><span class="line">// 指定采用“广播模式”进行消费，默认为“集群模式”</span><br><span class="line">// consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注册消息监听器</span><br><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一旦broker中有了其订阅的消息就会触发该方法的执行，</span><br><span class="line">// 其返回值为当前consumer消费的状态</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">// 逐条消费消息</span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">// 返回消费状态：消费成功</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 开启消费者消费</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、批量消息"><a href="#五、批量消息" class="headerlink" title="五、批量消息"></a>五、批量消息</h2><h3 id="1-批量发送消息"><a href="#1-批量发送消息" class="headerlink" title="1 批量发送消息"></a>1 批量发送消息</h3><h4 id="发送限制"><a href="#发送限制" class="headerlink" title="发送限制"></a>发送限制</h4><p>生产者进行消息发送时可以一次发送多条消息，这可以大大提升Producer的发送效率。不过需要注意以<br>下几点：</p>
<p>​		批量发送的消息必须具有相同的Topic<br>​		批量发送的消息必须具有相同的刷盘策略<br>​		批量发送的消息不能是延时消息与事务消息</p>
<h4 id="批量发送大小"><a href="#批量发送大小" class="headerlink" title="批量发送大小"></a>批量发送大小</h4><p>默认情况下，一批发送的消息总大小不能超过4MB字节。如果想超出该值，有两种解决方案：</p>
<p>方案一：将批量消息进行拆分，拆分为若干不大于4M的消息集合分多次批量发送</p>
<p>方案二：在Producer端与Broker端修改属性</p>
<p>​		Producer端需要在发送之前设置Producer的maxMessageSize属性</p>
<p>​		Broker端需要修改其加载的配置文件中的maxMessageSize属性</p>
<h4 id="生产者发送的消息大小"><a href="#生产者发送的消息大小" class="headerlink" title="生产者发送的消息大小"></a>生产者发送的消息大小</h4><p>生产者通过send()方法发送的Message，并不是直接将Message序列化后发送到网络上的，而是通过这个Message生成了一个字符串发送出去的。这个字符串由四部分构成：Topic、消息Body、消息日志（占 20 字节），及用于描述消息的一堆属性key-value。这些属性中包含例如生产者地址、生产时间、要发送的QueueId等。最终写入到Broker中消息单元中的数据都是来自于这些属性。</p>
<h3 id="2-批量消费消息"><a href="#2-批量消费消息" class="headerlink" title="2 批量消费消息"></a>2 批量消费消息</h3><h4 id="修改批量属性"><a href="#修改批量属性" class="headerlink" title="修改批量属性"></a>修改批量属性</h4><p>Consumer的MessageListenerConcurrently监听接口的consumeMessage()方法的第一个参数为消息列表，但默认情况下每次只能消费一条消息。若要使其一次可以消费多条消息，则可以通过修改Consumer的consumeMessageBatchMaxSize属性来指定。不过，该值不能超过 32 。因为默认情况下消费者每次可以拉取的消息最多是 32 条。若要修改一次拉取的最大值，则可通过修改Consumer的<br>pullBatchSize属性来指定。</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>Consumer的pullBatchSize属性与consumeMessageBatchMaxSize属性是否设置的越大越好？当然不是。</p>
<p>pullBatchSize值设置的越大，Consumer每拉取一次需要的时间就会越长，且在网络上传输出现问题的可能性就越高。若在拉取过程中若出现了问题，那么本批次所有消息都需要全部重新拉取。<br>consumeMessageBatchMaxSize值设置的越大，Consumer的消息并发消费能力越低，且这批被消费的消息具有相同的消费结果。因为consumeMessageBatchMaxSize指定的一批消息只会使用一个线程进行处理，且在处理过程中只要有一个消息处理异常，则这批消息需要全部重新再次消费处理。</p>
<h3 id="3-代码举例"><a href="#3-代码举例" class="headerlink" title="3 代码举例"></a>3 代码举例</h3><p>该批量发送的需求是，不修改最大发送4M的默认值，但要防止发送的批量消息超出4M的限制。定义消息列表分割器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 消息列表分割器：其只会处理每条消息的大小不超4M的情况。</span><br><span class="line">// 若存在某条消息，其本身大小大于4M，这个分割器无法处理，</span><br><span class="line">// 其直接将这条消息构成一个子列表返回。并没有再进行分割</span><br><span class="line">public class MessageListSplitter implements Iterator&lt;List&lt;Message&gt;&gt; &#123;</span><br><span class="line">// 指定极限值为4M</span><br><span class="line">private final int SIZE_LIMIT =  4 * 1024 * 1024 ;</span><br><span class="line">// 存放所有要发送的消息</span><br><span class="line">private final List&lt;Message&gt; messages;</span><br><span class="line">// 要进行批量发送消息的小集合起始索引</span><br><span class="line">private int currIndex;</span><br><span class="line">public MessageListSplitter(List&lt;Message&gt; messages) &#123;</span><br><span class="line">this.messages = messages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean hasNext() &#123;</span><br><span class="line">// 判断当前开始遍历的消息索引要小于消息总数</span><br><span class="line">return currIndex &lt; messages.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public List&lt;Message&gt; next() &#123;</span><br><span class="line">int nextIndex = currIndex;</span><br><span class="line">// 记录当前要发送的这一小批次消息列表的大小</span><br><span class="line">int totalSize = 0 ;</span><br><span class="line">for (; nextIndex &lt; messages.size(); nextIndex++) &#123;</span><br><span class="line">// 获取当前遍历的消息</span><br><span class="line">Message message = messages.get(nextIndex);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 统计当前遍历的message的大小</span><br><span class="line">int tmpSize = message.getTopic().length() +</span><br><span class="line">message.getBody().length;</span><br><span class="line">Map&lt;String, String&gt; properties = message.getProperties();</span><br><span class="line">for (Map.Entry&lt;String, String&gt; entry :</span><br><span class="line">properties.entrySet()) &#123;</span><br><span class="line">tmpSize += entry.getKey().length() +</span><br><span class="line">entry.getValue().length();</span><br><span class="line">&#125;</span><br><span class="line">tmpSize = tmpSize + 20 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断当前消息本身是否大于4M</span><br><span class="line">if (tmpSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">if (nextIndex - currIndex == 0 ) &#123;</span><br><span class="line">nextIndex++;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (tmpSize + totalSize &gt; SIZE_LIMIT) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">totalSize += tmpSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125; // end-for</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取当前messages列表的子集合[currIndex, nextIndex)</span><br><span class="line">List&lt;Message&gt; subList = messages.subList(currIndex, nextIndex);</span><br><span class="line">// 下次遍历的开始索引</span><br><span class="line">currIndex = nextIndex;</span><br><span class="line">return subList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="定义批量消息生产者"><a href="#定义批量消息生产者" class="headerlink" title="定义批量消息生产者"></a>定义批量消息生产者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BatchProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 指定要发送的消息的最大大小，默认是4M</span><br><span class="line">// 不过，仅修改该属性是不行的，还需要同时修改broker加载的配置文件中的</span><br><span class="line">// maxMessageSize属性</span><br><span class="line">// producer.setMaxMessageSize(8 * 1024 * 1024);</span><br><span class="line">producer.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义要发送的消息集合</span><br><span class="line">List&lt;Message&gt; messages = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0 ; i &lt; 100 ; i++) &#123;</span><br><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">Message msg = new Message(&quot;someTopic&quot;, &quot;someTag&quot;, body);</span><br><span class="line">messages.add(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义消息列表分割器，将消息列表分割为多个不超出4M大小的小列表</span><br><span class="line">MessageListSplitter splitter = new</span><br><span class="line">MessageListSplitter(messages);</span><br><span class="line">while (splitter.hasNext()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">List&lt;Message&gt; listItem = splitter.next();</span><br><span class="line">producer.send(listItem);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定义批量消息消费者"><a href="#定义批量消息消费者" class="headerlink" title="定义批量消息消费者"></a>定义批量消息消费者</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BatchConsumer &#123;</span><br><span class="line">public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="六、消息过滤"><a href="#六、消息过滤" class="headerlink" title="六、消息过滤"></a>六、消息过滤</h2><p>消息者在进行消息订阅时，除了可以指定要订阅消息的Topic外，还可以对指定Topic中的消息根据指定条件进行过滤，即可以订阅比Topic更加细粒度的消息类型。对于指定Topic消息的过滤有两种过滤方式：Tag过滤与SQL过滤。</p>
<h3 id="1-Tag过滤"><a href="#1-Tag过滤" class="headerlink" title="1 Tag过滤"></a>1 Tag过滤</h3><p>通过consumer的subscribe()方法指定要订阅消息的Tag。如果订阅多个Tag的消息，Tag间使用或运算符(双竖线||)连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br><span class="line">consumer.subscribe(&quot;someTopicA&quot;, &quot;*&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 指定每次可以消费 10 条消息，默认为 1</span><br><span class="line">consumer.setConsumeMessageBatchMaxSize( 10 );</span><br><span class="line">// 指定每次可以从Broker拉取 40 条消息，默认为 32</span><br><span class="line">consumer.setPullBatchSize( 40 );</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs,</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">for (MessageExt msg : msgs) &#123;</span><br><span class="line">System.out.println(msg);</span><br><span class="line">&#125;</span><br><span class="line">// 消费成功的返回结果</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">// 消费异常时的返回结果</span><br><span class="line">// return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-SQL过滤"><a href="#2-SQL过滤" class="headerlink" title="2 SQL过滤"></a>2 SQL过滤</h3><p>SQL过滤是一种通过特定表达式对事先埋入到消息中的用户属性进行筛选过滤的方式。通过SQL过滤，可以实现对消息的复杂过滤。不过，只有使用PUSH模式的消费者才能使用SQL过滤。SQL过滤表达式中支持多种常量类型与运算符。</p>
<p>支持的常量类型：数值：比如： 123 ，3.1415</p>
<p>字符：必须用单引号包裹起来，比如：’abc’<br>布尔：TRUE 或 FALSE<br>NULL：特殊的常量，表示空</p>
<h4 id="支持的运算符有："><a href="#支持的运算符有：" class="headerlink" title="支持的运算符有："></a>支持的运算符有：</h4><h4 id="数值比较：-，-，"><a href="#数值比较：-，-，" class="headerlink" title="数值比较：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;"></a>数值比较：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;</h4><h4 id="字符比较：-，，IN"><a href="#字符比较：-，，IN" class="headerlink" title="字符比较：&#x3D;，&lt;&gt;，IN"></a>字符比较：&#x3D;，&lt;&gt;，IN</h4><h4 id="逻辑运算-：AND，OR，NOT"><a href="#逻辑运算-：AND，OR，NOT" class="headerlink" title="逻辑运算 ：AND，OR，NOT"></a>逻辑运算 ：AND，OR，NOT</h4><h4 id="NULL判断：IS-NULL-或者-IS-NOT-NULL"><a href="#NULL判断：IS-NULL-或者-IS-NOT-NULL" class="headerlink" title="NULL判断：IS NULL 或者 IS NOT NULL"></a>NULL判断：IS NULL 或者 IS NOT NULL</h4><p>默认情况下Broker没有开启消息的SQL过滤功能，需要在Broker加载的配置文件中添加如下属性，以开<br>启该功能：</p>
<p>在启动Broker时需要指定这个修改过的配置文件。例如对于单机Broker的启动，其修改的配置文件是<br>conf&#x2F;broker.conf，启动时使用如下命令：</p>
<h3 id="3-代码举例-1"><a href="#3-代码举例-1" class="headerlink" title="3 代码举例"></a>3 代码举例</h3><p>定义Tag过滤Producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;CID_EXAMPLE&quot;);</span><br><span class="line">consumer.subscribe(&quot;TOPIC&quot;, &quot;TAGA || TAGB || TAGC&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 enablePropertyFilter = true</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterByTagProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">producer.start();</span><br><span class="line">String[] tags = &#123;&quot;myTagA&quot;,&quot;myTagB&quot;,&quot;myTagC&quot;&#125;;</span><br><span class="line">for (int i = 0 ; i &lt; 10 ; i++) &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>

<p>定义Tag过滤Consumer</p>
<p>定义SQL过滤Producer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">String tag = tags[i%tags.length];</span><br><span class="line">Message msg = new Message(&quot;myTopic&quot;,tag,body);</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterByTagConsumer &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;pg&quot;);</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(&quot;myTopic&quot;, &quot;myTagA || myTagB&quot;);</span><br><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs,</span><br><span class="line">ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">for (MessageExt me:msgs)&#123;</span><br><span class="line">System.out.println(me);</span><br><span class="line">&#125;</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterBySQLProducer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>定义SQL过滤Consumer</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">producer.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0 ; i &lt; 10 ; i++) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">byte[] body = (&quot;Hi,&quot; + i).getBytes();</span><br><span class="line">Message msg = new Message(&quot;myTopic&quot;, &quot;myTag&quot;, body);</span><br><span class="line">msg.putUserProperty(&quot;age&quot;, i + &quot;&quot;);</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">System.out.println(sendResult);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">producer.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class FilterBySQLConsumer &#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">DefaultMQPushConsumer consumer = new</span><br><span class="line">DefaultMQPushConsumer(&quot;pg&quot;);</span><br><span class="line">consumer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(&quot;myTopic&quot;, MessageSelector.bySql(&quot;age between</span><br><span class="line">0 and 6&quot;));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">consumer.registerMessageListener(new</span><br><span class="line">MessageListenerConcurrently() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus</span><br><span class="line">consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext</span><br><span class="line">context) &#123;</span><br><span class="line">for (MessageExt me:msgs)&#123;</span><br><span class="line">System.out.println(me);</span><br><span class="line">&#125;</span><br><span class="line">return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">consumer.start();</span><br><span class="line">System.out.println(&quot;Consumer Started&quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure>

<h2 id="七、消息发送重试机制"><a href="#七、消息发送重试机制" class="headerlink" title="七、消息发送重试机制"></a>七、消息发送重试机制</h2><h3 id="1-说明"><a href="#1-说明" class="headerlink" title="1 说明"></a>1 说明</h3><p>Producer对发送失败的消息进行重新发送的机制，称为消息发送重试机制，也称为消息重投机制。</p>
<h4 id="对于消息重投，需要注意以下几点："><a href="#对于消息重投，需要注意以下几点：" class="headerlink" title="对于消息重投，需要注意以下几点："></a>对于消息重投，需要注意以下几点：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产者在发送消息时，若采用同步或异步发送方式，发送失败会重试，但oneway消息发送方式</span><br><span class="line">发送失败是没有重试机制的</span><br><span class="line">只有普通消息具有发送重试机制，顺序消息是没有的</span><br><span class="line">消息重投机制可以保证消息尽可能发送成功、不丢失，但可能会造成消息重复。消息重复在</span><br><span class="line">RocketMQ中是无法避免的问题</span><br><span class="line">消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会成为大概率事件</span><br><span class="line">producer主动重发、consumer负载变化（发生Rebalance，不会导致消息重复，但可能出现重复</span><br><span class="line">消费）也会导致重复消息</span><br><span class="line">消息重复无法避免，但要避免消息的重复消费。</span><br><span class="line">避免消息重复消费的解决方案是，为消息添加唯一标识（例如消息key），使消费者对消息进行消</span><br><span class="line">费判断来避免重复消费</span><br><span class="line">消息发送重试有三种策略可以选择：同步发送失败策略、异步发送失败策略、消息刷盘失败策略</span><br></pre></td></tr></table></figure>

<h3 id="2-同步发送失败策略"><a href="#2-同步发送失败策略" class="headerlink" title="2 同步发送失败策略"></a>2 同步发送失败策略</h3><p>对于普通消息，消息发送默认采用round-robin策略来选择所发送到的队列。如果发送失败，默认重试 2<br>次。但在重试时是不会选择上次发送失败的Broker，而是选择其它Broker。当然，若只有一个Broker其<br>也只能发送到该Broker，但其会尽量发送到该Broker上的其它Queue。</p>
<p>同时，Broker还具有失败隔离功能，使Producer尽量选择未发生过发送失败的Broker作为目标</p>
<p>Broker。其可以保证其它消息尽量不发送到问题Broker，为了提升消息发送效率，降低消息发送耗时。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思考：让我们自己实现失败隔离功能，如何来做？</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个producer，参数为Producer Group名称</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">// 指定nameServer地址</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 设置同步发送失败时重试发送的次数，默认为 2 次</span><br><span class="line">producer.setRetryTimesWhenSendFailed( 3 );</span><br><span class="line">// 设置发送超时时限为5s，默认3s</span><br><span class="line">producer.setSendMsgTimeout( 5000 );</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ）方案一：Producer中维护某JUC的Map集合，其key是发生失败的时间戳，value为Broker实</span><br><span class="line">例。Producer中还维护着一个Set集合，其中存放着所有未发生发送异常的Broker实例。选择目</span><br><span class="line">标Broker是从该Set集合中选择的。再定义一个定时任务，定期从Map集合中将长期未发生发送</span><br><span class="line">异常的Broker清理出去，并添加到Set集合。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 ）方案二：为Producer中的Broker实例添加一个标识，例如是一个AtomicBoolean属性。只要该</span><br><span class="line">Broker上发生过发送异常，就将其置为true。选择目标Broker就是选择该属性值为false的</span><br><span class="line">Broker。再定义一个定时任务，定期将Broker的该属性置为false。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 ）方案三：为Producer中的Broker实例添加一个标识，例如是一个AtomicLong属性。只要该</span><br><span class="line">Broker上发生过发送异常，就使其值增一。选择目标Broker就是选择该属性值最小的Broker。若</span><br><span class="line">该值相同，采用轮询方式选择。</span><br></pre></td></tr></table></figure>

<p>如果超过重试次数，则抛出异常，由Producer去保证消息不丢。当然当生产者出现<br>RemotingException、MQClientException和MQBrokerException时，Producer会自动重投消息。</p>
<h3 id="3-异步发送失败策略"><a href="#3-异步发送失败策略" class="headerlink" title="3 异步发送失败策略"></a>3 异步发送失败策略</h3><p>异步发送失败重试时，异步重试不会选择其他broker，仅在同一个broker上做重试，所以该策略无法保<br>证消息不丢。</p>
<h3 id="4-消息刷盘失败策略"><a href="#4-消息刷盘失败策略" class="headerlink" title="4 消息刷盘失败策略"></a>4 消息刷盘失败策略</h3><p>消息刷盘超时（Master或Slave）或slave不可用（slave在做数据同步时向master返回状态不是<br>SEND_OK）时，默认是不会将消息尝试发送到其他Broker的。不过，对于重要消息可以通过在Broker<br>的配置文件设置retryAnotherBrokerWhenNotStoreOK属性为true来开启。</p>
<h2 id="八、消息消费重试机制"><a href="#八、消息消费重试机制" class="headerlink" title="八、消息消费重试机制"></a>八、消息消费重试机制</h2><h3 id="1-顺序消息的消费重试"><a href="#1-顺序消息的消费重试" class="headerlink" title="1 顺序消息的消费重试"></a>1 顺序消息的消费重试</h3><p>对于顺序消息，当Consumer消费消息失败后，为了保证消息的顺序性，其会自动不断地进行消息重<br>试，直到消费成功。消费重试默认间隔时间为 1000 毫秒。重试期间应用会出现消息消费被阻塞的情<br>况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;pg&quot;);</span><br><span class="line">producer.setNamesrvAddr(&quot;rocketmqOS:9876&quot;);</span><br><span class="line">// 指定异步发送失败后不进行重试发送</span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed( 0 );</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">// 顺序消息消费失败的消费重试时间间隔，单位毫秒，默认为 1000 ，其取值范围为[10,</span><br><span class="line">30000]</span><br><span class="line">consumer.setSuspendCurrentQueueTimeMillis( 100 );</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<h4 id="重试次数-与上次重试的间隔时间-重试次数-与上次重试的间隔时间"><a href="#重试次数-与上次重试的间隔时间-重试次数-与上次重试的间隔时间" class="headerlink" title="重试次数 与上次重试的间隔时间 重试次数 与上次重试的间隔时间"></a>重试次数 与上次重试的间隔时间 重试次数 与上次重试的间隔时间</h4><h4 id="1-10-秒-9-7-分钟"><a href="#1-10-秒-9-7-分钟" class="headerlink" title="1 10 秒 9 7 分钟"></a>1 10 秒 9 7 分钟</h4><h4 id="2-30-秒-10-8-分钟"><a href="#2-30-秒-10-8-分钟" class="headerlink" title="2 30 秒 10 8 分钟"></a>2 30 秒 10 8 分钟</h4><h4 id="3-1-分钟-11-9-分钟"><a href="#3-1-分钟-11-9-分钟" class="headerlink" title="3 1 分钟 11 9 分钟"></a>3 1 分钟 11 9 分钟</h4><h4 id="4-2-分钟-12-10-分钟"><a href="#4-2-分钟-12-10-分钟" class="headerlink" title="4 2 分钟 12 10 分钟"></a>4 2 分钟 12 10 分钟</h4><h4 id="5-3-分钟-13-20-分钟"><a href="#5-3-分钟-13-20-分钟" class="headerlink" title="5 3 分钟 13 20 分钟"></a>5 3 分钟 13 20 分钟</h4><h4 id="6-4-分钟-14-30-分钟"><a href="#6-4-分钟-14-30-分钟" class="headerlink" title="6 4 分钟 14 30 分钟"></a>6 4 分钟 14 30 分钟</h4><h4 id="7-5-分钟-15-1-小时"><a href="#7-5-分钟-15-1-小时" class="headerlink" title="7 5 分钟 15 1 小时"></a>7 5 分钟 15 1 小时</h4><h4 id="8-6-分钟-16-2-小时"><a href="#8-6-分钟-16-2-小时" class="headerlink" title="8 6 分钟 16 2 小时"></a>8 6 分钟 16 2 小时</h4><h4 id="由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，"><a href="#由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，" class="headerlink" title="由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，"></a>由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，</h4><h4 id="务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。"><a href="#务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。" class="headerlink" title="务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。"></a>务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。</h4><h4 id="注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制"><a href="#注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制" class="headerlink" title="注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制"></a>注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制</h4><h3 id="2-无序消息的消费重试"><a href="#2-无序消息的消费重试" class="headerlink" title="2 无序消息的消费重试"></a>2 无序消息的消费重试</h3><p>对于无序消息（普通消息、延时消息、事务消息），当Consumer消费消息失败时，可以通过设置返回<br>状态达到消息重试的效果。不过需要注意，无序消息的重试只对集群消费方式生效，广播消费方式不</p>
<p>提供失败重试特性。即对于广播消费，消费失败后，失败消息不再重试，继续消费后续消息。</p>
<h3 id="3-消费重试次数与间隔"><a href="#3-消费重试次数与间隔" class="headerlink" title="3 消费重试次数与间隔"></a>3 消费重试次数与间隔</h3><h4 id="对于无序消息集群消费下的重试消费，每条消息默认最多重试-16-次，但每次重试的间隔时间是不同"><a href="#对于无序消息集群消费下的重试消费，每条消息默认最多重试-16-次，但每次重试的间隔时间是不同" class="headerlink" title="对于无序消息集群消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同"></a>对于无序消息集群消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同</h4><h4 id="的，会逐渐变长。每次重试的间隔时间如下表。"><a href="#的，会逐渐变长。每次重试的间隔时间如下表。" class="headerlink" title="的，会逐渐变长。每次重试的间隔时间如下表。"></a>的，会逐渐变长。每次重试的间隔时间如下表。</h4><h4 id="若一条消息在一直消费失败的前提下，将会在正常消费后的第-4-小时-46-分后进行第-16-次重试。"><a href="#若一条消息在一直消费失败的前提下，将会在正常消费后的第-4-小时-46-分后进行第-16-次重试。" class="headerlink" title="若一条消息在一直消费失败的前提下，将会在正常消费后的第 4 小时 46 分后进行第 16 次重试。"></a>若一条消息在一直消费失败的前提下，将会在正常消费后的第 4 小时 46 分后进行第 16 次重试。</h4><h4 id="若仍然失败，则将消息投递到死信队列"><a href="#若仍然失败，则将消息投递到死信队列" class="headerlink" title="若仍然失败，则将消息投递到死信队列"></a>若仍然失败，则将消息投递到死信队列</h4><h4 id="修改消费重试次数"><a href="#修改消费重试次数" class="headerlink" title="修改消费重试次数"></a>修改消费重试次数</h4><h4 id="对于修改过的重试次数，将按照以下策略执行："><a href="#对于修改过的重试次数，将按照以下策略执行：" class="headerlink" title="对于修改过的重试次数，将按照以下策略执行："></a>对于修改过的重试次数，将按照以下策略执行：</h4><h4 id="若修改值小于-16-，则按照指定间隔进行重试"><a href="#若修改值小于-16-，则按照指定间隔进行重试" class="headerlink" title="若修改值小于 16 ，则按照指定间隔进行重试"></a>若修改值小于 16 ，则按照指定间隔进行重试</h4><h4 id="若修改值大于-16-，则超过-16-次的重试时间间隔均为-2-小时"><a href="#若修改值大于-16-，则超过-16-次的重试时间间隔均为-2-小时" class="headerlink" title="若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时"></a>若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于Consumer Group，若仅修改了一个Consumer的消费重试次数，则会应用到该Group中所有</span><br><span class="line">其它Consumer实例。若出现多个Consumer均做了修改的情况，则采用覆盖方式生效。即最后被</span><br><span class="line">修改的值会覆盖前面设置的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;cg&quot;);</span><br><span class="line">// 修改消费重试次数</span><br><span class="line">consumer.setMaxReconsumeTimes( 10 );</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="4-重试队列-1"><a href="#4-重试队列-1" class="headerlink" title="4 重试队列"></a>4 重试队列</h3><p>对于需要重试消费的消息，并不是Consumer在等待了指定时长后再次去拉取原来的消息进行消费，而<br>是将这些需要重试消费的消息放入到了一个特殊Topic的队列中，而后进行再次消费的。这个特殊的队<br>列就是重试队列。</p>
<p>当出现需要进行重试消费的消息时，Broker会为每个消费组都设置一个Topic名称<br>为%RETRY%consumerGroup@consumerGroup的重试队列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ）这个重试队列是针对消息才组的，而不是针对每个Topic设置的（一个Topic的消息可以让多</span><br><span class="line">个消费者组进行消费，所以会为这些消费者组各创建一个重试队列）</span><br></pre></td></tr></table></figure>

<h4 id="2-）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列"><a href="#2-）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列" class="headerlink" title="2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列"></a>2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</h4><h4 id="注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间"><a href="#注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间" class="headerlink" title="注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间"></a>注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间</h4><h4 id="外，其它的时间都是相同的"><a href="#外，其它的时间都是相同的" class="headerlink" title="外，其它的时间都是相同的"></a>外，其它的时间都是相同的</h4><p>Broker对于重试消息的处理是通过延时消息实现的。先将消息保存到SCHEDULE_TOPIC_XXXX延迟队</p>
<p>列中，延迟时间到后，会将消息投递到%RETRY%consumerGroup@consumerGroup重试队列中。</p>
<h3 id="5-消费重试配置方式"><a href="#5-消费重试配置方式" class="headerlink" title="5 消费重试配置方式"></a>5 消费重试配置方式</h3><h4 id="集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三"><a href="#集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三" class="headerlink" title="集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三"></a>集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三</h4><h4 id="种方式之一的配置："><a href="#种方式之一的配置：" class="headerlink" title="种方式之一的配置："></a>种方式之一的配置：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式 1 ：返回ConsumeConcurrentlyStatus.RECONSUME_LATER（推荐）</span><br><span class="line">方式 2 ：返回Null</span><br><span class="line">方式 3 ：抛出异常</span><br></pre></td></tr></table></figure>

<h3 id="6-消费不重试配置方式"><a href="#6-消费不重试配置方式" class="headerlink" title="6 消费不重试配置方式"></a>6 消费不重试配置方式</h3><h4 id="集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相"><a href="#集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相" class="headerlink" title="集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相"></a>集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相</h4><p>同的结果，即ConsumeConcurrentlyStatus.CONSUME_SUCCESS，则不进行消费重试。</p>
<h2 id="九、死信队列"><a href="#九、死信队列" class="headerlink" title="九、死信队列"></a>九、死信队列</h2><h3 id="1-什么是死信队列"><a href="#1-什么是死信队列" class="headerlink" title="1 什么是死信队列"></a>1 什么是死信队列</h3><p>当一条消息初次消费失败，消息队列会自动进行消费重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。这个队列就是死信队列（Dead-Letter Queue，DLQ），而其中的消息则称为死信消息（Dead-Letter Message，DLM）。</p>
<h4 id="死信队列是用于处理无法被正常消费的消息的。"><a href="#死信队列是用于处理无法被正常消费的消息的。" class="headerlink" title="死信队列是用于处理无法被正常消费的消息的。"></a>死信队列是用于处理无法被正常消费的消息的。</h4><h3 id="2-死信队列的特征"><a href="#2-死信队列的特征" class="headerlink" title="2 死信队列的特征"></a>2 死信队列的特征</h3><h4 id="死信队列具有如下特征："><a href="#死信队列具有如下特征：" class="headerlink" title="死信队列具有如下特征："></a>死信队列具有如下特征：</h4><p>死信队列中的消息不会再被消费者正常消费，即DLQ对于消费者是不可见的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">死信存储有效期与正常消息相同，均为 3 天（commitlog文件的过期时间）， 3 天后会被自动删除</span><br><span class="line">死信队列就是一个特殊的Topic，名称为%DLQ%consumerGroup@consumerGroup，即每个消</span><br><span class="line">费者组都有一个死信队列</span><br><span class="line">如果一个消费者组未产生死信消息，则不会为其创建相应的死信队列</span><br></pre></td></tr></table></figure>

<h3 id="3-死信消息的处理"><a href="#3-死信消息的处理" class="headerlink" title="3 死信消息的处理"></a>3 死信消息的处理</h3><p>实际上，当一条消息进入死信队列，就意味着系统中某些地方出现了问题，从而导致消费者无法正常消费该消息，比如代码中原本就存在Bug。因此，对于死信消息，通常需要开发人员进行特殊处理。最关键的步骤是要排查可疑因素，解决代码中可能存在的Bug，然后再将原来的死信消息再次进行投递消费。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Miller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/27/RocketMQ/RocketMQ/">http://example.com/2023/11/27/RocketMQ/RocketMQ/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">但行前路，不负韶华！</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/27/Spring%20Security/OAuth2.0/" title="OAuth2.0"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OAuth2.0</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97/" title="队列"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">队列</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Miller</div><div class="author-info__description">但行前路，不负韶华！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dongxiaopipi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dongxiaopipi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一、基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">二、系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Producer"><span class="toc-number">2.1.</span> <span class="toc-text">1 Producer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Consumer"><span class="toc-number">2.2.</span> <span class="toc-text">2 Consumer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Name-Server"><span class="toc-number">2.3.</span> <span class="toc-text">3 Name Server</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Broker"><span class="toc-number">2.4.</span> <span class="toc-text">4 Broker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Linux%E5%90%AF%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">三、Linux启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%90%AF%E5%8A%A8nameServer%E5%92%8Cbroker"><span class="toc-number">3.1.</span> <span class="toc-text">1.启动nameServer和broker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E6%94%B6%E5%8F%91"><span class="toc-number">3.2.</span> <span class="toc-text">2.消息收发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker%E5%90%AF%E5%8A%A8"><span class="toc-number">3.3.</span> <span class="toc-text">docker启动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-number">4.</span> <span class="toc-text">四、集群搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%B7%E7%9B%98%E7%AD%96%E7%95%A5"><span class="toc-number">4.1.</span> <span class="toc-text">1.数据复制和刷盘策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">五、工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7"><span class="toc-number">5.1.</span> <span class="toc-text">1.消息的生产</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">消息的生产过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Queue%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text">Queue选择算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">5.2.</span> <span class="toc-text">2.消息的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Rebalance%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">3.Rebalance机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Queue%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">4.Queue分配算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81offset%E7%AE%A1%E7%90%86"><span class="toc-number"></span> <span class="toc-text">六、offset管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-offset%E6%9C%AC%E5%9C%B0%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">1 offset本地管理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-offset%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">2 offset远程管理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-offset%E7%94%A8%E9%80%94"><span class="toc-number">3.</span> <span class="toc-text">3 offset用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">4 重试队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-offset%E7%9A%84%E5%90%8C%E6%AD%A5%E6%8F%90%E4%BA%A4%E4%B8%8E%E5%BC%82%E6%AD%A5%E6%8F%90%E4%BA%A4"><span class="toc-number">5.</span> <span class="toc-text">5 offset的同步提交与异步提交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89"><span class="toc-number"></span> <span class="toc-text">七、消费幂等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89"><span class="toc-number">1.</span> <span class="toc-text">1 什么是消费幂等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">2 消息重复的场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%97%B6%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">2.1.</span> <span class="toc-text">发送时消息重复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%97%B6%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D"><span class="toc-number">2.2.</span> <span class="toc-text">消费时消息重复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E7%94%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">3 通用解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.1.</span> <span class="toc-text">解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.2.</span> <span class="toc-text">解决方案举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E6%94%AF%E4%BB%98%E5%9C%BA%E6%99%AF%E4%B8%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">3.3.</span> <span class="toc-text">以支付场景为例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B6%88%E8%B4%B9%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">4 消费幂等的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E4%B8%8E%E6%B6%88%E8%B4%B9%E5%BB%B6%E8%BF%9F"><span class="toc-number"></span> <span class="toc-text">八、消息堆积与消费延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">2 产生原因分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8B%89%E5%8F%96"><span class="toc-number">2.1.</span> <span class="toc-text">消息拉取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9"><span class="toc-number">2.2.</span> <span class="toc-text">消息消费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">2.3.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E8%80%97%E6%97%B6"><span class="toc-number">3.</span> <span class="toc-text">3 消费耗时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B6%88%E8%B4%B9%E5%B9%B6%E5%8F%91%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">4 消费并发度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-number"></span> <span class="toc-text">九、消息的清理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%A2%AB%E6%B6%88%E8%B4%B9%E8%BF%87%E5%90%8E%E4%BC%9A%E8%A2%AB%E6%B8%85%E7%90%86%E6%8E%89%E5%90%97%EF%BC%9F%E4%B8%8D%E4%BC%9A%E7%9A%84%E3%80%82"><span class="toc-number">0.1.</span> <span class="toc-text">消息被消费过后会被清理掉吗？不会的。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A"><span class="toc-number">0.2.</span> <span class="toc-text">需要注意以下几点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-RocketMQ%E5%BA%94%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">第 4 章 RocketMQ应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number"></span> <span class="toc-text">一、普通消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">1 消息发送分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.</span> <span class="toc-text">同步发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.2.</span> <span class="toc-text">异步发送消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">单向发送消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number"></span> <span class="toc-text">二、顺序消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">1 什么是顺序消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">2 有序性分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%9C%89%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">全局有序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E6%9C%89%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">分区有序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number"></span> <span class="toc-text">三、延时消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">1 什么是延时消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BB%B6%E6%97%B6%E7%AD%89%E7%BA%A7"><span class="toc-number">2.</span> <span class="toc-text">2 延时等级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3 延时消息实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%E6%98%AF%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">具体实现方案是：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%B6%88%E6%81%AF"><span class="toc-number">3.2.</span> <span class="toc-text">修改消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number"></span> <span class="toc-text">四、事务消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">1.</span> <span class="toc-text">1 问题引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">2 解决思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E6%89%A3%E6%AC%BE%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E5%9C%A8%E4%B8%89%E7%A7%8D%E5%8F%AF%E8%83%BD%E6%80%A7%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">预扣款执行结果存在三种可能性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-TM%E4%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%8A%E6%8A%A5%E7%BB%93%E6%9E%9C%E5%90%91TC%E5%8F%91%E5%87%BA%E4%B8%8D%E5%90%8C%E7%9A%84%E7%A1%AE%E8%AE%A4%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text">8. TM会根据上报结果向TC发出不同的确认指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">3 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">3.1.</span> <span class="toc-text">事务消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">3.2.</span> <span class="toc-text">半事务消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81"><span class="toc-number">3.3.</span> <span class="toc-text">本地事务状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%9B%9E%E6%9F%A5"><span class="toc-number">3.4.</span> <span class="toc-text">消息回查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-XA%E6%A8%A1%E5%BC%8F%E4%B8%89%E5%89%91%E5%AE%A2"><span class="toc-number">4.</span> <span class="toc-text">4 XA模式三剑客</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XA%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.1.</span> <span class="toc-text">XA协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TM"><span class="toc-number">4.2.</span> <span class="toc-text">TM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RM"><span class="toc-number">4.3.</span> <span class="toc-text">RM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-XA%E6%A8%A1%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">5 XA模式架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B3%A8%E6%84%8F"><span class="toc-number">6.</span> <span class="toc-text">6 注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">7 代码举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">7.1.</span> <span class="toc-text">定义消费者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">8.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF"><span class="toc-number"></span> <span class="toc-text">五、批量消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">1 批量发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%99%90%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">发送限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.2.</span> <span class="toc-text">批量发送大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.3.</span> <span class="toc-text">生产者发送的消息大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%B9%E9%87%8F%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF"><span class="toc-number">2.</span> <span class="toc-text">2 批量消费消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%89%B9%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">修改批量属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.</span> <span class="toc-text">3 代码举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">3.1.</span> <span class="toc-text">定义批量消息生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%89%B9%E9%87%8F%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.2.</span> <span class="toc-text">定义批量消息消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number"></span> <span class="toc-text">六、消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Tag%E8%BF%87%E6%BB%A4"><span class="toc-number">1.</span> <span class="toc-text">1 Tag过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL%E8%BF%87%E6%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">2 SQL过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9C%89%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">支持的运算符有：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83%EF%BC%9A-%EF%BC%8C-%EF%BC%8C"><span class="toc-number">2.2.</span> <span class="toc-text">数值比较：&gt;，&gt;&#x3D;，&lt;，&lt;&#x3D;，BETWEEN，&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%AF%94%E8%BE%83%EF%BC%9A-%EF%BC%8C%EF%BC%8CIN"><span class="toc-number">2.3.</span> <span class="toc-text">字符比较：&#x3D;，&lt;&gt;，IN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97-%EF%BC%9AAND%EF%BC%8COR%EF%BC%8CNOT"><span class="toc-number">2.4.</span> <span class="toc-text">逻辑运算 ：AND，OR，NOT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NULL%E5%88%A4%E6%96%AD%EF%BC%9AIS-NULL-%E6%88%96%E8%80%85-IS-NOT-NULL"><span class="toc-number">2.5.</span> <span class="toc-text">NULL判断：IS NULL 或者 IS NOT NULL</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B-1"><span class="toc-number">3.</span> <span class="toc-text">3 代码举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">七、消息发送重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">1 说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%B6%88%E6%81%AF%E9%87%8D%E6%8A%95%EF%BC%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">对于消息重投，需要注意以下几点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">2.</span> <span class="toc-text">2 同步发送失败策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">3.</span> <span class="toc-text">3 异步发送失败策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5"><span class="toc-number">4.</span> <span class="toc-text">4 消息刷盘失败策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">八、消息消费重试机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">1 顺序消息的消费重试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0-%E4%B8%8E%E4%B8%8A%E6%AC%A1%E9%87%8D%E8%AF%95%E7%9A%84%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4-%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0-%E4%B8%8E%E4%B8%8A%E6%AC%A1%E9%87%8D%E8%AF%95%E7%9A%84%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4"><span class="toc-number">1.1.</span> <span class="toc-text">重试次数 与上次重试的间隔时间 重试次数 与上次重试的间隔时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-%E7%A7%92-9-7-%E5%88%86%E9%92%9F"><span class="toc-number">1.2.</span> <span class="toc-text">1 10 秒 9 7 分钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-30-%E7%A7%92-10-8-%E5%88%86%E9%92%9F"><span class="toc-number">1.3.</span> <span class="toc-text">2 30 秒 10 8 分钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%88%86%E9%92%9F-11-9-%E5%88%86%E9%92%9F"><span class="toc-number">1.4.</span> <span class="toc-text">3 1 分钟 11 9 分钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%88%86%E9%92%9F-12-10-%E5%88%86%E9%92%9F"><span class="toc-number">1.5.</span> <span class="toc-text">4 2 分钟 12 10 分钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%88%86%E9%92%9F-13-20-%E5%88%86%E9%92%9F"><span class="toc-number">1.6.</span> <span class="toc-text">5 3 分钟 13 20 分钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E5%88%86%E9%92%9F-14-30-%E5%88%86%E9%92%9F"><span class="toc-number">1.7.</span> <span class="toc-text">6 4 分钟 14 30 分钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E5%88%86%E9%92%9F-15-1-%E5%B0%8F%E6%97%B6"><span class="toc-number">1.8.</span> <span class="toc-text">7 5 分钟 15 1 小时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E5%88%86%E9%92%9F-16-2-%E5%B0%8F%E6%97%B6"><span class="toc-number">1.9.</span> <span class="toc-text">8 6 分钟 16 2 小时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E4%BA%8E%E5%AF%B9%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E8%AF%95%E6%98%AF%E6%97%A0%E4%BC%91%E6%AD%A2%E7%9A%84%EF%BC%8C%E4%B8%8D%E9%97%B4%E6%96%AD%E7%9A%84%EF%BC%8C%E7%9B%B4%E8%87%B3%E6%B6%88%E8%B4%B9%E6%88%90%E5%8A%9F%EF%BC%8C%E6%89%80%E4%BB%A5%EF%BC%8C%E5%AF%B9%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%EF%BC%8C"><span class="toc-number">1.10.</span> <span class="toc-text">由于对顺序消息的重试是无休止的，不间断的，直至消费成功，所以，对于顺序消息的消费，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A1%E5%BF%85%E8%A6%81%E4%BF%9D%E8%AF%81%E5%BA%94%E7%94%A8%E8%83%BD%E5%A4%9F%E5%8F%8A%E6%97%B6%E7%9B%91%E6%8E%A7%E5%B9%B6%E5%A4%84%E7%90%86%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E9%81%BF%E5%85%8D%E6%B6%88%E8%B4%B9%E8%A2%AB%E6%B0%B8%E4%B9%85%E6%80%A7%E9%98%BB%E5%A1%9E%E3%80%82"><span class="toc-number">1.11.</span> <span class="toc-text">务必要保证应用能够及时监控并处理消费失败的情况，避免消费被永久性阻塞。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%8C%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%B2%A1%E6%9C%89%E5%8F%91%E9%80%81%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BD%86%E5%85%B7%E6%9C%89%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.12.</span> <span class="toc-text">注意，顺序消息没有发送失败重试机制，但具有消费失败重试机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">2 无序消息的消费重试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%E4%B8%8E%E9%97%B4%E9%9A%94"><span class="toc-number">3.</span> <span class="toc-text">3 消费重试次数与间隔</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%97%A0%E5%BA%8F%E6%B6%88%E6%81%AF%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%E4%B8%8B%E7%9A%84%E9%87%8D%E8%AF%95%E6%B6%88%E8%B4%B9%EF%BC%8C%E6%AF%8F%E6%9D%A1%E6%B6%88%E6%81%AF%E9%BB%98%E8%AE%A4%E6%9C%80%E5%A4%9A%E9%87%8D%E8%AF%95-16-%E6%AC%A1%EF%BC%8C%E4%BD%86%E6%AF%8F%E6%AC%A1%E9%87%8D%E8%AF%95%E7%9A%84%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4%E6%98%AF%E4%B8%8D%E5%90%8C"><span class="toc-number">3.1.</span> <span class="toc-text">对于无序消息集群消费下的重试消费，每条消息默认最多重试 16 次，但每次重试的间隔时间是不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%EF%BC%8C%E4%BC%9A%E9%80%90%E6%B8%90%E5%8F%98%E9%95%BF%E3%80%82%E6%AF%8F%E6%AC%A1%E9%87%8D%E8%AF%95%E7%9A%84%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4%E5%A6%82%E4%B8%8B%E8%A1%A8%E3%80%82"><span class="toc-number">3.2.</span> <span class="toc-text">的，会逐渐变长。每次重试的间隔时间如下表。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5%E4%B8%80%E6%9D%A1%E6%B6%88%E6%81%AF%E5%9C%A8%E4%B8%80%E7%9B%B4%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%9C%A8%E6%AD%A3%E5%B8%B8%E6%B6%88%E8%B4%B9%E5%90%8E%E7%9A%84%E7%AC%AC-4-%E5%B0%8F%E6%97%B6-46-%E5%88%86%E5%90%8E%E8%BF%9B%E8%A1%8C%E7%AC%AC-16-%E6%AC%A1%E9%87%8D%E8%AF%95%E3%80%82"><span class="toc-number">3.3.</span> <span class="toc-text">若一条消息在一直消费失败的前提下，将会在正常消费后的第 4 小时 46 分后进行第 16 次重试。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5%E4%BB%8D%E7%84%B6%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%88%99%E5%B0%86%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E5%88%B0%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">3.4.</span> <span class="toc-text">若仍然失败，则将消息投递到死信队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">修改消费重试次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84%E9%87%8D%E8%AF%95%E6%AC%A1%E6%95%B0%EF%BC%8C%E5%B0%86%E6%8C%89%E7%85%A7%E4%BB%A5%E4%B8%8B%E7%AD%96%E7%95%A5%E6%89%A7%E8%A1%8C%EF%BC%9A"><span class="toc-number">3.6.</span> <span class="toc-text">对于修改过的重试次数，将按照以下策略执行：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5%E4%BF%AE%E6%94%B9%E5%80%BC%E5%B0%8F%E4%BA%8E-16-%EF%BC%8C%E5%88%99%E6%8C%89%E7%85%A7%E6%8C%87%E5%AE%9A%E9%97%B4%E9%9A%94%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%AF%95"><span class="toc-number">3.7.</span> <span class="toc-text">若修改值小于 16 ，则按照指定间隔进行重试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5%E4%BF%AE%E6%94%B9%E5%80%BC%E5%A4%A7%E4%BA%8E-16-%EF%BC%8C%E5%88%99%E8%B6%85%E8%BF%87-16-%E6%AC%A1%E7%9A%84%E9%87%8D%E8%AF%95%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E5%9D%87%E4%B8%BA-2-%E5%B0%8F%E6%97%B6"><span class="toc-number">3.8.</span> <span class="toc-text">若修改值大于 16 ，则超过 16 次的重试时间间隔均为 2 小时</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97-1"><span class="toc-number">4.</span> <span class="toc-text">4 重试队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%EF%BC%89%E5%8F%AA%E6%9C%89%E5%BD%93%E5%87%BA%E7%8E%B0%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E9%87%8D%E8%AF%95%E6%B6%88%E8%B4%B9%E7%9A%84%E6%B6%88%E6%81%AF%E6%97%B6%EF%BC%8C%E6%89%8D%E4%BC%9A%E4%B8%BA%E8%AF%A5%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E5%88%9B%E5%BB%BA%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97"><span class="toc-number">4.1.</span> <span class="toc-text">2 ）只有当出现需要进行重试消费的消息时，才会为该消费者组创建重试队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%8C%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E4%B8%8E%E5%BB%B6%E6%97%B6%E6%B6%88%E8%B4%B9%E7%9A%84%E5%BB%B6%E6%97%B6%E7%AD%89%E7%BA%A7%E5%8D%81%E5%88%86%E7%9B%B8%E4%BC%BC%EF%BC%8C%E9%99%A4%E4%BA%86%E6%B2%A1%E6%9C%89%E5%BB%B6%E6%97%B6%E7%AD%89%E7%BA%A7%E7%9A%84%E5%89%8D%E4%B8%A4%E4%B8%AA%E6%97%B6%E9%97%B4"><span class="toc-number">4.2.</span> <span class="toc-text">注意，消费重试的时间间隔与延时消费的延时等级十分相似，除了没有延时等级的前两个时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%EF%BC%8C%E5%85%B6%E5%AE%83%E7%9A%84%E6%97%B6%E9%97%B4%E9%83%BD%E6%98%AF%E7%9B%B8%E5%90%8C%E7%9A%84"><span class="toc-number">4.3.</span> <span class="toc-text">外，其它的时间都是相同的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">5 消费重试配置方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F%E4%B8%8B%EF%BC%8C%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%90%8E%E8%8B%A5%E5%B8%8C%E6%9C%9B%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%EF%BC%8C%E5%88%99%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B6%88%E6%81%AF%E7%9B%91%E5%90%AC%E5%99%A8%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%AD%E6%98%8E%E7%A1%AE%E8%BF%9B%E8%A1%8C%E5%A6%82%E4%B8%8B%E4%B8%89"><span class="toc-number">5.1.</span> <span class="toc-text">集群消费方式下，消息消费失败后若希望消费重试，则需要在消息监听器接口的实现中明确进行如下三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%B9%8B%E4%B8%80%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">种方式之一的配置：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B6%88%E8%B4%B9%E4%B8%8D%E9%87%8D%E8%AF%95%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">6 消费不重试配置方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%E6%96%B9%E5%BC%8F%E4%B8%8B%EF%BC%8C%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E5%90%8E%E8%8B%A5%E4%B8%8D%E5%B8%8C%E6%9C%9B%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%EF%BC%8C%E5%88%99%E5%9C%A8%E6%8D%95%E8%8E%B7%E5%88%B0%E5%BC%82%E5%B8%B8%E5%90%8E%E5%90%8C%E6%A0%B7%E4%B9%9F%E8%BF%94%E5%9B%9E%E4%B8%8E%E6%B6%88%E8%B4%B9%E6%88%90%E5%8A%9F%E5%90%8E%E7%9A%84%E7%9B%B8"><span class="toc-number">6.1.</span> <span class="toc-text">集群消费方式下，消息消费失败后若不希望消费重试，则在捕获到异常后同样也返回与消费成功后的相</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">九、死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">1 什么是死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E6%98%AF%E7%94%A8%E4%BA%8E%E5%A4%84%E7%90%86%E6%97%A0%E6%B3%95%E8%A2%AB%E6%AD%A3%E5%B8%B8%E6%B6%88%E8%B4%B9%E7%9A%84%E6%B6%88%E6%81%AF%E7%9A%84%E3%80%82"><span class="toc-number">1.1.</span> <span class="toc-text">死信队列是用于处理无法被正常消费的消息的。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">2.</span> <span class="toc-text">2 死信队列的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E5%85%B7%E6%9C%89%E5%A6%82%E4%B8%8B%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">死信队列具有如下特征：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%BB%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3 死信消息的处理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="Mysql主从复制"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql主从复制"/></a><div class="content"><a class="title" href="/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="Mysql主从复制">Mysql主从复制</a><time datetime="2023-11-29T02:15:37.000Z" title="发表于 2023-11-29 10:15:37">2023-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/Docker/" title="Docker"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2023/11/27/Docker/" title="Docker">Docker</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/ElasticSearch/" title="ElasticSearch"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch"/></a><div class="content"><a class="title" href="/2023/11/27/ElasticSearch/" title="ElasticSearch">ElasticSearch</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/JDK/" title="JDK1.8新特性"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK1.8新特性"/></a><div class="content"><a class="title" href="/2023/11/27/JDK/" title="JDK1.8新特性">JDK1.8新特性</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/JVM/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/" title="JVM字节码"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM字节码"/></a><div class="content"><a class="title" href="/2023/11/27/JVM/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/" title="JVM字节码">JVM字节码</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Miller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>