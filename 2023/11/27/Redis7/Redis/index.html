<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | Miller</title><meta name="author" content="Miller"><meta name="copyright" content="Miller"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. NoSQL 数据库简介1. 1. 技术发展技术的分类 1 、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 2 、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis 3 、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch1. 1. 1.">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://example.com/2023/11/27/Redis7/Redis/index.html">
<meta property="og:site_name" content="Miller">
<meta property="og:description" content="1. NoSQL 数据库简介1. 1. 技术发展技术的分类 1 、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN 2 、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis 3 、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch1. 1. 1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png">
<meta property="article:published_time" content="2023-11-27T14:15:37.000Z">
<meta property="article:modified_time" content="2023-11-27T08:01:56.446Z">
<meta property="article:author" content="Miller">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/11/27/Redis7/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Miller","link":"链接: ","source":"来源: Miller","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-27 16:01:56'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://file.crazywong.com/gh/jerryc127/CDN@latest/Photo/tags.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Miller"><span class="site-name">Miller</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-27T08:01:56.446Z" title="更新于 2023-11-27 16:01:56">2023-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-NoSQL-数据库简介"><a href="#1-NoSQL-数据库简介" class="headerlink" title="1. NoSQL 数据库简介"></a>1. NoSQL 数据库简介</h2><h2 id="1-1-技术发展"><a href="#1-1-技术发展" class="headerlink" title="1. 1. 技术发展"></a>1. 1. 技术发展</h2><p>技术的分类</p>
<p>1 、解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</p>
<p>2 、解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</p>
<h6 id="3-、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch"><a href="#3-、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch" class="headerlink" title="3 、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch"></a>3 、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</h6><h2 id="1-1-1-Web-1-0-时代"><a href="#1-1-1-Web-1-0-时代" class="headerlink" title="1. 1. 1. Web 1. 0 时代"></a>1. 1. 1. Web 1. 0 时代</h2><p>Web 1. 0 的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p>
<h2 id="1-1-2-Web-2-0-时代"><a href="#1-1-2-Web-2-0-时代" class="headerlink" title="1. 1. 2. Web 2. 0 时代"></a>1. 1. 2. Web 2. 0 时代</h2><p>随着 Web 2. 0 的时代的到来，用户访问量大幅度提升，同时产生了大量的用户<br>数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p>
<h4 id="1-1-3-解决-CPU-及内存压力"><a href="#1-1-3-解决-CPU-及内存压力" class="headerlink" title="1. 1. 3. 解决 CPU 及内存压力"></a>1. 1. 3. 解决 CPU 及内存压力</h4><h4 id="1-1-4-解决-IO-压力"><a href="#1-1-4-解决-IO-压力" class="headerlink" title="1. 1. 4. 解决 IO 压力"></a>1. 1. 4. 解决 IO 压力</h4><h4 id="1-2-NoSQL-数据库"><a href="#1-2-NoSQL-数据库" class="headerlink" title="1. 2 .NoSQL 数据库"></a>1. 2 .NoSQL 数据库</h4><h4 id="1-2-1-NoSQL-数据库概述"><a href="#1-2-1-NoSQL-数据库概述" class="headerlink" title="1. 2. 1. NoSQL 数据库概述"></a>1. 2. 1. NoSQL 数据库概述</h4><p>NoSQL(NoSQL&#x3D; <strong>NotOnlySQL</strong> )，意即“不仅仅是 SQL”，泛指非关系型的数据库。</p>
<p>NoSQL不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加<br>了数据库的扩展能力。</p>
<p> 不遵循SQL标准。</p>
<p> 不支持ACID。</p>
<p> 远超于SQL的性能。</p>
<h4 id="1-2-2-NoSQL-适用场景"><a href="#1-2-2-NoSQL-适用场景" class="headerlink" title="1. 2. 2. NoSQL 适用场景"></a>1. 2. 2. NoSQL 适用场景</h4><p> 对数据高并发的读写</p>
<p> 海量数据的读写</p>
<p> 对数据高可扩展性的</p>
<h4 id="1-2-3-NoSQL-不适用场景"><a href="#1-2-3-NoSQL-不适用场景" class="headerlink" title="1. 2. 3. NoSQL 不适用场景"></a>1. 2. 3. NoSQL 不适用场景</h4><p> 需要事务支持</p>
<p> 基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</p>
<p> （用不着 <strong>sql</strong> 的和用了 <strong>sql</strong> 也不行的情况，请考虑用 <strong>NoSql</strong> ）</p>
<h4 id="1-2-4-Memcache"><a href="#1-2-4-Memcache" class="headerlink" title="1. 2. 4. Memcache"></a>1. 2. 4. Memcache</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">很早出现的 NoSql数据库</span><br><span class="line">数据都在内存中，一般不持久化</span><br><span class="line">支持简单的 key-value模式，支持类型单一</span><br><span class="line">一般是作为缓存数据库辅助持久化的数据库</span><br></pre></td></tr></table></figure>
<h4 id="1-2-5-Redis"><a href="#1-2-5-Redis" class="headerlink" title="1. 2. 5. Redis"></a>1. 2. 5. Redis</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">几乎覆盖了 Memcached的绝大部分功能</span><br><span class="line">数据都在内存中，支持持久化，主要用作备份恢复</span><br><span class="line">除了支持简单的 key-value 模式，还支持多种数据结构的存储，比如list、set、hash、zset 等。</span><br><span class="line">一般是作为缓存数据库辅助持久化的数据库</span><br></pre></td></tr></table></figure>
<h4 id="1-2-6-MongoDB"><a href="#1-2-6-MongoDB" class="headerlink" title="1. 2. 6. MongoDB"></a>1. 2. 6. MongoDB</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">高性能、开源、模式自由(schemafree)的文档型数据库</span><br><span class="line">数据都在内存中，如果内存不足，把不常用的数据保存到硬盘</span><br><span class="line">虽然是 key-value模式，但是对 value（尤其是 json）提供了丰富的查询功能</span><br><span class="line">支持二进制数据及大型对象</span><br><span class="line">可以根据数据的特点替代 RDBMS，成为独立的数据库。或者配合 RDBMS，存储特定的数据。</span><br></pre></td></tr></table></figure>

<h4 id="1-3-行式存储数据库（大数据时代）"><a href="#1-3-行式存储数据库（大数据时代）" class="headerlink" title="1. 3. 行式存储数据库（大数据时代）"></a>1. 3. 行式存储数据库（大数据时代）</h4><h4 id="1-3-1-行式数据库"><a href="#1-3-1-行式数据库" class="headerlink" title="1. 3. 1. 行式数据库"></a>1. 3. 1. 行式数据库</h4><h4 id="1-3-2-列式数据库"><a href="#1-3-2-列式数据库" class="headerlink" title="1. 3. 2. 列式数据库"></a>1. 3. 2. 列式数据库</h4><h5 id="1-3-2-1-Hbase"><a href="#1-3-2-1-Hbase" class="headerlink" title="1. 3. 2. 1 .Hbase"></a>1. 3. 2. 1 .Hbase</h5><p>HBase是 <strong>Hadoop</strong> 项目中的数据库。它用于需要对大量的数据进行随机、实时的读写<br>操作的场景中。</p>
<p>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过 <strong>10</strong> 亿行<br>数据，还可处理有数百万列元素的数据表。</p>
<h5 id="1-3-2-2-Cassandra-kəˈsaendrə"><a href="#1-3-2-2-Cassandra-kəˈsaendrə" class="headerlink" title="1. 3. 2. 2 .Cassandra[kəˈsændrə]"></a>1. 3. 2. 2 .Cassandra[kəˈsændrə]</h5><p>ApacheCassandra是一款免费的开源 NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集 <strong>(</strong> 数据量通常达到 <strong>PB</strong> 级别 <strong>)</strong> 。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p>
<p>计算机存储单位计算机存储单位一般用B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：</p>
<p>位bit(比特)(BinaryDigits)：存放一位二进制数，即 0 或 1 ，最小的存储单位。</p>
<p>字节byte： 8 个二进制位为一个字节(B)，最常用的单位。</p>
<p>1 KB(Kilobyte千字节)&#x3D; 1024 B，</p>
<p>1 MB(Megabyte兆字节简称“兆”)&#x3D; 1024 KB，</p>
<p>1 GB(Gigabyte吉字节又称“千兆”)&#x3D; 1024 MB，</p>
<p>1 TB(Trillionbyte万亿字节太字节)&#x3D; 1024 GB，其中 1024 &#x3D; 2 ^ 10 ( 2 的 10 次方)，</p>
<p>1 PB（Petabyte千万亿字节拍字节）&#x3D; 1024 TB，</p>
<p>1 EB（Exabyte百亿亿字节艾字节）&#x3D; 1024 PB，</p>
<p>1 ZB(Zettabyte十万亿亿字节泽字节)&#x3D; 1024 EB,</p>
<p>1 YB(Jottabyte一亿亿亿字节尧字节)&#x3D; 1024 ZB,</p>
<p>1 BB(Brontobyte一千亿亿亿字节)&#x3D; 1024 YB.</p>
<p>注：“兆”为百万级数量单位。</p>
<h4 id="1-4-图关系型数据库"><a href="#1-4-图关系型数据库" class="headerlink" title="1. 4. 图关系型数据库"></a>1. 4. 图关系型数据库</h4><p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n- 1 )&#x2F; 2 )</p>
<h4 id="1-5-DB-Engines-数据库排名"><a href="#1-5-DB-Engines-数据库排名" class="headerlink" title="1. 5 .DB-Engines 数据库排名"></a>1. 5 .DB-Engines 数据库排名</h4><p><a target="_blank" rel="noopener" href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p>
<h2 id="2-Redis-概述安装"><a href="#2-Redis-概述安装" class="headerlink" title="2 .Redis 概述安装"></a>2 .Redis 概述安装</h2><p> Redis是一个开源的key-value存储系统。</p>
<p> 和Memcached类似，它支持存储的 value类型相对更多，包括string(字符串)、<br>list(链表)、set(集合)、zset(sortedset–有序集合)和 hash（哈希类型）。</p>
<p> 这些数据类型都支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，<br>而且这些操作都是原子性的。</p>
<p> 在此基础上，Redis支持各种不同方式的排序。</p>
<p> 与memcached一样，为了保证效率，数据都是缓存在内存中。</p>
<p> 区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记<br>录文件。</p>
<p> 并且在此基础上实现了 master-slave(主从)同步。</p>
<h4 id="2-1-应用场景"><a href="#2-1-应用场景" class="headerlink" title="2. 1. 应用场景"></a>2. 1. 应用场景</h4><h4 id="2-1-1-配合关系型数据库做高速缓存"><a href="#2-1-1-配合关系型数据库做高速缓存" class="headerlink" title="2. 1. 1. 配合关系型数据库做高速缓存"></a>2. 1. 1. 配合关系型数据库做高速缓存</h4><p> 高频次，热门访问的数据，降低数据库IO</p>
<p> 分布式架构，做session共享</p>
<h4 id="2-1-2-多样的数据结构存储持久化数据"><a href="#2-1-2-多样的数据结构存储持久化数据" class="headerlink" title="2. 1. 2. 多样的数据结构存储持久化数据"></a>2. 1. 2. 多样的数据结构存储持久化数据</h4><h4 id="2-2-Redis-安装"><a href="#2-2-Redis-安装" class="headerlink" title="2. 2 .Redis 安装"></a>2. 2 .Redis 安装</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis官方网站 Redis中文官方网站</span><br><span class="line">http://redis.io http://redis.cn/</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-安装版本"><a href="#2-2-1-安装版本" class="headerlink" title="2. 2. 1. 安装版本"></a>2. 2. 1. 安装版本</h4><p> 6. 2. 1 forLinux（redis- 6. 2. 1 .tar.gz）</p>
<p> 不用考虑在windows环境下对Redis的支持</p>
<h4 id="2-2-2-安装步骤"><a href="#2-2-2-安装步骤" class="headerlink" title="2. 2. 2. 安装步骤"></a>2. 2. 2. 安装步骤</h4><h4 id="2-2-2-1-准备工作：下载安装最新版的-gcc-编译器"><a href="#2-2-2-1-准备工作：下载安装最新版的-gcc-编译器" class="headerlink" title="2. 2. 2. 1. 准备工作：下载安装最新版的 gcc 编译器"></a>2. 2. 2. 1. 准备工作：下载安装最新版的 gcc 编译器</h4><p>安装C语言的编译环境</p>
<h6 id="yuminstallcentos-release-sclscl-utils-build"><a href="#yuminstallcentos-release-sclscl-utils-build" class="headerlink" title="yuminstallcentos-release-sclscl-utils-build"></a>yuminstallcentos-release-sclscl-utils-build</h6><p>yuminstall-ydevtoolset- 8 - toolchain</p>
<p>sclenabledevtoolset- 8 bash</p>
<p>测试gcc版本</p>
<p>gcc–version</p>
<h4 id="2-2-2-2-下载-redis-6-2-1-tar-gz-放-opt-目录"><a href="#2-2-2-2-下载-redis-6-2-1-tar-gz-放-opt-目录" class="headerlink" title="2. 2. 2. 2. 下载 redis- 6. 2. 1 .tar.gz 放&#x2F;opt 目录"></a>2. 2. 2. 2. 下载 redis- 6. 2. 1 .tar.gz 放&#x2F;opt 目录</h4><h4 id="2-2-2-3-解压命令：tar-zxvfredis-6-2-1-tar-gz"><a href="#2-2-2-3-解压命令：tar-zxvfredis-6-2-1-tar-gz" class="headerlink" title="2. 2. 2. 3. 解压命令：tar-zxvfredis- 6. 2. 1 .tar.gz"></a>2. 2. 2. 3. 解压命令：tar-zxvfredis- 6. 2. 1 .tar.gz</h4><h4 id="2-2-2-4-解压完成后进入目录：cdredis-6-2-1"><a href="#2-2-2-4-解压完成后进入目录：cdredis-6-2-1" class="headerlink" title="2. 2. 2. 4. 解压完成后进入目录：cdredis- 6. 2. 1"></a>2. 2. 2. 4. 解压完成后进入目录：cdredis- 6. 2. 1</h4><h4 id="2-2-2-5-在-redis-6-2-1-目录下再次执行-make-命令（只"><a href="#2-2-2-5-在-redis-6-2-1-目录下再次执行-make-命令（只" class="headerlink" title="2. 2. 2. 5. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只"></a>2. 2. 2. 5. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只</h4><h4 id="是编译好）"><a href="#是编译好）" class="headerlink" title="是编译好）"></a>是编译好）</h4><h4 id="2-2-2-6-如果没有准备好-C-语言编译环境，make-会报"><a href="#2-2-2-6-如果没有准备好-C-语言编译环境，make-会报" class="headerlink" title="2. 2. 2. 6. 如果没有准备好 C 语言编译环境，make 会报"></a>2. 2. 2. 6. 如果没有准备好 C 语言编译环境，make 会报</h4><h4 id="错—Jemalloc-jemalloc-h：没有那个文件"><a href="#错—Jemalloc-jemalloc-h：没有那个文件" class="headerlink" title="错—Jemalloc&#x2F;jemalloc.h：没有那个文件"></a>错—Jemalloc&#x2F;jemalloc.h：没有那个文件</h4><h4 id="2-2-2-7-解决方案：运行-makedistclean"><a href="#2-2-2-7-解决方案：运行-makedistclean" class="headerlink" title="2. 2. 2. 7. 解决方案：运行 makedistclean"></a>2. 2. 2. 7. 解决方案：运行 makedistclean</h4><h4 id="2-2-2-8-在-redis-6-2-1-目录下再次执行-make-命令（只"><a href="#2-2-2-8-在-redis-6-2-1-目录下再次执行-make-命令（只" class="headerlink" title="2. 2. 2. 8. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只"></a>2. 2. 2. 8. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只</h4><h4 id="是编译好）-1"><a href="#是编译好）-1" class="headerlink" title="是编译好）"></a>是编译好）</h4><h4 id="2-2-2-9-跳过-maketest继续执行-makeinstall"><a href="#2-2-2-9-跳过-maketest继续执行-makeinstall" class="headerlink" title="2. 2. 2. 9. 跳过 maketest继续执行:makeinstall"></a>2. 2. 2. 9. 跳过 maketest继续执行:makeinstall</h4><h4 id="2-2-3-安装目录：-usr-local-bin"><a href="#2-2-3-安装目录：-usr-local-bin" class="headerlink" title="2. 2. 3. 安装目录：&#x2F;usr&#x2F;local&#x2F;bin"></a>2. 2. 3. 安装目录：&#x2F;usr&#x2F;local&#x2F;bin</h4><p>查看默认安装目录：</p>
<p>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</p>
<p>redis-check-aof：修复有问题的AOF文件，rdb和 aof后面讲</p>
<p>redis-check-dump：修复有问题的dump.rdb文件</p>
<p>redis-sentinel：Redis集群使用</p>
<p>redis-server：Redis服务器启动命令</p>
<p>redis-cli：客户端，操作入口</p>
<h4 id="2-2-4-前台启动（不推荐）"><a href="#2-2-4-前台启动（不推荐）" class="headerlink" title="2. 2. 4. 前台启动（不推荐）"></a>2. 2. 4. 前台启动（不推荐）</h4><p>前台启动，命令行窗口不能关闭，否则服务器停止</p>
<h4 id="2-2-5-后台启动（推荐）"><a href="#2-2-5-后台启动（推荐）" class="headerlink" title="2. 2. 5. 后台启动（推荐）"></a>2. 2. 5. 后台启动（推荐）</h4><h5 id="2-2-5-1-备份-redis-conf"><a href="#2-2-5-1-备份-redis-conf" class="headerlink" title="2. 2. 5. 1. 备份 redis.conf"></a>2. 2. 5. 1. 备份 redis.conf</h5><p>拷贝一份redis.conf到其他目录</p>
<p>cp &#x2F;opt&#x2F;redis- 3. 2. 5 &#x2F;redis.conf &#x2F;myredis</p>
<h5 id="2-2-5-2-后台启动设置-daemonizeno-改成-yes"><a href="#2-2-5-2-后台启动设置-daemonizeno-改成-yes" class="headerlink" title="2. 2. 5. 2. 后台启动设置 daemonizeno 改成 yes"></a>2. 2. 5. 2. 后台启动设置 daemonizeno 改成 yes</h5><p>修改redis.conf( 128 行)文件将里面的daemonizeno改成yes，让服务在后台启动</p>
<h5 id="2-2-5-3-Redis-启动"><a href="#2-2-5-3-Redis-启动" class="headerlink" title="2. 2. 5. 3 .Redis 启动"></a>2. 2. 5. 3 .Redis 启动</h5><p>redis-server&#x2F;myredis&#x2F;redis.conf</p>
<h5 id="2-2-5-4-用客户端访问：-redis-cli"><a href="#2-2-5-4-用客户端访问：-redis-cli" class="headerlink" title="2. 2. 5. 4. 用客户端访问： redis-cli"></a>2. 2. 5. 4. 用客户端访问： redis-cli</h5><h5 id="2-2-5-5-多个端口可以：-redis-cli-p-6379"><a href="#2-2-5-5-多个端口可以：-redis-cli-p-6379" class="headerlink" title="2. 2. 5. 5. 多个端口可以： redis-cli-p 6379"></a>2. 2. 5. 5. 多个端口可以： redis-cli-p 6379</h5><h5 id="2-2-5-6-测试验证：-ping"><a href="#2-2-5-6-测试验证：-ping" class="headerlink" title="2. 2. 5. 6. 测试验证： ping"></a>2. 2. 5. 6. 测试验证： ping</h5><h5 id="2-2-5-7-Redis-关闭"><a href="#2-2-5-7-Redis-关闭" class="headerlink" title="2. 2. 5. 7 .Redis 关闭"></a>2. 2. 5. 7 .Redis 关闭</h5><p>单实例关闭：redis-clishutdown</p>
<p>也可以进入终端后再关闭</p>
<p>多实例关闭，指定端口关闭：redis-cli-p 6379 shutdown</p>
<h4 id="2-2-6-Redis-介绍相关知识"><a href="#2-2-6-Redis-介绍相关知识" class="headerlink" title="2. 2. 6. Redis 介绍相关知识"></a>2. 2. 6. Redis 介绍相关知识</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">端口 6379 从何而来</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alessia Merz</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认 16 个数据库，类似数组下标从 0 开始，初始默认使</span><br><span class="line">用 0 号库</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用命令select &lt;dbid&gt;来切换数据库。如:select 8</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">统一密码管理，所有库同样密码。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbsize查看当前数据库的key的数量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushdb清空当前库</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flushall通杀全部库</span><br></pre></td></tr></table></figure>
<p>Redis是单线程+多路IO复用技术</p>
<p>多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用<br>select和 poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则<br>阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启<br>动线程执行（比如使用线程池）</p>
<p>串行 vs 多线程+锁（memcached）vs 单线程+多路IO复用(Redis)</p>
<p>（与Memcache三点不同:支持多数据类型，支持持久化，单线程+多路IO复用）</p>
<h2 id="3-常用五大数据类型"><a href="#3-常用五大数据类型" class="headerlink" title="3. 常用五大数据类型"></a>3. 常用五大数据类型</h2><p>哪里去获得redis常见数据类型操作命令 <a target="_blank" rel="noopener" href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></p>
<h3 id="3-1-Redis-键-key"><a href="#3-1-Redis-键-key" class="headerlink" title="3. 1 .Redis 键 (key)"></a>3. 1 .Redis 键 (key)</h3><p>keys<em>查看当前库所有 key (匹配：keys</em> 1 )</p>
<p>existskey判断某个key是否存在</p>
<p>typekey查看你的key是什么类型</p>
<p>delkey 删除指定的key数据</p>
<p>unlinkkey 根据value选择非阻塞删除</p>
<p>仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</p>
<p>expirekey^1010 秒钟：为给定的key设置过期时间</p>
<p>ttlkey查看还有多少秒过期，- 1 表示永不过期，- 2 表示已过期</p>
<p>select命令切换数据库</p>
<p>dbsize查看当前数据库的key的数量</p>
<p>flushdb清空当前库</p>
<p>flushall通杀全部库</p>
<h4 id="3-2-Redis-字符串-String"><a href="#3-2-Redis-字符串-String" class="headerlink" title="3. 2 .Redis 字符串 (String)"></a>3. 2 .Redis 字符串 (String)</h4><h4 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3. 2. 1. 简介"></a>3. 2. 1. 简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个<br>key对应一个value。</p>
<p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图<br>片或者序列化的对象。</p>
<p>String类型是Redis最基本的数据类型，一个Redis中字符串 value最多可以是 512 M</p>
<h4 id="3-2-2-常用命令"><a href="#3-2-2-常用命令" class="headerlink" title="3. 2. 2. 常用命令"></a>3. 2. 2. 常用命令</h4><p>set <key><value>添加键值对</value></key></p>
<p>*NX：当数据库中 key不存在时，可以将key-value添加数据库</p>
<p>*XX：当数据库中key存在时，可以将key-value添加数据库，与 NX参数互斥</p>
<p>*EX：key的超时秒数</p>
<p>*PX：key的超时毫秒数，与EX互斥</p>
<p>get <key>查询对应键值</key></p>
<p>append <key><value>将给定的<value>追加到原值的末尾</value></value></key></p>
<p>strlen <key>获得值的长度</key></p>
<p>setnx <key><value>只有在key不存在时 设置key的值</value></key></p>
<p>incr <key></key></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将key中储存的数字值增 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只能对数字值操作，如果为空，新增值为 1</span><br></pre></td></tr></table></figure>
<p>decr <key></key></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将key中储存的数字值减 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只能对数字值操作，如果为空，新增值为- 1</span><br></pre></td></tr></table></figure>
<p>incrby&#x2F;decrby <key>&lt;步长&gt;将key中储存的数字值增减。自定义步长。</key></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原子性</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">所谓原子操作是指不会被线程调度机制打断的操作；</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这种操作一旦开始，就一直运行到结束，中间不会有任何contextswitch（切换到另</span><br><span class="line">一个线程）。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（ 1 ）在单线程中，能够在单条指令中完成的操作都可以认为是&quot;原子操作&quot;，因为中</span><br><span class="line">断只能发生于指令之间。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（ 2 ）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis单命令的原子性主要得益于Redis的单线程。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例：</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java中的i++是否是原子操作？不是</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 0 ;两个线程分别对i进行++ 100 次,值是多少？ 2 ~ 200</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 0</span><br><span class="line">i++</span><br><span class="line">i= 99</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i++</span><br><span class="line">i= 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i= 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i++</span><br><span class="line">i= 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i++</span><br><span class="line">i= 100</span><br></pre></td></tr></table></figure>
<p>mset &lt;key 1 &gt;&lt;value 1 &gt;&lt;key 2 &gt;&lt;value 2 &gt; …..</p>
<p>同时设置一个或多个key-value对</p>
<p>mget &lt;key 1 &gt;&lt;key 2 &gt;&lt;key 3 &gt;…..</p>
<p>同时获取一个或多个value</p>
<p>msetnx&lt;key 1 &gt;&lt;value 1 &gt;&lt;key 2 &gt;&lt;value 2 &gt; …..</p>
<p>同时设置一个或多个key-value对，当且仅当所有给定key都不存在。</p>
<p>原子性，有一个失败则都失败</p>
<p>getrange <key>&lt;起始位置&gt;&lt;结束位置&gt;</key></p>
<p>获得值的范围，类似java中的substring，前包，后包</p>
<p>setrange <key>&lt;起始位置&gt;<value></value></key></p>
<p>用<value> 覆写<key>所储存的字符串值，从&lt;起始位置&gt;开始(索引从 <strong>0</strong> 开始)。</key></value></p>
<p><strong>setex <key>&lt;** 过期时间 **&gt;<value></value></key></strong></p>
<p>设置键值的同时，设置过期时间，单位秒。</p>
<p>getset<key><value></value></key></p>
<p>以新换旧，设置了新值同时获得旧值。</p>
<h4 id="3-2-3-数据结构"><a href="#3-2-3-数据结构" class="headerlink" title="3. 2. 3. 数据结构"></a>3. 2. 3. 数据结构</h4><p>String的数据结构为简单动态字符串(SimpleDynamicString,缩写 SDS)。是可以<br>修改的字符串，内部结构实现上类似于Java的 ArrayList，采用预分配冗余空间的方<br>式来减少内存的频繁分配.</p>
<p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度<br>len。当字符串长度小于 1 M时，扩容都是加倍现有的空间，如果超过 1 M，扩容时一<br>次只会多扩 1 M的空间。需要注意的是字符串最大长度为 512 M。</p>
<h4 id="3-3-Redis-列表-List"><a href="#3-3-Redis-列表-List" class="headerlink" title="3. 3 .Redis 列表 (List)"></a>3. 3 .Redis 列表 (List)</h4><h4 id="3-3-1-简介"><a href="#3-3-1-简介" class="headerlink" title="3. 3. 1. 简介"></a>3. 3. 1. 简介</h4><p>单键多值</p>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头<br>部（左边）或者尾部（右边）。</p>
<p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节<br>点性能会较差。</p>
<h4 id="3-3-2-常用命令"><a href="#3-3-2-常用命令" class="headerlink" title="3. 3. 2. 常用命令"></a>3. 3. 2. 常用命令</h4><p>lpush&#x2F;rpush <key>&lt;value 1 &gt;&lt;value 2 &gt;&lt;value 3 &gt;….从左边&#x2F;右边插入一个或多个值。</key></p>
<p>lpop&#x2F;rpop <key>从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</key></p>
<p>rpoplpush &lt;key 1 &gt;&lt;key 2 &gt;从&lt;key 1 &gt;列表右边吐出一个值，插到&lt;key 2 &gt;列表左边。</p>
<p>lrange<key><start><stop></stop></start></key></p>
<p>按照索引下标获得元素(从左到右)</p>
<p>lrangemylist 0 - 1 0 左边第一个，- 1 右边第一个，（ 0 - 1 表示获取所有）</p>
<p>lindex<key><index>按照索引下标获得元素(从左到右)</index></key></p>
<p>llen<key>获得列表长度</key></p>
<p>linsert<key> before<value><newvalue>在<value>的后面插入<newvalue>插入值</newvalue></value></newvalue></value></key></p>
<p>lrem<key><n><value>从左边删除 n个 value(从左到右)</value></n></key></p>
<p>lset<key><index><value>将列表 key下标为index的值替换成value</value></index></key></p>
<h4 id="3-3-3-数据结构"><a href="#3-3-3-数据结构" class="headerlink" title="3. 3. 3. 数据结构"></a>3. 3. 3. 数据结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List的数据结构为快速链表quickList。</span><br></pre></td></tr></table></figure>
<p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即<br>是压缩列表。</p>
<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>
<p>当数据量比较多的时候才会改成quicklist。</p>
<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只<br>是int类型的数据，结构上还需要两个额外的指针 prev和 next。</p>
<p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个 ziplist使用双向<br>指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<h4 id="3-4-Redis-集合-Set"><a href="#3-4-Redis-集合-Set" class="headerlink" title="3. 4 .Redis 集合 (Set)"></a>3. 4 .Redis 集合 (Set)</h4><h4 id="3-4-1-简介"><a href="#3-4-1-简介" class="headerlink" title="3. 4. 1. 简介"></a>3. 4. 1. 简介</h4><p>Redisset对外提供的功能与 list类似是一个列表的功能，特殊之处在于 set是可以自<br>动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的<br>选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list<br>所不能提供的。</p>
<p>Redis的Set是 string类型的无序集合。它底层其实是一个value为 null的 hash表，<br>所以添加，删除，查找的复杂度都是 <strong>O( 1 )</strong> 。</p>
<p>一个算法，随着数据的增加，执行时间的长短，如果是O( 1 )，数据增加，查找数据的<br>时间不变</p>
<h4 id="3-4-2-常用命令"><a href="#3-4-2-常用命令" class="headerlink" title="3. 4. 2. 常用命令"></a>3. 4. 2. 常用命令</h4><p>sadd<key>&lt;value 1 &gt;&lt;value 2 &gt;…..</key></p>
<p>将一个或多个member元素加入到集合key中，已经存在的member元素将被忽略</p>
<p>smembers<key>取出该集合的所有值。</key></p>
<p>sismember<key><value>判断集合<key>是否为含有该<value>值，有 1 ，没有 0</value></key></value></key></p>
<p>scard<key>返回该集合的元素个数。</key></p>
<p>srem<key>&lt;value 1 &gt;&lt;value 2 &gt;….删除集合中的某个元素。</key></p>
<p>spop<key>随机从该集合中吐出一个值。</key></p>
<p>srandmember<key><n>随机从该集合中取出 n个值。不会从集合中删除。</n></key></p>
<p>smove<source><destination>value把集合中一个值从一个集合移动到另一个集合</destination></p>
<p>sinter&lt;key 1 &gt;&lt;key 2 &gt;返回两个集合的交集元素。</p>
<p>sunion&lt;key 1 &gt;&lt;key 2 &gt;返回两个集合的并集元素。</p>
<p>sdiff&lt;key 1 &gt;&lt;key 2 &gt;返回两个集合的差集元素(key 1 中的，不包含key 2 中的)</p>
<h4 id="3-4-3-数据结构"><a href="#3-4-3-数据结构" class="headerlink" title="3. 4. 3. 数据结构"></a>3. 4. 3. 数据结构</h4><p>Set数据结构是 dict字典，字典是用哈希表实现的。</p>
<p>Java中HashSet的内部实现使用的是HashMap，只不过所有的 value都指向同一个对<br>象。Redis的 set结构也是一样，它的内部也使用hash结构，所有的value都指向同一<br>个内部值。</p>
<h4 id="3-5-Redis-哈希-Hash"><a href="#3-5-Redis-哈希-Hash" class="headerlink" title="3. 5 .Redis 哈希 (Hash)"></a>3. 5 .Redis 哈希 (Hash)</h4><h4 id="3-5-1-简介"><a href="#3-5-1-简介" class="headerlink" title="3. 5. 1. 简介"></a>3. 5. 1. 简介</h4><p>Redishash是一个键值对集合。</p>
<p>Redishash是一个string类型的field和value的映射表，hash特别适合用于存储对<br>象。</p>
<p>类似Java里面的 Map&lt;String,Object&gt;</p>
<p>用户ID为查找的 key，存储的value用户对象包含姓名，年龄，生日等信息，如果用<br>普通的key&#x2F;value结构来存储</p>
<p>主要有以下 2 种存储方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">每次修改用户的某个属性需要，先反序列化</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户 ID数据冗余</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">改好后再序列化回去。开销较大。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过key(用户 ID)+field( 属性标签 ) 就可以操作对应属性数据了，既不需要重复存储数</span><br><span class="line">据，也不会带来序列化和并发修改控制的问题</span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-常用命令"><a href="#3-5-2-常用命令" class="headerlink" title="3. 5. 2. 常用命令"></a>3. 5. 2. 常用命令</h4><p>hset<key><field><value>给<key>集合中的 <field>键赋值<value></value></field></key></value></field></key></p>
<p>hget&lt;key 1 &gt;<field>从&lt;key 1 &gt;集合<field>取出value</field></field></p>
<p>hmset&lt;key 1 &gt;&lt;field 1 &gt;&lt;value 1 &gt;&lt;field 2 &gt;&lt;value 2 &gt;…批量设置 hash 的值</p>
<p>hexists&lt;key 1 &gt;<field>查看哈希表key中，给定域field是否存在。</field></p>
<p>hkeys<key>列出该 hash 集合的所有field</key></p>
<p>hvals<key>列出该 hash集合的所有 value</key></p>
<p>hincrby<key><field><increment>为哈希表key中的域field的值加上增量 1 - 1</increment></field></key></p>
<p>hsetnx<key><field><value>将哈希表key中的域field的值设置为value，当且仅当域field不<br>存在.</value></field></key></p>
<h4 id="3-5-3-数据结构"><a href="#3-5-3-数据结构" class="headerlink" title="3. 5. 3. 数据结构"></a>3. 5. 3. 数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当<br>field-value长度较短且个数较少时，使用ziplist，否则使用 hashtable。</p>
<h4 id="3-6-Redis-有序集合-Zset-sortedset"><a href="#3-6-Redis-有序集合-Zset-sortedset" class="headerlink" title="3. 6 .Redis 有序集合 Zset(sortedset)"></a>3. 6 .Redis 有序集合 Zset(sortedset)</h4><h4 id="3-6-1-简介"><a href="#3-6-1-简介" class="headerlink" title="3. 6. 1. 简介"></a>3. 6. 1. 简介</h4><p>Redis有序集合zset与普通集合 set非常相似，是一个没有重复元素的字符串集合。</p>
<p>不同之处是有序集合的每个成员都关联了一个评分（ <strong>score</strong> ）,这个评分（score）被用<br>来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分<br>可以是重复了。</p>
<p>因为元素是有序的,所以你也可以很快的根据评分（score）或者次序（position）来获<br>取一个范围的元素。</p>
<p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成<br>员的智能列表。</p>
<h4 id="3-6-2-常用命令"><a href="#3-6-2-常用命令" class="headerlink" title="3. 6. 2. 常用命令"></a>3. 6. 2. 常用命令</h4><p>zadd <key>&lt;score 1 &gt;&lt;value 1 &gt;&lt;score 2 &gt;&lt;value 2 &gt;…</key></p>
<p>将一个或多个member元素及其score值加入到有序集key当中。</p>
<p><strong>zrange<key><start><stop></stop>[WITHSCORES]</start></key></strong></p>
<p>返回有序集key中，下标在<start><stop></stop>之间的元素</start></p>
<p>带WITHSCORES，可以让分数一起和值返回到结果集。</p>
<p>zrangebyscorekeyminmax[withscores][limitoffsetcount]</p>
<p>返回有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。<br>有序集成员按score值递增(从小到大)次序排列。</p>
<p>zrevrangebyscorekeymaxmin[withscores][limitoffsetcount]</p>
<p>同上，改为从大到小排列。</p>
<p>zincrby<key><increment><value> 为元素的score加上增量</value></increment></key></p>
<p>zrem <key><value>删除该集合下，指定值的元素</value></key></p>
<p>zcount<key><min><max>统计该集合，分数区间内的元素个数</max></min></key></p>
<p>zrank<key><value>返回该值在集合中的排名，从 0 开始。</value></key></p>
<p>案例：如何利用zset实现一个文章访问量的排行榜？</p>
<h4 id="3-6-3-数据结构"><a href="#3-6-3-数据结构" class="headerlink" title="3. 6. 3. 数据结构"></a>3. 6. 3. 数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于 Java的<br>数据结构Map&lt;String,Double&gt;，可以给每一个元素 value赋予一个权重 score，另一方<br>面它又类似于TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的<br>名次，还可以通过score的范围来获取元素的列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zset底层使用了两个数据结构</span><br></pre></td></tr></table></figure>
<p>（ 1 ）hash，hash的作用就是关联元素 value和权重 score，保障元素 value的唯<br>一性，可以通过元素value找到相应的score值。</p>
<p>（ 2 ）跳跃表，跳跃表的目的在于给元素value 排序，根据score的范围获取元素<br>列表。</p>
<h4 id="3-6-4-跳跃表（跳表）"><a href="#3-6-4-跳跃表（跳表）" class="headerlink" title="3. 6. 4. 跳跃表（跳表）"></a>3. 6. 4. 跳跃表（跳表）</h4><p>1 、简介</p>
<p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名<br>等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、<br>删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis<br>采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p>
<p>2 、实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对比有序链表和跳跃表，从链表中查询出 51</span><br></pre></td></tr></table></figure>
<p>（ 1 ） 有序链表</p>
<p>要查找值为 51 的元素，需要从第一个元素开始依次查找、比较才能找到。共<br>需要 6 次比较。</p>
<p>（ 2 ） 跳跃表</p>
<p>从第 2 层开始， 1 节点比 51 节点小，向后比较。</p>
<p>21 节点比 51 节点小，继续向后比较，后面就是 NULL了，所以从 21 节点向下到<br>第 1 层</p>
<p>在第 1 层， 41 节点比 51 节点小，继续向后， 61 节点比 51 节点大，所以从 41 向<br>下</p>
<p>在第 0 层， 51 节点为要查找的节点，节点被找到，共查找 4 次。</p>
<p>从此可以看出跳跃表比有序链表效率要高</p>
<h2 id="4-Redis-配置文件介绍"><a href="#4-Redis-配置文件介绍" class="headerlink" title="4. Redis 配置文件介绍"></a>4. Redis 配置文件介绍</h2><p>自定义目录：&#x2F;myredis&#x2F;redis.conf</p>
<h4 id="4-1-Units-单位"><a href="#4-1-Units-单位" class="headerlink" title="4. 1 .###Units 单位"></a>4. 1 .###Units 单位</h4><p>配置大小单位,开头定义了一些基本的度量单位，只支持 bytes，不支持bit</p>
<p>大小写不敏感</p>
<h4 id="4-2-INCLUDES-包含"><a href="#4-2-INCLUDES-包含" class="headerlink" title="4. 2 .###INCLUDES 包含"></a>4. 2 .###INCLUDES 包含</h4><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p>
<h4 id="4-3-网络相关配置"><a href="#4-3-网络相关配置" class="headerlink" title="4. 3 .### 网络相关配置"></a>4. 3 .### 网络相关配置</h4><h4 id="4-3-1-b-ind"><a href="#4-3-1-b-ind" class="headerlink" title="4. 3. 1. b ind"></a>4. 3. 1. b ind</h4><p>默认情况bind&#x3D; 127. 0. 0. 1 只能接受本机的访问请求</p>
<p>不写的情况下，无限制接受任何ip地址的访问</p>
<p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注<br>释掉</p>
<p>如果开启了protected-mode，那么在没有设定bindip且没有设密码的情况下，Redis<br>只允许接受本机的响应</p>
<p>保存配置，停止服务，重启启动查看进程，不再是本机访问了。</p>
<h4 id="4-3-2-p-rotected-mode"><a href="#4-3-2-p-rotected-mode" class="headerlink" title="4. 3. 2. p rotected- mode"></a>4. 3. 2. p rotected- mode</h4><p>将本机访问保护模式设置no</p>
<h4 id="4-3-3-P-ort"><a href="#4-3-3-P-ort" class="headerlink" title="4. 3. 3. P ort"></a>4. 3. 3. P ort</h4><p>端口号，默认 6379</p>
<h4 id="4-3-4-t-cp-backlog"><a href="#4-3-4-t-cp-backlog" class="headerlink" title="4. 3. 4. t cp-backlog"></a>4. 3. 4. t cp-backlog</h4><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握<br>手队列+已经完成三次握手队列。</p>
<p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p>
<p>注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值（ 128 ），所以需要<br>确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv 4 &#x2F;tcp_max_syn_backlog（ 128 ）<br>两个值来达到想要的效果</p>
<h4 id="4-3-5-t-imeout"><a href="#4-3-5-t-imeout" class="headerlink" title="4. 3. 5. t imeout"></a>4. 3. 5. t imeout</h4><p>一个空闲的客户端维持多少秒会关闭， 0 表示关闭该功能。即永不关闭。</p>
<h4 id="4-3-6-t-cp-keepalive"><a href="#4-3-6-t-cp-keepalive" class="headerlink" title="4. 3. 6. t cp-keepalive"></a>4. 3. 6. t cp-keepalive</h4><p>对访问客户端的一种心跳检测，每个n秒检测一次。</p>
<p>单位为秒，如果设置为 0 ，则不会进行 Keepalive检测，建议设置成 60</p>
<h4 id="4-4-GENERAL-通用"><a href="#4-4-GENERAL-通用" class="headerlink" title="4. 4 .###GENERAL 通用"></a>4. 4 .###GENERAL 通用</h4><h4 id="4-4-1-daemonize"><a href="#4-4-1-daemonize" class="headerlink" title="4. 4. 1. daemonize"></a>4. 4. 1. daemonize</h4><p>是否为后台进程，设置为yes</p>
<p>守护进程，后台启动</p>
<h4 id="4-4-2-pidfile"><a href="#4-4-2-pidfile" class="headerlink" title="4. 4. 2. pidfile"></a>4. 4. 2. pidfile</h4><p>存放pid文件的位置，每个实例会产生一个不同的 pid文件</p>
<h4 id="4-4-3-loglevel"><a href="#4-4-3-loglevel" class="headerlink" title="4. 4. 3. loglevel"></a>4. 4. 3. loglevel</h4><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默<br>认为 <strong>notice</strong></p>
<p>四个级别根据使用阶段来选择，生产环境选择notice或者warning</p>
<h4 id="4-4-4-logfile"><a href="#4-4-4-logfile" class="headerlink" title="4. 4. 4. logfile"></a>4. 4. 4. logfile</h4><p>日志文件名称</p>
<h4 id="4-4-5-d-atabases-16"><a href="#4-4-5-d-atabases-16" class="headerlink" title="4. 4. 5. d atabases 16"></a>4. 4. 5. d atabases 16</h4><p>设定库的数量默认 16 ，默认数据库为 0 ，可以使用 SELECT<dbid>命令在连接上指<br>定数据库id</dbid></p>
<h4 id="4-5-SECURITY-安全"><a href="#4-5-SECURITY-安全" class="headerlink" title="4. 5 .###SECURITY 安全"></a>4. 5 .###SECURITY 安全</h4><h4 id="4-5-1-设置密码"><a href="#4-5-1-设置密码" class="headerlink" title="4. 5. 1. 设置密码"></a>4. 5. 1. 设置密码</h4><p>访问密码的查看、设置和取消</p>
<p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p>
<p>永久设置，需要再配置文件中进行设置。</p>
<h4 id="4-6-LIMITS-限制"><a href="#4-6-LIMITS-限制" class="headerlink" title="4. 6 .####LIMITS 限制"></a>4. 6 .####LIMITS 限制</h4><h4 id="4-6-1-m-axclients"><a href="#4-6-1-m-axclients" class="headerlink" title="4. 6. 1. m axclients"></a>4. 6. 1. m axclients</h4><p> 设置redis同时可以与多少个客户端进行连接。</p>
<p> 默认情况下为 10000 个客户端。</p>
<p> 如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出<br>“maxnumberofclientsreached”以作回应。</p>
<h4 id="4-6-2-m-axmemory"><a href="#4-6-2-m-axmemory" class="headerlink" title="4. 6. 2. m axmemory"></a>4. 6. 2. m axmemory</h4><p> 建议必须设置，否则，将内存占满，造成服务器宕机</p>
<p> 设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部<br>数据，移除规则可以通过maxmemory-policy来指定。</p>
<p> 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，<br>那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH<br>等。</p>
<p> 但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是<br>主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统<br>中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，<br>才不用考虑这个因素。</p>
<h4 id="4-6-3-m-axmemory-policy"><a href="#4-6-3-m-axmemory-policy" class="headerlink" title="4. 6. 3. m axmemory-policy"></a>4. 6. 3. m axmemory-policy</h4><p> volatile-lru：使用LRU算法移除 key，只对设置了过期时间的键；（最近最少使<br>用）</p>
<p> allkeys-lru：在所有集合key中，使用LRU算法移除 key</p>
<p> volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</p>
<p> allkeys-random：在所有集合key中，移除随机的 key</p>
<p> volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的 key</p>
<p> noeviction：不进行移除。针对写操作，只是返回错误信息</p>
<h4 id="4-6-4-m-axmemory-samples"><a href="#4-6-4-m-axmemory-samples" class="headerlink" title="4. 6. 4. m axmemory-samples"></a>4. 6. 4. m axmemory-samples</h4><p> 设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所<br>以你可以设置样本的大小，redis默认会检查这么多个 key并选择其中LRU的那<br>个。</p>
<p> 一般设置 3 到^7 的数字，数值越小样本越不准确，但性能消耗越小。</p>
<h2 id="5-Redis-的发布和订阅"><a href="#5-Redis-的发布和订阅" class="headerlink" title="5. Redis 的发布和订阅"></a>5. Redis 的发布和订阅</h2><h4 id="5-1-什么是发布和订阅"><a href="#5-1-什么是发布和订阅" class="headerlink" title="5. 1. 什么是发布和订阅"></a>5. 1. 什么是发布和订阅</h4><p>Redis发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者<br>(sub)接收消息。</p>
<p>Redis客户端可以订阅任意数量的频道。</p>
<h4 id="5-2-Redis-的发布和订阅"><a href="#5-2-Redis-的发布和订阅" class="headerlink" title="5. 2 .Redis 的发布和订阅"></a>5. 2 .Redis 的发布和订阅</h4><p>1 、客户端可以订阅频道如下图</p>
<p>2 、当给这个频道发布消息后，消息就会发送给订阅的客户端</p>
<h4 id="5-3-发布订阅命令行实现"><a href="#5-3-发布订阅命令行实现" class="headerlink" title="5. 3. 发布订阅命令行实现"></a>5. 3. 发布订阅命令行实现</h4><p>1 、打开一个客户端订阅channel 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBSCRIBEchannel 1</span><br></pre></td></tr></table></figure>
<p>2 、打开另一个客户端，给channel 1 发布消息hello</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publishchannel 1 hello</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回的 1 是订阅者数量</span><br></pre></td></tr></table></figure>
<p>3 、打开第一个客户端可以看到发送的消息</p>
<p>注：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布<br>的消息</p>
<h2 id="6-Redis-新数据类型"><a href="#6-Redis-新数据类型" class="headerlink" title="6. Redis 新数据类型"></a>6. Redis 新数据类型</h2><h4 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6. 1 .Bitmaps"></a>6. 1 .Bitmaps</h4><h4 id="6-1-1-简介"><a href="#6-1-1-简介" class="headerlink" title="6. 1. 1. 简介"></a>6. 1. 1. 简介</h4><p>现代计算机用二进制（位）作为信息的基础单位， 1 个字节等于 8 位，例如“abc”<br>字符串是由 3 个字节组成，但实际在计算机存储时将其用二进制表示，“abc”分别<br>对应的 ASCII码分别是 97 、 98 、 99 ，对应的二进制分别是 01100001 、 01100010<br>和 01100011 ，如下图</p>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。<br>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：<br>（ 1 ） Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value），<br>但是它可以对字符串的位进行操作。<br>（ 2 ） Bitmaps单独提供了一套命令，所以在 Redis中使用 Bitmaps和使用<br>字符串的方法不太相同。可以把 Bitmaps想象成一个以位为单位的数<br>组，数组的每个单元只能存储 0 和 1 ，数组的下标在Bitmaps中叫做<br>偏移量。</p>
<h4 id="6-1-2-命令"><a href="#6-1-2-命令" class="headerlink" title="6. 1. 2. 命令"></a>6. 1. 2. 命令</h4><p>1 、setbit</p>
<p>（ 1 ）格式<br>setbit<key><offset><value>设置Bitmaps中某个偏移量的值（ 0 或 1 ）</value></offset></key></p>
<p>*offset:偏移量从 0 开始</p>
<p>（ 2 ）实例<br>每个独立用户是否访问过网站存放在Bitmaps中，将访问的用户记做 1 ，没有<br>访问的用户记做 0 ，用偏移量作为用户的id。<br>设置键的第offset个位的值（从 0 算起），假设现在有 20 个用户，userid&#x3D; 1 ，<br>6 ， 11 ， 15 ， 19 的用户对网站进行了访问，那么当前 Bitmaps初始化结果如图</p>
<p>unique:users: 20201106 代表 2020 - 11 - 06 这天的独立访问用户的Bitmaps</p>
<p>注：<br>很多应用的用户 id以一个指定数字（例如 10000 ）开头，直接将用户 id和<br>Bitmaps的偏移量对应势必会造成一定的浪费，通常的做法是每次做setbit操作时将<br>用户id减去这个指定数字。<br>在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会<br>比较慢，可能会造成 Redis的阻塞。</p>
<p>2 、getbit<br>（ 1 ）格式<br>getbit<key><offset>获取Bitmaps中某个偏移量的值</offset></key></p>
<p>获取键的第offset位的值（从 0 开始算）</p>
<p>（ 2 ）实例<br>获取id&#x3D; 8 的用户是否在 2020 - 11 - 06 这天访问过，返回 0 说明没有访问过：</p>
<p>注：因为 100 根本不存在，所以也是返回 0</p>
<p>3 、bitcount<br>统计字符串被设置为 1 的bit数。一般情况下，给定的整个字符串都会被进行计数，<br>通过指定额外的start或end参数，可以让计数只在特定的位上进行。start和end参<br>数的设置，都可以使用负数值：比如- 1 表示最后一个位，而- 2 表示倒数第二个位，<br>start、end是指 bit组的字节的下标数，二者皆包含。</p>
<p>（ 1 ）格式<br>bitcount<key>[startend]统计字符串从 start字节到 end字节比特值为 1 的数量</key></p>
<p>（ 2 ）实例<br>计算 2022 - 11 - 06 这天的独立访问用户数量</p>
<p>start和end代表起始和结束字节数，下面操作计算用户 id在第 1 个字节到第 3 个<br>字节之间的独立访问用户数，对应的用户 id是 11 ， 15 ， 19 。</p>
<p>举例：K 1 【 0100000101000000 0000000000100001 】，对应【 0 ， 1 ， 2 ， 3 】<br>bitcountK 112 ：统计下标 1 、 2 字节组中 bit&#x3D; 1 的个数，即 01000000 00000000</p>
<ul>
<li>-》bitcountK 112 - -》 1</li>
</ul>
<p>bitcountK 113 ：统计下标 1 、 2 字节组中 bit&#x3D; 1 的个数，即 01000000 00000000<br>00100001</p>
<ul>
<li>-》bitcountK 113 - -》 3</li>
</ul>
<p>bitcountK 10 - 2 ： 统计下标 0 到下标倒数第 2 ，字节组中 bit&#x3D; 1 的个数，即<br>01000001 01000000 00000000</p>
<ul>
<li>-》bitcountK 10 - 2 - -》 3</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</span><br></pre></td></tr></table></figure>
<p>4 、bitop<br>( 1 )格式<br>bitop and(or&#x2F;not&#x2F;xor)<destkey>[key…]</destkey></p>
<p>bitop是一个复合操作，它可以做多个Bitmaps的and（交集）、or（并集）、not<br>（非）、xor（异或）操作并将结果保存在destkey中。</p>
<p>( 2 )实例<br>2020 - 11 - 04 日访问网站的 userid&#x3D; 1 , 2 , 5 , 9 。<br>setbitunique:users: 2020110411<br>setbitunique:users: 2020110421<br>setbitunique:users: 2020110451<br>setbitunique:users: 2020110491</p>
<p>2020 - 11 - 03 日访问网站的 userid&#x3D; 0 , 1 , 4 , 9 。<br>setbitunique:users: 2020110301<br>setbitunique:users: 2020110311<br>setbitunique:users: 2020110341<br>setbitunique:users: 2020110391</p>
<p>计算出两天都访问过网站的用户数量<br>bitopandunique:users:and: 20201104 _ 03<br>unique:users: 20201103 unique:users: 20201104</p>
<p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种），可以使用<br>or求并集</p>
<h4 id="6-1-3-Bitmaps-与-set-对比"><a href="#6-1-3-Bitmaps-与-set-对比" class="headerlink" title="6. 1. 3. Bitmaps 与 set 对比"></a>6. 1. 3. Bitmaps 与 set 对比</h4><p>假设网站有 1 亿用户，每天独立访问的用户有 5 千万，如果每天用集合类型和<br>Bitmaps分别存储活跃用户可以得到表</p>
<h4 id="set和Bitmaps存储一天活跃用户对比"><a href="#set和Bitmaps存储一天活跃用户对比" class="headerlink" title="set和Bitmaps存储一天活跃用户对比"></a>set和Bitmaps存储一天活跃用户对比</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据</span><br><span class="line">类型 每个用户id占用空间 需要存储的用户量 全部内存量</span><br><span class="line">集合</span><br><span class="line">类型^64 位^5000000064 位*^50000000 =^400 MB</span><br><span class="line">Bitmaps 1 位 100000000 1 位* 100000000 = 12. 5 MB</span><br></pre></td></tr></table></figure>
<p>很明显，这种情况下使用Bitmaps能节省很多的内存空间，尤其是随着时间推<br>移节省的内存还是非常可观的</p>
<h4 id="set和Bitmaps存储独立用户空间对比"><a href="#set和Bitmaps存储独立用户空间对比" class="headerlink" title="set和Bitmaps存储独立用户空间对比"></a>set和Bitmaps存储独立用户空间对比</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型 一天 一个月 一年</span><br><span class="line">集合类型^400 MB^12 GB^144 GB</span><br><span class="line">Bitmaps 12. 5 MB 375 MB 4. 5 GB</span><br></pre></td></tr></table></figure>
<p>但 Bitmaps并不是万金油，假如该网站每天的独立访问用户很少，例如只有<br>10 万（大量的僵尸用户），那么两者的对比如下表所示，很显然，这时候使用<br>Bitmaps就不太合适了，因为基本上大部分位都是 0 。</p>
<h4 id="set和Bitmaps存储一天活跃用户对比（独立用户比较少）"><a href="#set和Bitmaps存储一天活跃用户对比（独立用户比较少）" class="headerlink" title="set和Bitmaps存储一天活跃用户对比（独立用户比较少）"></a>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类</span><br><span class="line">型 每个userid占用空间 需要存储的用户量 全部内存量</span><br><span class="line">集合类</span><br><span class="line">型^64 位^10000064 位*^100000 =^800 KB</span><br><span class="line">Bitmaps 1 位 100000000 1 位* 100000000 = 12. 5 MB</span><br></pre></td></tr></table></figure>
<h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6. 2 .HyperLogLog"></a>6. 2 .HyperLogLog</h3><h4 id="6-2-1-简介"><a href="#6-2-1-简介" class="headerlink" title="6. 2. 1. 简介"></a>6. 2. 1. 简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站 PV<br>（PageView页面访问量）,可以使用 Redis的 incr、incrby轻松实现。<br>但像UV（UniqueVisitor，独立访客）、独立 IP数、搜索记录数等需要去重和<br>计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。<br>解决基数问题有很多种方案：<br>（ 1 ）数据存储在 MySQL表中，使用distinctcount计算不重复个数</p>
<p>（ 2 ）使用 Redis提供的 hash、set、bitmaps等数据结构来处理<br>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非<br>常大的数据集是不切实际的。<br>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog<br>RedisHyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输<br>入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小<br>的。<br>在Redis里面，每个HyperLogLog键只需要花费 12 KB内存，就可以计算接<br>近 2 ^ 64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成<br>鲜明对比。<br>但是，因为HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素<br>本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数?<br>比如数据集{ 1 , 3 , 5 , 7 , 5 , 7 , 8 }，那么这个数据集的基数集为{ 1 , 3 , 5 , 7 , 8 },<br>基数(不重复元素)为 5 。基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h4 id="6-2-2-命令"><a href="#6-2-2-命令" class="headerlink" title="6. 2. 2. 命令"></a>6. 2. 2. 命令</h4><p>1 、pfadd<br>（ 1 ）格式<br>pfadd<key><element>[element…] 添加指定元素到HyperLogLog中</element></key></p>
<p>（ 2 ）实例</p>
<p>将所有元素添加到指定 HyperLogLog数据结构中。如果执行命令后 HLL估计<br>的近似基数发生变化，则返回 1 ，否则返回 0 。</p>
<p>2 、pfcount<br>（ 1 ）格式<br>pfcount<key>[key…]计算 HLL的近似基数，可以计算多个HLL，比如用 HLL存储<br>每天的UV，计算一周的 UV可以使用 7 天的UV合并计算即可</key></p>
<p>（ 2 ）实例</p>
<p>3 、pfmerge<br>（ 1 ）格式<br>pfmerge<destkey><sourcekey>[sourcekey…] 将一个或多个 HLL合并后的结果存<br>储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</sourcekey></destkey></p>
<p>（ 2 ）实例</p>
<h4 id="6-3-Geospatial"><a href="#6-3-Geospatial" class="headerlink" title="6. 3 .Geospatial"></a>6. 3 .Geospatial</h4><h4 id="6-3-1-简介"><a href="#6-3-1-简介" class="headerlink" title="6. 3. 1. 简介"></a>6. 3. 1. 简介</h4><p>Redis 3. 2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。<br>该类型，就是元素的 2 维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬<br>度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>
<h4 id="6-3-2-命令"><a href="#6-3-2-命令" class="headerlink" title="6. 3. 2. 命令"></a>6. 3. 2. 命令</h4><p>1 、geoadd</p>
<p>（ 1 ）格式<br>geoadd<key><longitude><latitude><member>[longitudelatitudemember…] 添<br>加地理位置（经度，纬度，名称）</member></latitude></longitude></key></p>
<p>（ 2 ）实例<br>geoaddchina:city 121. 4731. 23 shanghai<br>geoadd china:city 106. 50 29. 53 chongqing 114. 05 22. 52 shenzhen 116. 38 39. 90<br>beijing</p>
<p>两极无法直接添加，一般会下载城市数据，直接通过Java程序一次性导入。<br>有效的经度从 - 180 度到 180 度。有效的纬度从 - 85. 05112878 度到<br>85. 05112878 度。<br>当坐标位置超出指定范围时，该命令将会返回一个错误。<br>已经添加的数据，是无法再次往里面添加的。<br>2 、geopos</p>
<p>（ 1 ）格式<br>geopos <key><member>[member…] 获得指定地区的坐标值</member></key></p>
<p>（ 2 ）实例</p>
<p>3 、geodist</p>
<p>（ 1 ）格式<br>geodist<key>&lt;member 1 &gt;&lt;member 2 &gt; [m|km|ft|mi] 获取两个位置之间的直线距<br>离</key></p>
<p>（ 2 ）实例<br>获取两个位置之间的直线距离</p>
<p>单位：<br>m表示单位为米[默认值]。</p>
<p>km表示单位为千米。<br>mi表示单位为英里。<br>ft表示单位为英尺。<br>如果用户没有显式地指定单位参数，那么GEODIST默认使用米作为单位</p>
<p>4 、georadius<br>（ 1 ）格式<br>georadius<key><longitude><latitude>radius m|km|ft|mi 以给定的经纬度为中心，<br>找出某一半径内的元素</latitude></longitude></key></p>
<p>经度纬度距离单位</p>
<p>（ 2 ）实例</p>
<h2 id="7-Redis-Jedis-测试"><a href="#7-Redis-Jedis-测试" class="headerlink" title="7. Redis_Jedis_测试"></a>7. Redis_Jedis_测试</h2><h4 id="7-1-Jedis-所需要的-jar-包"><a href="#7-1-Jedis-所需要的-jar-包" class="headerlink" title="7. 1 .Jedis 所需要的 jar 包"></a>7. 1 .Jedis 所需要的 jar 包</h4><dependency>
<groupId>redis.clients</groupId>
<artifactId>jedis</artifactId>
<version> 3. 2. 0 </version>
</dependency>

<h4 id="7-2-连接-Redis-注意事项"><a href="#7-2-连接-Redis-注意事项" class="headerlink" title="7. 2. 连接 Redis 注意事项"></a>7. 2. 连接 Redis 注意事项</h4><p>禁用Linux的防火墙：Linux(CentOS 7 )里执行命令</p>
<p><strong>systemctlstop&#x2F;disablefirewalld.service</strong></p>
<p>redis.conf中注释掉bind 127. 0. 0. 1 ,然后protected-modeno</p>
<h4 id="7-3-Jedis-常用操作"><a href="#7-3-Jedis-常用操作" class="headerlink" title="7. 3 .Jedis 常用操作"></a>7. 3 .Jedis 常用操作</h4><h4 id="7-3-1-创建动态的工程"><a href="#7-3-1-创建动态的工程" class="headerlink" title="7. 3. 1. 创建动态的工程"></a>7. 3. 1. 创建动态的工程</h4><h4 id="7-3-2-创建测试程序"><a href="#7-3-2-创建测试程序" class="headerlink" title="7. 3. 2. 创建测试程序"></a>7. 3. 2. 创建测试程序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">packagecom.atguigu.jedis;</span><br><span class="line">importredis.clients.jedis.Jedis;</span><br><span class="line">publicclassDemo 01 &#123;</span><br><span class="line">publicstaticvoidmain(String[]args)&#123;</span><br><span class="line">Jedisjedis=newJedis(&quot; 192. 168. 137. 3 &quot;, 6379 );</span><br><span class="line">Stringpong=jedis.ping();</span><br><span class="line">System.out.println(&quot;连接成功：&quot;+pong);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-测试相关数据类型"><a href="#7-4-测试相关数据类型" class="headerlink" title="7. 4. 测试相关数据类型"></a>7. 4. 测试相关数据类型</h4><h4 id="7-4-1-Jedis-API-Key"><a href="#7-4-1-Jedis-API-Key" class="headerlink" title="7. 4. 1. Jedis-API: Key"></a>7. 4. 1. Jedis-API: Key</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. set (&quot;k 1 &quot;,&quot;v 1 &quot;);</span><br><span class="line">jedis.set(&quot;k 2 &quot;,&quot;v 2 &quot;);</span><br><span class="line">jedis.set(&quot;k 3 &quot;,&quot;v 3 &quot;);</span><br><span class="line">Set&lt;String&gt;keys=jedis. keys (&quot;*&quot;);</span><br><span class="line">System.out.println(keys.size());</span><br><span class="line">for(Stringkey:keys)&#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis. exists (&quot;k 1 &quot;));</span><br><span class="line">System.out.println(jedis. ttl (&quot;k 1 &quot;));</span><br><span class="line">System.out.println(jedis. get (&quot;k 1 &quot;));</span><br></pre></td></tr></table></figure>
<h4 id="7-4-2-Jedis-API-String"><a href="#7-4-2-Jedis-API-String" class="headerlink" title="7. 4. 2. Jedis-API: String"></a>7. 4. 2. Jedis-API: String</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. mset (&quot;str 1 &quot;,&quot;v 1 &quot;,&quot;str 2 &quot;,&quot;v 2 &quot;,&quot;str 3 &quot;,&quot;v 3 &quot;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(jedis. mget (&quot;str 1 &quot;,&quot;str 2 &quot;,&quot;str 3 &quot;));</span><br></pre></td></tr></table></figure>
<h4 id="7-4-3-Jedis-API-List"><a href="#7-4-3-Jedis-API-List" class="headerlink" title="7. 4. 3. Jedis-API: List"></a>7. 4. 3. Jedis-API: List</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;list=jedis. lrange (&quot;mylist&quot;, 0 ,- 1 );</span><br><span class="line">for(Stringelement:list)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-4-Jedis-API-set"><a href="#7-4-4-Jedis-API-set" class="headerlink" title="7. 4. 4. Jedis-API: set"></a>7. 4. 4. Jedis-API: set</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 01 &quot;);</span><br><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 02 &quot;);</span><br><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 03 &quot;);</span><br><span class="line">jedis.sadd(&quot;orders&quot;,&quot;order 04 &quot;);</span><br><span class="line">Set&lt;String&gt;smembers=jedis. smembers (&quot;orders&quot;);</span><br><span class="line">for(Stringorder:smembers)&#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis. srem (&quot;orders&quot;,&quot;order 02 &quot;);</span><br></pre></td></tr></table></figure>
<h4 id="7-4-5-Jedis-API-hash"><a href="#7-4-5-Jedis-API-hash" class="headerlink" title="7. 4. 5. Jedis-API: hash"></a>7. 4. 5. Jedis-API: hash</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. hset (&quot;hash 1 &quot;,&quot;userName&quot;,&quot;lisi&quot;);</span><br><span class="line">System.out.println(jedis. hget (&quot;hash 1 &quot;,&quot;userName&quot;));</span><br><span class="line">Map&lt;String,String&gt;map=newHashMap&lt;String,String&gt;();</span><br><span class="line">map.put(&quot;telphone&quot;,&quot; 13810169999 &quot;);</span><br><span class="line">map.put(&quot;address&quot;,&quot;atguigu&quot;);</span><br><span class="line">map.put(&quot;email&quot;,&quot;abc@ 163 .com&quot;);</span><br><span class="line">jedis. hmset (&quot;hash 2 &quot;,map);</span><br><span class="line">List&lt;String&gt;result=jedis. hmget (&quot;hash 2 &quot;,&quot;telphone&quot;,&quot;email&quot;);</span><br><span class="line">for(Stringelement:result)&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-4-6-Jedis-API-zset"><a href="#7-4-6-Jedis-API-zset" class="headerlink" title="7. 4. 6. Jedis-API: zset"></a>7. 4. 6. Jedis-API: zset</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis. zadd (&quot;zset 01 &quot;, 100 d,&quot;z 3 &quot;);</span><br><span class="line">jedis.zadd(&quot;zset 01 &quot;, 90 d,&quot;l 4 &quot;);</span><br><span class="line">jedis.zadd(&quot;zset 01 &quot;, 80 d,&quot;w 5 &quot;);</span><br><span class="line">jedis.zadd(&quot;zset 01 &quot;, 70 d,&quot;z 6 &quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt;zrange=jedis. zrange (&quot;zset 01 &quot;, 0 ,- 1 );</span><br><span class="line">for(Stringe:zrange)&#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-Redis-Jedis-实例"><a href="#8-Redis-Jedis-实例" class="headerlink" title="8. Redis_Jedis_实例"></a>8. Redis_Jedis_实例</h2><h4 id="8-1-完成一个手机验证码功能"><a href="#8-1-完成一个手机验证码功能" class="headerlink" title="8. 1. 完成一个手机验证码功能"></a>8. 1. 完成一个手机验证码功能</h4><p>要求：</p>
<p>1 、输入手机号，点击发送后随机生成 6 位数字码， 2 分钟有效</p>
<p>2 、输入验证码，点击验证，返回成功或失败</p>
<p>3 、每个手机号每天只能输入 3 次</p>
<h2 id="9-Redis-与-SpringBoot-整合"><a href="#9-Redis-与-SpringBoot-整合" class="headerlink" title="9. Redis 与 SpringBoot 整合"></a>9. Redis 与 SpringBoot 整合</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SpringBoot整合 Redis 非常简单，只需要按如下步骤整合即可</span><br></pre></td></tr></table></figure>
<h4 id="9-1-整合步骤"><a href="#9-1-整合步骤" class="headerlink" title="9. 1. 整合步骤"></a>9. 1. 整合步骤</h4><p>1 、在 pom.xml文件中引入 redis相关依赖</p>
<!--redis-->

<p>&lt; **dependency** &gt;</p>
<p>&lt; **groupId** &gt;org.springframework.boot&lt;&#x2F; **groupId** &gt;</p>
<p>&lt; **artifactId** &gt;spring-boot-starter-data-redis&lt;&#x2F; **artifactId** &gt;</p>
<p>&lt;&#x2F; **dependency** &gt;</p>
<!--spring 2 .X集成redis所需common-pool 2 - ->

< **dependency** >

< **groupId** >org.apache.commons</ **groupId** >

< **artifactId** >commons-pool 2 </ **artifactId** >

< **version** > 2. 6. 0 </ **version** >

</ **dependency** >

2 、application.properties配置redis配置

#Redis服务器地址

**spring.redis.host** = **192. 168. 140. 136**

#Redis服务器连接端口

**spring.redis.port** = **6379**

#Redis数据库索引（默认为 0 ）

**spring.redis.database** = **0**

#连接超时时间（毫秒）

**spring.redis.timeout** = **1800000**

#连接池最大连接数（使用负值表示没有限制）

**spring.redis.lettuce.pool.max-active** = **20**

#最大阻塞等待时间(负数表示没限制)

**spring.redis.lettuce.pool.max-wait** = **- 1**

#连接池中的最大空闲连接

**spring.redis.lettuce.pool.max-idle** = **5**


#连接池中的最小空闲连接

**spring.redis.lettuce.pool.min-idle** = **0**

3 、添加redis配置类

@EnableCaching
@Configuration
publicclassRedisConfigextendsCachingConfigurerSupport{

@Bean
publicRedisTemplate<String,Object>redisTemplate(RedisConnectionFactoryfactory){
RedisTemplate<String,Object>template=newRedisTemplate<>();
RedisSerializer<String>redisSerializer=newStringRedisSerializer();
Jackson 2 JsonRedisSerializerjackson 2 JsonRedisSerializer=new
Jackson 2 JsonRedisSerializer(Object.class);
ObjectMapperom=newObjectMapper();
om.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);
om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
jackson 2 JsonRedisSerializer.setObjectMapper(om);
template.setConnectionFactory(factory);
//key序列化方式
template.setKeySerializer(redisSerializer);
//value序列化
template.setValueSerializer(jackson 2 JsonRedisSerializer);
//valuehashmap序列化
template.setHashValueSerializer(jackson 2 JsonRedisSerializer);
returntemplate;
}

@Bean
publicCacheManagercacheManager(RedisConnectionFactoryfactory){
RedisSerializer<String>redisSerializer=newStringRedisSerializer();
Jackson 2 JsonRedisSerializerjackson 2 JsonRedisSerializer=new
Jackson 2 JsonRedisSerializer(Object.class);
//解决查询缓存转换异常的问题
ObjectMapperom=newObjectMapper();
om.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);
om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
jackson 2 JsonRedisSerializer.setObjectMapper(om);
//配置序列化（解决乱码的问题）,过期时间 600 秒
RedisCacheConfigurationconfig=RedisCacheConfiguration.defaultCacheConfig()
.entryTtl(Duration.ofSeconds( 600 ))
.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializ
er))
.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson 2 Js
onRedisSerializer))
.disableCachingNullValues();


RedisCacheManagercacheManager=RedisCacheManager.builder(factory)
.cacheDefaults(config)
.build();
returncacheManager;
}
}

4 、测试一下
RedisTestController中添加测试方法

@RestController
@RequestMapping("/redisTest")
publicclassRedisTestController{
@Autowired
privateRedisTemplateredisTemplate;

@GetMapping
publicStringtestRedis(){
//设置值到 redis
redisTemplate.opsForValue().set("name","lucy");
//从 redis获取值
Stringname=(String)redisTemplate.opsForValue().get("name");
returnname;
}
}

## 10. Redis_事务 _ 锁机制 _ 秒杀

#### 10. 1 .Redis 的事务定义

Redis事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事
务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

Redis事务的主要作用就是串联多个命令防止别的命令插队。

#### 10. 2 .Multi 、 Exec 、 discard

从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输
入Exec后，Redis会将之前的命令队列中的命令依次执行。

组队的过程中可以通过discard来放弃组队。


案例：

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组队成功，提交成功</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组队阶段报错，提交失败</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组队成功，提交有成功有失败情况</span><br></pre></td></tr></table></figure>
<h4 id="10-3-事务的错误处理"><a href="#10-3-事务的错误处理" class="headerlink" title="10. 3. 事务的错误处理"></a>10. 3. 事务的错误处理</h4><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p>
<p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都<br>会执行，不会回滚。</p>
<h4 id="10-4-为什么要做成事务"><a href="#10-4-为什么要做成事务" class="headerlink" title="10. 4. 为什么要做成事务"></a>10. 4. 为什么要做成事务</h4><p>想想一个场景：有很多人有你的账户,同时去参加双十一抢购</p>
<h4 id="10-5-事务冲突的问题"><a href="#10-5-事务冲突的问题" class="headerlink" title="10. 5. 事务冲突的问题"></a>10. 5. 事务冲突的问题</h4><h4 id="10-5-1-例子"><a href="#10-5-1-例子" class="headerlink" title="10. 5. 1. 例子"></a>10. 5. 1. 例子</h4><p>一个请求想给金额减 8000</p>
<p>一个请求想给金额减 5000</p>
<p>一个请求想给金额减 1000</p>
<h4 id="10-5-2-悲观锁"><a href="#10-5-2-悲观锁" class="headerlink" title="10. 5. 2. 悲观锁"></a>10. 5. 2. 悲观锁</h4><p>悲观锁 <strong>(PessimisticLock)</strong> ,顾名思义，就是很悲观，每次去拿数据的时候都认为别人会<br>修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它<br>拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读<br>锁，写锁等，都是在做操作之前先上锁。</p>
<h4 id="10-5-3-乐观锁"><a href="#10-5-3-乐观锁" class="headerlink" title="10. 5. 3. 乐观锁"></a>10. 5. 3. 乐观锁</h4><p>乐观锁 <strong>(OptimisticLock),</strong> 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不<br>会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这<br>个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐<br>量。Redis就是利用这种 check-and-set机制实现事务的。</p>
<h4 id="10-5-4-WATCHkey-key…"><a href="#10-5-4-WATCHkey-key…" class="headerlink" title="10. 5. 4. WATCHkey[key…]"></a>10. 5. 4. WATCHkey[key…]</h4><p>在执行multi之前，先执行watchkey 1 [key 2 ],可以监视一个(或多个)key，如果在事务<br>执行之前这个 <strong>(</strong> 或这些 <strong>)key</strong> 被其他命令所改动，那么事务将被打断。</p>
<h4 id="10-5-5-unwatch"><a href="#10-5-5-unwatch" class="headerlink" title="10. 5. 5. unwatch"></a>10. 5. 5. unwatch</h4><p>取消WATCH命令对所有key的监视。</p>
<p>如果在执行WATCH命令之后，EXEC命令或DISCARD命令先被执行了的话，那么就<br>不需要再执行UNWATCH了。</p>
<p><a target="_blank" rel="noopener" href="http://doc.redisfans.com/transaction/exec.html">http://doc.redisfans.com/transaction/exec.html</a></p>
<h4 id="10-6-Redis-事务三特性"><a href="#10-6-Redis-事务三特性" class="headerlink" title="10. 6 .Redis 事务三特性"></a>10. 6 .Redis 事务三特性</h4><p> 单独的隔离操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会</span><br><span class="line">被其他客户端发送来的命令请求所打断。</span><br></pre></td></tr></table></figure>
<p> 没有隔离级别的概念</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都</span><br><span class="line">不会被实际执行</span><br></pre></td></tr></table></figure>
<p> 不保证原子性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</span><br></pre></td></tr></table></figure>
<h2 id="11-Redis-事务-秒杀案例"><a href="#11-Redis-事务-秒杀案例" class="headerlink" title="11. Redis_事务 _ 秒杀案例"></a>11. Redis_事务 _ 秒杀案例</h2><h4 id="11-1-解决计数器和人员记录的事务操作"><a href="#11-1-解决计数器和人员记录的事务操作" class="headerlink" title="11. 1. 解决计数器和人员记录的事务操作"></a>11. 1. 解决计数器和人员记录的事务操作</h4><h4 id="11-2-Redis-事务-秒杀并发模拟"><a href="#11-2-Redis-事务-秒杀并发模拟" class="headerlink" title="11. 2 .Redis 事务 - - 秒杀并发模拟"></a>11. 2 .Redis 事务 - - 秒杀并发模拟</h4><p>使用工具ab模拟测试</p>
<p>CentOS 6 默认安装</p>
<p>CentOS 7 需要手动安装</p>
<h4 id="11-2-1-联网：yuminstallhttpd-tools"><a href="#11-2-1-联网：yuminstallhttpd-tools" class="headerlink" title="11. 2. 1. 联网：yuminstallhttpd-tools"></a>11. 2. 1. 联网：yuminstallhttpd-tools</h4><h4 id="11-2-2-无网络"><a href="#11-2-2-无网络" class="headerlink" title="11. 2. 2. 无网络"></a>11. 2. 2. 无网络</h4><p>（ 1 ）进入 cd &#x2F;run&#x2F;media&#x2F;root&#x2F;CentOS 7 x 86 _ 64 &#x2F;Packages（路径跟centos 6 不同）</p>
<p>（ 2 ）顺序安装</p>
<p>apr- 1. 4. 8 - 3 .el 7 .x 86 _ 64 .rpm</p>
<p>apr-util- 1. 5. 2 - 6 .el 7 .x 86 _ 64 .rpm</p>
<p>httpd-tools- 2. 4. 6 - 67 .el 7 .centos.x 86 _ 64 .rpm</p>
<h4 id="11-2-3-测试及结果"><a href="#11-2-3-测试及结果" class="headerlink" title="11. 2. 3. 测试及结果"></a>11. 2. 3. 测试及结果</h4><h5 id="11-2-3-1-通过-ab-测试"><a href="#11-2-3-1-通过-ab-测试" class="headerlink" title="11. 2. 3. 1. 通过 ab 测试"></a>11. 2. 3. 1. 通过 ab 测试</h5><p>vimpostfile模拟表单提交参数,以&amp;符号结尾;存放当前目录。</p>
<p>内容：prodid&#x3D; 0101 &amp;</p>
<p>ab-n 2000 - c 200 - k-p~&#x2F;postfile-Tapplication&#x2F;x-www-form-urlencoded<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 2. 115 : 8081 &#x2F;Seckill&#x2F;doseckill</p>
<h5 id="11-2-3-2-超卖"><a href="#11-2-3-2-超卖" class="headerlink" title="11. 2. 3. 2. 超卖"></a>11. 2. 3. 2. 超卖</h5><h4 id="11-3-超卖问题"><a href="#11-3-超卖问题" class="headerlink" title="11. 3. 超卖问题"></a>11. 3. 超卖问题</h4><h4 id="11-4-利用乐观锁淘汰用户，解决超卖问题。"><a href="#11-4-利用乐观锁淘汰用户，解决超卖问题。" class="headerlink" title="11. 4. 利用乐观锁淘汰用户，解决超卖问题。"></a>11. 4. 利用乐观锁淘汰用户，解决超卖问题。</h4><p>&#x2F;&#x2F;增加乐观锁</p>
<p>jedis.watch(qtkey);</p>
<p>&#x2F;&#x2F; 3 .判断库存</p>
<p>Stringqtkeystr&#x3D;jedis.get(qtkey);</p>
<p>if(qtkeystr&#x3D;&#x3D;null||<br>“”.equals(qtkeystr.trim())){</p>
<p>System.out.println(“未初始化库存”);</p>
<p>jedis.close();</p>
<p>returnfalse;</p>
<p>}</p>
<p>intqt&#x3D;Integer.parseInt(qtkeystr);</p>
<p>if(qt&lt;&#x3D; 0 ){</p>
<p>System.err.println(“已经秒光”);</p>
<p>jedis.close();</p>
<p>returnfalse;</p>
<p>}</p>
<p>&#x2F;&#x2F;增加事务</p>
<p>Transaction <strong>multi</strong> &#x3D;jedis.multi();</p>
<p>&#x2F;&#x2F; 4 .减少库存</p>
<p>&#x2F;&#x2F;jedis.decr(qtkey);</p>
<p><strong>multi</strong> .decr(qtkey);</p>
<p>&#x2F;&#x2F; 5 .加人</p>
<p>&#x2F;&#x2F;jedis.sadd(usrkey,uid);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">multi .sadd(usrkey,uid);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//执行事务</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt;list= multi .exec();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//判断事务提交是否失败</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(list==null||list.size()== 0 )&#123;</span><br><span class="line">System.out.println(&quot;秒杀失败&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br><span class="line">returnfalse;</span><br><span class="line">&#125;</span><br><span class="line">System.err.print ln(&quot; 秒杀成功&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>
<h4 id="11-5-继续增加并发测试"><a href="#11-5-继续增加并发测试" class="headerlink" title="11. 5. 继续增加并发测试"></a>11. 5. 继续增加并发测试</h4><h4 id="11-5-1-连接有限制"><a href="#11-5-1-连接有限制" class="headerlink" title="11. 5. 1. 连接有限制"></a>11. 5. 1. 连接有限制</h4><p>ab-n 2000 - c 200 - k-ppostfile-T’application&#x2F;x-www-form-urlencoded’<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 140. 1 : 8080 &#x2F;seckill&#x2F;doseckill</p>
<p>增加-r参数，-r Don’texitonsocketreceiveerrors.</p>
<p>ab-n 2000 - c 100 - r-ppostfile-T’application&#x2F;x-www-form-urlencoded’<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 140. 1 : 8080 &#x2F;seckill&#x2F;doseckill</p>
<h4 id="11-5-2-已经秒光，可是还有库存"><a href="#11-5-2-已经秒光，可是还有库存" class="headerlink" title="11. 5. 2. 已经秒光，可是还有库存"></a>11. 5. 2. 已经秒光，可是还有库存</h4><p>ab-n 2000 - c 100 - ppostfile-T’application&#x2F;x-www-form-urlencoded’<br><a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 137. 1 : 8080 &#x2F;seckill&#x2F;doseckill</p>
<p>已经秒光，可是还有库存。原因，就是乐观锁导致很多请求都失败。先点的没秒到，后点<br>的可能秒到了。</p>
<h4 id="11-5-3-连接超时，通过连接池解决"><a href="#11-5-3-连接超时，通过连接池解决" class="headerlink" title="11. 5. 3. 连接超时，通过连接池解决"></a>11. 5. 3. 连接超时，通过连接池解决</h4><h4 id="11-5-4-连接池"><a href="#11-5-4-连接池" class="headerlink" title="11. 5. 4. 连接池"></a>11. 5. 4. 连接池</h4><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</p>
<p>通过参数管理连接的行为</p>
<p>代码见项目中</p>
<p> 链接池参数<br> MaxTotal：控制一个pool可分配多少个 jedis实例，通过pool.getResource()<br>来获取；如果赋值为- 1 ，则表示不限制；如果 pool已经分配了 MaxTotal个<br>jedis实例，则此时pool的状态为 exhausted。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> maxIdle：控制一个pool最多有多少个状态为idle(空闲)的 jedis实例；</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等</span><br><span class="line">待时间，则直接抛JedisConnectionException；</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；</span><br><span class="line">如果为true，则得到的 jedis实例均是可用的；</span><br></pre></td></tr></table></figure>
<h4 id="11-6-解决库存遗留问题"><a href="#11-6-解决库存遗留问题" class="headerlink" title="11. 6. 解决库存遗留问题"></a>11. 6. 解决库存遗留问题</h4><h4 id="11-6-1-LUA-脚本"><a href="#11-6-1-LUA-脚本" class="headerlink" title="11. 6. 1. LUA 脚本"></a>11. 6. 1. LUA 脚本</h4><p>Lua是一个小巧的脚本语言，Lua脚本可以很容易的被C&#x2F;C++代码调用，也可以反过<br>来调用C&#x2F;C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过 200 k，<br>所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。</p>
<p>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可<br>扩展性。</p>
<p>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p>
<p><a target="_blank" rel="noopener" href="https://www.w/">https://www.w</a> 3 cschool.cn&#x2F;lua&#x2F;</p>
<h4 id="11-6-2-LUA-脚本在-Redis-中的优势"><a href="#11-6-2-LUA-脚本在-Redis-中的优势" class="headerlink" title="11. 6. 2. LUA 脚本在 Redis 中的优势"></a>11. 6. 2. LUA 脚本在 Redis 中的优势</h4><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连<br>接redis的次数。提升性能。</p>
<p>LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些<br>redis事务性的操作。</p>
<p>但是注意redis的lua脚本功能，只有在 Redis 2. 6 以上的版本才可以使用。</p>
<p>利用lua脚本淘汰用户，解决超卖问题。</p>
<p>redis 2. 6 版本以后，通过 lua脚本解决争抢问题，实际上是 <strong>redis</strong> 利用其单线程的特<br>性，用任务队列的方式解决多任务并发问题。</p>
<h4 id="11-7-Redis-事务-秒杀案例-代码"><a href="#11-7-Redis-事务-秒杀案例-代码" class="headerlink" title="11. 7. Redis_事务_秒杀案例_代码"></a>11. 7. Redis_事务_秒杀案例_代码</h4><h4 id="11-7-1-项目结构"><a href="#11-7-1-项目结构" class="headerlink" title="11. 7. 1. 项目结构"></a>11. 7. 1. 项目结构</h4><h4 id="11-7-2-第一版：简单版"><a href="#11-7-2-第一版：简单版" class="headerlink" title="11. 7. 2. 第一版：简单版"></a>11. 7. 2. 第一版：简单版</h4><p>老师点 10 次，正常秒杀</p>
<p>同学一起点试一试，秒杀也是正常的。这是因为还达不到并发的效果。</p>
<p>使用工具ab模拟并发测试，会出现超卖情况。查看库存会出现负数。</p>
<h4 id="11-7-3-第二版：加事务-乐观锁-解决超卖-但出现遗留库"><a href="#11-7-3-第二版：加事务-乐观锁-解决超卖-但出现遗留库" class="headerlink" title="11. 7. 3. 第二版：加事务-乐观锁(解决超卖),但出现遗留库"></a>11. 7. 3. 第二版：加事务-乐观锁(解决超卖),但出现遗留库</h4><h4 id="存和连接超时"><a href="#存和连接超时" class="headerlink" title="存和连接超时"></a>存和连接超时</h4><h4 id="11-7-4-第三版：连接池解决超时问题"><a href="#11-7-4-第三版：连接池解决超时问题" class="headerlink" title="11. 7. 4. 第三版：连接池解决超时问题"></a>11. 7. 4. 第三版：连接池解决超时问题</h4><h4 id="11-7-5-第四版：解决库存依赖问题，LUA-脚本"><a href="#11-7-5-第四版：解决库存依赖问题，LUA-脚本" class="headerlink" title="11. 7. 5. 第四版：解决库存依赖问题，LUA 脚本"></a>11. 7. 5. 第四版：解决库存依赖问题，LUA 脚本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localuserid=KEYS[ 1 ];</span><br><span class="line">localprodid=KEYS[ 2 ];</span><br><span class="line">localqtkey=&quot;sk:&quot;..prodid..&quot;:qt&quot;;</span><br><span class="line">localusersKey=&quot;sk:&quot;..prodid.&quot;:usr&#x27;;</span><br><span class="line">localuserExists=redis.call(&quot;sismember&quot;,usersKey,userid);</span><br><span class="line">iftonumber(userExists)== 1 then</span><br><span class="line">return 2 ;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">end</span><br><span class="line">localnum=redis.call(&quot;get&quot;,qtkey);</span><br><span class="line">iftonumber(num)&lt;= 0 then</span><br><span class="line">return 0 ;</span><br><span class="line">else</span><br><span class="line">redis.call(&quot;decr&quot;,qtkey);</span><br><span class="line">redis.call(&quot;sadd&quot;,usersKey,userid);</span><br><span class="line">end</span><br><span class="line">return 1 ;</span><br></pre></td></tr></table></figure>
<h2 id="12-Redis-持久化之-RDB"><a href="#12-Redis-持久化之-RDB" class="headerlink" title="12. Redis 持久化之 RDB"></a>12. Redis 持久化之 RDB</h2><h4 id="12-1-总体介绍"><a href="#12-1-总体介绍" class="headerlink" title="12. 1. 总体介绍"></a>12. 1. 总体介绍</h4><p>官网介绍：<a target="_blank" rel="noopener" href="http://www.redis.io/">http://www.redis.io</a></p>
<p>Redis提供了 2 个不同形式的持久化方式。</p>
<p> RDB（RedisDataBase）</p>
<p> AOF（AppendOfFile）</p>
<h4 id="12-2-RDB-（-RedisDataBase-）"><a href="#12-2-RDB-（-RedisDataBase-）" class="headerlink" title="12. 2 .RDB （ RedisDataBase ）"></a>12. 2 .RDB （ RedisDataBase ）</h4><h4 id="12-2-1-官网介绍"><a href="#12-2-1-官网介绍" class="headerlink" title="12. 2. 1. 官网介绍"></a>12. 2. 1. 官网介绍</h4><h4 id="12-2-2-是什么"><a href="#12-2-2-是什么" class="headerlink" title="12. 2. 2. 是什么"></a>12. 2. 2. 是什么</h4><p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的 Snapshot快<br>照，它恢复时是将快照文件直接读到内存里</p>
<h4 id="12-2-3-备份是如何执行的"><a href="#12-2-3-备份是如何执行的" class="headerlink" title="12. 2. 3. 备份是如何执行的"></a>12. 2. 3. 备份是如何执行的</h4><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件<br>中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程<br>中，主进程是不进行任何IO操作的，这就确保了极高的性能如果需要进行大规模数<br>据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比 AOF方式更加<br>的高效。 <strong>RDB</strong> 的缺点是最后一次持久化后的数据可能丢失。</p>
<h4 id="12-2-4-Fork"><a href="#12-2-4-Fork" class="headerlink" title="12. 2. 4. Fork"></a>12. 2. 4. Fork</h4><p> Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、<br>程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进<br>程</p>
<p> 在 Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多<br>会exec系统调用，出于效率考虑，Linux中引入了“写时复制技术”</p>
<p> 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要<br>发生变化时，才会将父进程的内容复制一份给子进程。</p>
<h4 id="12-2-5-RDB-持久化流程"><a href="#12-2-5-RDB-持久化流程" class="headerlink" title="12. 2. 5. RDB 持久化流程"></a>12. 2. 5. RDB 持久化流程</h4><h4 id="12-2-6-dump-rdb-文件"><a href="#12-2-6-dump-rdb-文件" class="headerlink" title="12. 2. 6. dump.rdb 文件"></a>12. 2. 6. dump.rdb 文件</h4><p>在redis.conf中配置文件名称，默认为dump.rdb</p>
<h4 id="12-2-7-配置位置"><a href="#12-2-7-配置位置" class="headerlink" title="12. 2. 7. 配置位置"></a>12. 2. 7. 配置位置</h4><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p>
<p>dir”&#x2F;myredis&#x2F;“</p>
<h4 id="12-2-8-如何触发-RDB-快照；保持策略"><a href="#12-2-8-如何触发-RDB-快照；保持策略" class="headerlink" title="12. 2. 8. 如何触发 RDB 快照；保持策略"></a>12. 2. 8. 如何触发 RDB 快照；保持策略</h4><h5 id="12-2-8-1-配置文件中默认的快照配置"><a href="#12-2-8-1-配置文件中默认的快照配置" class="headerlink" title="12. 2. 8. 1. 配置文件中默认的快照配置"></a>12. 2. 8. 1. 配置文件中默认的快照配置</h5><h5 id="12-2-8-2-命令-saveVSbgsave"><a href="#12-2-8-2-命令-saveVSbgsave" class="headerlink" title="12. 2. 8. 2. 命令 saveVSbgsave"></a>12. 2. 8. 2. 命令 saveVSbgsave</h5><p>save：save时只管保存，其它不管，全部阻塞。手动保存。不建议。</p>
<p><strong>bgsave</strong> ： <strong>Redis</strong> 会在后台异步进行快照操作，快照同时还可以响应客户端请求。</p>
<p>可以通过lastsave命令获取最后一次成功执行快照的时间</p>
<h5 id="12-2-8-3-flushall-命令"><a href="#12-2-8-3-flushall-命令" class="headerlink" title="12. 2. 8. 3. flushall 命令"></a>12. 2. 8. 3. flushall 命令</h5><p>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</p>
<h5 id="12-2-8-4-SNAPSHOTTING-快照"><a href="#12-2-8-4-SNAPSHOTTING-快照" class="headerlink" title="12. 2. 8. 4. ###SNAPSHOTTING 快照"></a>12. 2. 8. 4. ###SNAPSHOTTING 快照</h5><h5 id="12-2-8-5-Save"><a href="#12-2-8-5-Save" class="headerlink" title="12. 2. 8. 5. Save"></a>12. 2. 8. 5. Save</h5><p>格式：save秒钟写操作次数</p>
<p>RDB是整个内存的压缩过的 Snapshot，RDB的数据结构，可以配置复合的快照触发条<br>件，</p>
<p>默认是 <strong>1</strong> 分钟内改了 <strong>1</strong> 万次，或 <strong>5</strong> 分钟内改了 <strong>10</strong> 次，或 <strong>15</strong> 分钟内改了 <strong>1</strong> 次。</p>
<p>禁用</p>
<p>不设置save指令，或者给save传入空字符串</p>
<h5 id="12-2-8-6-stop-writes-on-bgsave-error"><a href="#12-2-8-6-stop-writes-on-bgsave-error" class="headerlink" title="12. 2. 8. 6. stop-writes-on-bgsave-error"></a>12. 2. 8. 6. stop-writes-on-bgsave-error</h5><p>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</p>
<h5 id="12-2-8-7-rdbcompression-压缩文件"><a href="#12-2-8-7-rdbcompression-压缩文件" class="headerlink" title="12. 2. 8. 7. rdbcompression 压缩文件"></a>12. 2. 8. 7. rdbcompression 压缩文件</h5><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用<br>LZF算法进行压缩。</p>
<p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。推荐yes.</p>
<h5 id="12-2-8-8-rdbchecksum-检查完整性"><a href="#12-2-8-8-rdbchecksum-检查完整性" class="headerlink" title="12. 2. 8. 8. rdbchecksum 检查完整性"></a>12. 2. 8. 8. rdbchecksum 检查完整性</h5><p>在存储快照后，还可以让redis使用 CRC 64 算法来进行数据校验，</p>
<p>但是这样做会增加大约 10 %的性能消耗，如果希望获取到最大的性能提升，可以关<br>闭此功能</p>
<p>推荐yes.</p>
<h5 id="12-2-8-9-rdb-的备份"><a href="#12-2-8-9-rdb-的备份" class="headerlink" title="12. 2. 8. 9. rdb 的备份"></a>12. 2. 8. 9. rdb 的备份</h5><p>先通过configgetdir 查询 rdb文件的目录</p>
<p>将*.rdb的文件拷贝到别的地方</p>
<p>rdb的恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 关闭Redis</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 先把备份的文件拷贝到工作目录下cpdump 2 .rdbdump.rdb</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 启动Redis,备份数据会直接加载</span><br></pre></td></tr></table></figure>
<h4 id="12-2-9-优势"><a href="#12-2-9-优势" class="headerlink" title="12. 2. 9. 优势"></a>12. 2. 9. 优势</h4><p> 适合大规模的数据恢复</p>
<p> 对数据完整性和一致性要求不高更适合使用</p>
<p> 节省磁盘空间</p>
<p> 恢复速度快</p>
<h4 id="12-2-10-劣势"><a href="#12-2-10-劣势" class="headerlink" title="12. 2. 10. 劣势"></a>12. 2. 10. 劣势</h4><p> Fork的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑</p>
<p> 虽然 Redis在 fork时使用了写时拷贝技术,但是如果数据庞大时还是比较消</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">耗性能。</span><br></pre></td></tr></table></figure>
<p> 在备份周期在一定间隔时间做一次备份，所以如果 Redis意外 down掉的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">话，就会丢失最后一次快照后的所有修改。</span><br></pre></td></tr></table></figure>
<h4 id="12-2-11-如何停止"><a href="#12-2-11-如何停止" class="headerlink" title="12. 2. 11. 如何停止"></a>12. 2. 11. 如何停止</h4><p>动态停止RDB：redis-cliconfigsetsave””#save后给空值，表示禁用保存策略</p>
<h4 id="12-2-12-小总结"><a href="#12-2-12-小总结" class="headerlink" title="12. 2. 12. 小总结"></a>12. 2. 12. 小总结</h4><h2 id="13-Redis-持久化之-AOF"><a href="#13-Redis-持久化之-AOF" class="headerlink" title="13. Redis 持久化之 AOF"></a>13. Redis 持久化之 AOF</h2><h4 id="13-1-AOF-（-AppendOnlyFile-）"><a href="#13-1-AOF-（-AppendOnlyFile-）" class="headerlink" title="13. 1 .AOF （ AppendOnlyFile ）"></a>13. 1 .AOF （ AppendOnlyFile ）</h4><h4 id="13-1-1-是什么"><a href="#13-1-1-是什么" class="headerlink" title="13. 1. 1. 是什么"></a>13. 1. 1. 是什么</h4><p>以日志的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下<br>来(读操作不记录)，只许追加文件但不可以改写文件，redis启动之初会读取该文件重<br>新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一<br>次以完成数据的恢复工作</p>
<h4 id="13-1-2-AOF-持久化流程"><a href="#13-1-2-AOF-持久化流程" class="headerlink" title="13. 1. 2. AOF 持久化流程"></a>13. 1. 2. AOF 持久化流程</h4><p>（ 1 ）客户端的请求写命令会被append追加到AOF缓冲区内；</p>
<p>（ 2 ）AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘<br>的AOF文件中；</p>
<p>（ 3 ）AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩<br>AOF文件容量；</p>
<p>（ 4 ）Redis服务重启时，会重新 load加载AOF文件中的写操作达到数据恢复的目的；</p>
<h4 id="13-1-3-AOF-默认不开启"><a href="#13-1-3-AOF-默认不开启" class="headerlink" title="13. 1. 3. AOF 默认不开启"></a>13. 1. 3. AOF 默认不开启</h4><p>可以在redis.conf中配置文件名称，默认为appendonly.aof</p>
<p>AOF文件的保存路径，同RDB的路径一致。</p>
<h4 id="13-1-4-AOF-和-RDB-同时开启，-redis-听谁的？"><a href="#13-1-4-AOF-和-RDB-同时开启，-redis-听谁的？" class="headerlink" title="13. 1. 4. AOF 和 RDB 同时开启， redis 听谁的？"></a>13. 1. 4. AOF 和 RDB 同时开启， redis 听谁的？</h4><p>AOF和RDB同时开启，系统默认取 AOF的数据（数据不会存在丢失）</p>
<h4 id="13-1-5-AOF-启动-修复-恢复"><a href="#13-1-5-AOF-启动-修复-恢复" class="headerlink" title="13. 1. 5. AOF 启动 &#x2F; 修复 &#x2F; 恢复"></a>13. 1. 5. AOF 启动 &#x2F; 修复 &#x2F; 恢复</h4><p> AOF的备份机制和性能虽然和RDB不同,但是备份和恢复的操作同 RDB一样，<br>都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p>
<p> 正常恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 修改默认的appendonlyno，改为yes</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 将有数据的aof文件复制一份保存到对应目录(查看目录：configgetdir)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 恢复：重启redis然后重新加载</span><br></pre></td></tr></table></figure>

<p> 异常恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 修改默认的appendonlyno，改为yes</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 如遇到 AOF 文件损坏，通过/usr/local/bin/ redis-check-aof--fix</span><br><span class="line">appendonly.aof 进行恢复</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 备份被写坏的AOF文件</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 恢复：重启redis，然后重新加载</span><br></pre></td></tr></table></figure>
<h4 id="13-1-6-AOF-同步频率设置"><a href="#13-1-6-AOF-同步频率设置" class="headerlink" title="13. 1. 6. AOF 同步频率设置"></a>13. 1. 6. AOF 同步频率设置</h4><p>appendfsyncalways</p>
<p>始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</p>
<p>appendfsynceverysec</p>
<p>每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</p>
<p>appendfsyncno</p>
<p>redis不主动进行同步，把同步时机交给操作系统。</p>
<h4 id="13-1-7-Rewrite-压缩"><a href="#13-1-7-Rewrite-压缩" class="headerlink" title="13. 1. 7. Rewrite 压缩"></a>13. 1. 7. Rewrite 压缩</h4><p>1 是什么：</p>
<p>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当<br>AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留<br>可以恢复数据的最小指令集.可以使用命令 bgrewriteaof</p>
<p>2 重写原理，如何实现重写</p>
<p>AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件<br>最后再rename)，redis 4. 0 版本后的重写，是指上就是把 rdb的快照，以二级制的形<br>式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作。</p>
<p>no-appendfsync-on-rewrite：</p>
<p>如果no-appendfsync-on-rewrite&#x3D;yes,不写入 aof文件只写入缓存，用户请求不会阻<br>塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高<br>性能）</p>
<p>如果no-appendfsync-on-rewrite&#x3D;no, 还是会把数据往磁盘里刷，但是遇到重<br>写操作，可能会发生阻塞。（数据安全，但是性能降低）</p>
<p>触发机制，何时重写</p>
<p>Redis会记录上次重写时的AOF大小，默认配置是当 AOF文件大小是上次 rewrite后<br>大小的一倍且文件大于 64 M时触发</p>
<p>重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，<br>因此设定Redis要满足一定条件才会进行重写。</p>
<p>auto-aof-rewrite-percentage：设置重写的基准值，文件达到 100 %时开始重写（文件<br>是原来重写后文件的 2 倍时触发）</p>
<p>auto-aof-rewrite-min-size：设置重写的基准值，最小文件 64 MB。达到这个值开始重<br>写。</p>
<p>例如：文件达到 70 MB开始重写，降到 50 MB，下次什么时候开始重写？ 100 MB</p>
<p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size,</p>
<p>如果Redis的AOF当前大小&gt;&#x3D;base_size+base_size* 100 %(默认)且当前大<br>小&gt;&#x3D; 64 mb(默认)的情况下，Redis会对 AOF进行重写。</p>
<p>3 、重写流程</p>
<p>（ 1 ）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果<br>有，则等待该命令结束后再继续执行。</p>
<p>（ 2 ）主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p>
<p>（ 3 ）子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓<br>冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间<br>的新的数据修改动作不会丢失。</p>
<p>（ 4 ） 1 ).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。 2 ).主<br>进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p>
<p>（ 5 ）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p>
<h4 id="13-1-8-优势"><a href="#13-1-8-优势" class="headerlink" title="13. 1. 8. 优势"></a>13. 1. 8. 优势</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 备份机制更稳健，丢失数据概率更低。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 可读的日志文本，通过操作AOF稳健，可以处理误操作。</span><br></pre></td></tr></table></figure>
<h4 id="13-1-9-劣势"><a href="#13-1-9-劣势" class="headerlink" title="13. 1. 9. 劣势"></a>13. 1. 9. 劣势</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 比起RDB占用更多的磁盘空间。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 恢复备份速度要慢。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 每次读写都同步的话，有一定的性能压力。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 存在个别Bug，造成恢复不能。</span><br></pre></td></tr></table></figure>

<h4 id="13-1-10-小总结"><a href="#13-1-10-小总结" class="headerlink" title="13. 1. 10. 小总结"></a>13. 1. 10. 小总结</h4><h4 id="13-2-总结-Whichone"><a href="#13-2-总结-Whichone" class="headerlink" title="13. 2. 总结 (Whichone)"></a>13. 2. 总结 (Whichone)</h4><h4 id="13-2-1-用哪个好"><a href="#13-2-1-用哪个好" class="headerlink" title="13. 2. 1. 用哪个好"></a>13. 2. 1. 用哪个好</h4><p>官方推荐两个都启用。</p>
<p>如果对数据不敏感，可以选单独用RDB。</p>
<p>不建议单独用AOF，因为可能会出现Bug。</p>
<p>如果只是做纯内存缓存，可以都不用。</p>
<h4 id="13-2-2-官网建议"><a href="#13-2-2-官网建议" class="headerlink" title="13. 2. 2. 官网建议"></a>13. 2. 2. 官网建议</h4><p> RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</p>
<p> AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些<br>命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.</p>
<p> Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</p>
<p> 只做缓存：如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何<br>持久化方式.</p>
<p> 同时开启两种持久化方式</p>
<p> 在这种情况下,当 redis重启的时候会优先载入 AOF文件来恢复原始的数据,因为<br>在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整.</p>
<p> RDB的数据不实时，同时使用两者时服务器重启也只会找 AOF文件。那要不要只<br>使用AOF呢？</p>
<p> 建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份)，快速重<br>启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。</p>
<p> 性能建议</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为 RDB文件只用作后备用途，建议只在Slave上持久化 RDB文件，而且只要^15</span><br><span class="line">分钟备份一次就够了，只保留 save 9001 这条规则。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果使用 AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简</span><br><span class="line">单只 load自己的AOF文件就可以了。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代价,一是带来了持续的 IO，二是 AOFrewrite的最后将rewrite过程中产生的新数据</span><br><span class="line">写到新文件造成的阻塞几乎是不可避免的。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只要硬盘许可，应该尽量减少 AOFrewrite的频率，AOF重写的基础大小默认值</span><br><span class="line">64 M太小了，可以设到 5 G以上。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认超过原大小 100 %大小时重写可以改到适当的数值。</span><br></pre></td></tr></table></figure>
<h2 id="14-Redis-主从复制"><a href="#14-Redis-主从复制" class="headerlink" title="14. Redis_主从复制"></a>14. Redis_主从复制</h2><h4 id="14-1-是什么"><a href="#14-1-是什么" class="headerlink" title="14. 1. 是什么"></a>14. 1. 是什么</h4><p>主机数据更新后根据配置和策略，自动同步到备机的 master&#x2F;slaver机制， <strong>Master</strong> 以</p>
<p>写为主， <strong>Slave</strong> 以读为主</p>
<h4 id="14-2-能干嘛"><a href="#14-2-能干嘛" class="headerlink" title="14. 2. 能干嘛"></a>14. 2. 能干嘛</h4><p> 读写分离，性能扩展</p>
<p> 容灾快速恢复</p>
<h4 id="14-3-怎么玩：主从复制"><a href="#14-3-怎么玩：主从复制" class="headerlink" title="14. 3. 怎么玩：主从复制"></a>14. 3. 怎么玩：主从复制</h4><p>拷贝多个redis.conf文件include(写绝对路径)</p>
<p>开启daemonizeyes</p>
<p>Pid文件名字pidfile</p>
<p>指定端口port</p>
<p>Log文件名字</p>
<p>dump.rdb名字 dbfilename</p>
<p>Appendonly关掉或者换名字</p>
<h4 id="14-3-1-新建-redis-6379-conf，填写以下内容"><a href="#14-3-1-新建-redis-6379-conf，填写以下内容" class="headerlink" title="14. 3. 1. 新建 redis 6379 .conf，填写以下内容"></a>14. 3. 1. 新建 redis 6379 .conf，填写以下内容</h4><p>include&#x2F;myredis&#x2F;redis.conf</p>
<p>pidfile&#x2F;var&#x2F;run&#x2F;redis_ 6379 .pid</p>
<p>port 6379</p>
<p>dbfilenamedump 6379 .rdb</p>
<h4 id="14-3-2-新建-redis-6380-conf，填写以下内容"><a href="#14-3-2-新建-redis-6380-conf，填写以下内容" class="headerlink" title="14. 3. 2. 新建 redis 6380 .conf，填写以下内容"></a>14. 3. 2. 新建 redis 6380 .conf，填写以下内容</h4><h4 id="14-3-3-新建-redis-6381-conf，填写以下内容"><a href="#14-3-3-新建-redis-6381-conf，填写以下内容" class="headerlink" title="14. 3. 3. 新建 redis 6381 .conf，填写以下内容"></a>14. 3. 3. 新建 redis 6381 .conf，填写以下内容</h4><p>slave-priority 10</p>
<p>设置从机的优先级，值越小，优先级越高，用于选举主机时使用。默认 100</p>
<h4 id="14-3-4-启动三台-redis-服务器"><a href="#14-3-4-启动三台-redis-服务器" class="headerlink" title="14. 3. 4. 启动三台 redis 服务器"></a>14. 3. 4. 启动三台 redis 服务器</h4><h4 id="14-3-5-查看系统进程，看看三台服务器是否启动"><a href="#14-3-5-查看系统进程，看看三台服务器是否启动" class="headerlink" title="14. 3. 5. 查看系统进程，看看三台服务器是否启动"></a>14. 3. 5. 查看系统进程，看看三台服务器是否启动</h4><h4 id="14-3-6-查看三台主机运行情况"><a href="#14-3-6-查看三台主机运行情况" class="headerlink" title="14. 3. 6. 查看三台主机运行情况"></a>14. 3. 6. 查看三台主机运行情况</h4><p>inforeplication<br>打印主从复制的相关信息</p>
<h4 id="14-3-7-配从-库-不配主-库"><a href="#14-3-7-配从-库-不配主-库" class="headerlink" title="14. 3. 7. 配从(库 ) 不配主 ( 库 )"></a>14. 3. 7. 配从(库 ) 不配主 ( 库 )</h4><p>slaveof <ip><port></p>
<p>成为某个实例的从服务器</p>
<p>1 、在 6380 和 6381 上执行:slaveof 127. 0. 0. 16379</p>
<p>2 、在主机上写，在从机上可以读取数据</p>
<p>在从机上写数据报错</p>
<p>3 、主机挂掉，重启就行，一切如初</p>
<p>4 、从机重启需重设：slaveof 127. 0. 0. 16379</p>
<p>可以将配置增加到文件中。永久生效。</p>
<h4 id="14-4-常用-3-招"><a href="#14-4-常用-3-招" class="headerlink" title="14. 4. 常用 3 招"></a>14. 4. 常用 3 招</h4><h4 id="14-4-1-一主二仆"><a href="#14-4-1-一主二仆" class="headerlink" title="14. 4. 1. 一主二仆"></a>14. 4. 1. 一主二仆</h4><p>切入点问题？slave 1 、slave 2 是从头开始复制还是从切入点开始复制?比如从k 4 进来，<br>那之前的k 1 ,k 2 ,k 3 是否也可以复制？</p>
<p>从机是否可以写？set可否？</p>
<p>主机shutdown后情况如何？从机是上位还是原地待命？</p>
<p>主机又回来了后，主机新增记录，从机还能否顺利复制？</p>
<p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p>
<h4 id="14-4-2-薪火相传"><a href="#14-4-2-薪火相传" class="headerlink" title="14. 4. 2. 薪火相传"></a>14. 4. 2. 薪火相传</h4><p>上一个Slave可以是下一个 slave的Master，Slave同样可以接收其他slaves的连接和<br>同步请求，那么该slave作为了链条中下一个的 master,可以有效减轻 master的写压<br>力,去中心化降低风险。</p>
<p>用slaveof <ip><port></p>
<p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p>
<p>风险是一旦某个slave宕机，后面的 slave都没法备份</p>
<p>主机挂了，从机还是从机，无法写数据了</p>
<h4 id="14-4-3-反客为主"><a href="#14-4-3-反客为主" class="headerlink" title="14. 4. 3. 反客为主"></a>14. 4. 3. 反客为主</h4><p>当一个master宕机后，后面的 slave可以立刻升为 master，其后面的 slave不用做任<br>何修改。</p>
<p>用slaveof noone 将从机变为主机。</p>
<h4 id="14-5-复制原理"><a href="#14-5-复制原理" class="headerlink" title="14. 5. 复制原理"></a>14. 5. 复制原理</h4><p> Slave启动成功连接到 master后会发送一个sync命令</p>
<p> Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命<br>令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次<br>完全同步</p>
<p> 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
<p> 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步</p>
<p> 但是只要是重新连接master,一次完全同步（全量复制)将被自动执行</p>
<h4 id="14-6-哨兵模式-sentinel"><a href="#14-6-哨兵模式-sentinel" class="headerlink" title="14. 6. 哨兵模式 (sentinel)"></a>14. 6. 哨兵模式 (sentinel)</h4><h4 id="14-6-1-是什么"><a href="#14-6-1-是什么" class="headerlink" title="14. 6. 1. 是什么"></a>14. 6. 1. 是什么</h4><p>反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库<br>转换为主库</p>
<h4 id="14-6-2-怎么玩-使用步骤"><a href="#14-6-2-怎么玩-使用步骤" class="headerlink" title="14. 6. 2. 怎么玩(使用步骤 )"></a>14. 6. 2. 怎么玩(使用步骤 )</h4><h5 id="14-6-2-1-调整为一主二仆模式，-6379-带着-6380-、-6381"><a href="#14-6-2-1-调整为一主二仆模式，-6379-带着-6380-、-6381" class="headerlink" title="14. 6. 2. 1. 调整为一主二仆模式， 6379 带着 6380 、 6381"></a>14. 6. 2. 1. 调整为一主二仆模式， 6379 带着 6380 、 6381</h5><h5 id="14-6-2-2-自定义的-myredis-目录下新建-sentinel-conf-文件，名"><a href="#14-6-2-2-自定义的-myredis-目录下新建-sentinel-conf-文件，名" class="headerlink" title="14. 6. 2. 2. 自定义的 &#x2F;myredis 目录下新建 sentinel.conf 文件，名"></a>14. 6. 2. 2. 自定义的 &#x2F;myredis 目录下新建 sentinel.conf 文件，名</h5><h5 id="字绝不能错"><a href="#字绝不能错" class="headerlink" title="字绝不能错"></a>字绝不能错</h5><h5 id="14-6-2-3-配置哨兵-填写内容"><a href="#14-6-2-3-配置哨兵-填写内容" class="headerlink" title="14. 6. 2. 3. 配置哨兵 , 填写内容"></a>14. 6. 2. 3. 配置哨兵 , 填写内容</h5><p>sentinelmonitormymaster 127. 0. 0. 163791</p>
<p>其中 mymaster为监控对象起的服务器名称， 1 为至少有多少个哨兵同意迁移的数量。</p>
<h5 id="14-6-2-4-启动哨兵"><a href="#14-6-2-4-启动哨兵" class="headerlink" title="14. 6. 2. 4. 启动哨兵"></a>14. 6. 2. 4. 启动哨兵</h5><p>&#x2F;usr&#x2F;local&#x2F;bin</p>
<p>redis做压测可以用自带的redis-benchmark工具</p>
<p>执行redis-sentinel &#x2F;myredis&#x2F;sentinel.conf</p>
<h5 id="14-6-2-5-当主机挂掉，从机选举中产生新的主机"><a href="#14-6-2-5-当主机挂掉，从机选举中产生新的主机" class="headerlink" title="14. 6. 2. 5. 当主机挂掉，从机选举中产生新的主机"></a>14. 6. 2. 5. 当主机挂掉，从机选举中产生新的主机</h5><p>(大概 10 秒左右可以看到哨兵窗口日志，切换了新的主机)</p>
<p>哪个从机会被选举为主机呢？根据优先级别：slave-priority</p>
<p>原主机重启后会变为从机。</p>
<h5 id="14-6-2-6-复制延时"><a href="#14-6-2-6-复制延时" class="headerlink" title="14. 6. 2. 6. 复制延时"></a>14. 6. 2. 6. 复制延时</h5><p>由于所有的写操作都是先在Master上操作，然后同步更新到 Slave上，所以从<br>Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<br>Slave机器数量的增加也会使这个问题更加严重。</p>
<h4 id="14-6-3-故障恢复"><a href="#14-6-3-故障恢复" class="headerlink" title="14. 6. 3. 故障恢复"></a>14. 6. 3. 故障恢复</h4><p>优先级在redis.conf中默认：slave-priority 100 ，值越小优先级越高</p>
<p>偏移量是指获得原主机数据最全的</p>
<p>每个redis实例启动后都会随机生成一个 40 位的runid</p>
<h4 id="14-6-4-主从复制"><a href="#14-6-4-主从复制" class="headerlink" title="14. 6. 4. 主从复制"></a>14. 6. 4. 主从复制</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privatestaticJedisSentinelPooljedisSentinelPool=null;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicstatic JedisgetJedisFromSentinel()&#123;</span><br><span class="line">if(jedisSentinelPool==null)&#123;</span><br><span class="line">Set&lt;String&gt;sentinelSet=newHashSet&lt;&gt;();</span><br><span class="line">sentinelSet.add(&quot; 192. 168. 11. 103 : 26379 &quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JedisPoolConfigjedisPoolConfig=newJedisPoolConfig();</span><br><span class="line">jedisPoolConfig.setMaxTotal( 10 );//最大可用连接数</span><br><span class="line">jedisPoolConfig.setMaxIdle( 5 );//最大闲置连接数</span><br><span class="line">jedisPoolConfig.setMinIdle( 5 );//最小闲置连接数</span><br><span class="line">jedisPoolConfig.setBlockWhenExhausted(true);//连接耗尽是否等待</span><br><span class="line">jedisPoolConfig.setMaxWaitMillis( 2000 );//等待时间</span><br><span class="line">jedisPoolConfig.setTestOnBorrow(true);//取连接的时候进行一下测试pingpong</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jedisSentinelPool=newJedisSentinelPool(&quot;mymaster&quot;,sentinelSet,jedisPoolConfig);</span><br><span class="line">returnjedisSentinelPool.getResource();</span><br><span class="line">&#125;else&#123;</span><br><span class="line">returnjedisSentinelPool.getResource();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-Redis-集群"><a href="#15-Redis-集群" class="headerlink" title="15. Redis 集群"></a>15. Redis 集群</h2><h4 id="15-1-问题"><a href="#15-1-问题" class="headerlink" title="15. 1. 问题"></a>15. 1. 问题</h4><p>容量不够，redis如何进行扩容？</p>
<p>并发写操作，redis如何分摊？</p>
<p>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置<br>需要修改对应的主机地址、端口等信息。</p>
<p>之前通过代理主机来解决，但是redis 3. 0 中提供了解决方案。就是无中心化集群配置。</p>
<h4 id="15-2-什么是集群"><a href="#15-2-什么是集群" class="headerlink" title="15. 2. 什么是集群"></a>15. 2. 什么是集群</h4><p>Redis集群实现了对 Redis的水平扩容，即启动 N个redis节点，将整个数据库分布存<br>储在这N个节点中，每个节点存储总数据的 1 &#x2F;N。</p>
<p>Redis集群通过分区（partition）来提供一定程度的可用性（availability）：即使集群<br>中有一部分节点失效或者无法进行通讯，集群也可以继续处理命令请求。</p>
<h4 id="15-3-删除持久化数据"><a href="#15-3-删除持久化数据" class="headerlink" title="15. 3. 删除持久化数据"></a>15. 3. 删除持久化数据</h4><p>将rdb,aof文件都删除掉。</p>
<h4 id="15-4-制作-6-个实例，-6379-6380-6381-6389-6390-6391"><a href="#15-4-制作-6-个实例，-6379-6380-6381-6389-6390-6391" class="headerlink" title="15. 4. 制作 6 个实例， 6379 , 6380 , 6381 , 6389 , 6390 , 6391"></a>15. 4. 制作 6 个实例， 6379 , 6380 , 6381 , 6389 , 6390 , 6391</h4><h4 id="15-4-1-配置基本信息"><a href="#15-4-1-配置基本信息" class="headerlink" title="15. 4. 1. 配置基本信息"></a>15. 4. 1. 配置基本信息</h4><p>开启daemonizeyes</p>
<p>Pid文件名字</p>
<p>指定端口</p>
<p>Log文件名字</p>
<p>Dump.rdb名字</p>
<p>Appendonly关掉或者换名字</p>
<h4 id="15-4-2-rediscluster-配置修改"><a href="#15-4-2-rediscluster-配置修改" class="headerlink" title="15. 4. 2. rediscluster 配置修改"></a>15. 4. 2. rediscluster 配置修改</h4><p>cluster-enabledyes 打开集群模式</p>
<p>cluster-config-filenodes- 6379 .conf 设定节点配置文件名</p>
<p>cluster-node-timeout 15000 设定节点失联时间，超过该时间（毫秒），集群自动进<br>行主从切换。</p>
<p>include&#x2F;home&#x2F;bigdata&#x2F;redis.conf</p>
<p>port 6379</p>
<p>pidfile”&#x2F;var&#x2F;run&#x2F;redis_ 6379 .pid”</p>
<p>dbfilename”dump 6379 .rdb”</p>
<p>dir”&#x2F;home&#x2F;bigdata&#x2F;redis_cluster”</p>
<p>logfile”&#x2F;home&#x2F;bigdata&#x2F;redis_cluster&#x2F;redis_err_ 6379 .log”</p>
<p>cluster-enabledyes</p>
<p>cluster-config-filenodes- 6379 .conf</p>
<p>cluster-node-timeout 15000</p>
<h4 id="15-4-3-修改好-redis-6379-conf-文件，拷贝多个-redis-conf"><a href="#15-4-3-修改好-redis-6379-conf-文件，拷贝多个-redis-conf" class="headerlink" title="15. 4. 3. 修改好 redis 6379 .conf 文件，拷贝多个 redis.conf"></a>15. 4. 3. 修改好 redis 6379 .conf 文件，拷贝多个 redis.conf</h4><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><h4 id="15-4-4-使用查找替换修改另外-5-个文件"><a href="#15-4-4-使用查找替换修改另外-5-个文件" class="headerlink" title="15. 4. 4. 使用查找替换修改另外 5 个文件"></a>15. 4. 4. 使用查找替换修改另外 5 个文件</h4><p>例如：:%s&#x2F; 6379 &#x2F; 6380</p>
<h4 id="15-4-5-启动-6-个-redis-服务"><a href="#15-4-5-启动-6-个-redis-服务" class="headerlink" title="15. 4. 5. 启动 6 个 redis 服务"></a>15. 4. 5. 启动 6 个 redis 服务</h4><h4 id="15-5-将六个节点合成一个集群"><a href="#15-5-将六个节点合成一个集群" class="headerlink" title="15. 5. 将六个节点合成一个集群"></a>15. 5. 将六个节点合成一个集群</h4><p>组合之前，请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常。</p>
<p> 合体：</p>
<p>cd &#x2F;opt&#x2F;redis- 6. 2. 1 &#x2F;src</p>
<p>redis-cli–clustercreate–cluster-replicas 1192. 168. 11. 101 : 6379<br>192. 168. 11. 101 : 6380192. 168. 11. 101 : 6381192. 168. 11. 101 : 6389<br>192. 168. 11. 101 : 6390192. 168. 11. 101 : 6391</p>
<p>此处不要用 127. 0. 0. 1 ，请用真实IP地址</p>
<ul>
<li>-replicas 1 采用最简单的方式配置集群，一台主机，一台从机，正好三组。</li>
</ul>
<p> 普通方式登录</p>
<p>可能直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，应该以集群<br>方式登录。</p>
<h4 id="15-6-c-采用集群策略连接，设置数据会自动切换到相应的"><a href="#15-6-c-采用集群策略连接，设置数据会自动切换到相应的" class="headerlink" title="15. 6. - c 采用集群策略连接，设置数据会自动切换到相应的"></a>15. 6. - c 采用集群策略连接，设置数据会自动切换到相应的</h4><h4 id="写主机"><a href="#写主机" class="headerlink" title="写主机"></a>写主机</h4><h4 id="15-7-通过-cluster-nodes-命令查看集群信息"><a href="#15-7-通过-cluster-nodes-命令查看集群信息" class="headerlink" title="15. 7. 通过 cluster nodes 命令查看集群信息"></a>15. 7. 通过 cluster nodes 命令查看集群信息</h4><h4 id="15-8-redis-cluster-如何分配这六个节点"><a href="#15-8-redis-cluster-如何分配这六个节点" class="headerlink" title="15. 8. redis cluster 如何分配这六个节点?"></a>15. 8. redis cluster 如何分配这六个节点?</h4><p>一个集群至少要有三个主节点。</p>
<p>选项–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点。</p>
<p>分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP<br>地址上。</p>
<h4 id="15-9-什么是-slots"><a href="#15-9-什么是-slots" class="headerlink" title="15. 9. 什么是 slots"></a>15. 9. 什么是 slots</h4><p>[OK]Allnodesagreeaboutslotsconfiguration.</p>
<blockquote>
<blockquote>
<blockquote>
<p>Checkforopenslots…<br>Checkslotscoverage…<br>[OK]All 16384 slotscovered.<br>一个Redis集群包含 16384 个插槽（hashslot），数据库中的每个键都属于这 16384<br>个插槽的其中一个，</p>
</blockquote>
</blockquote>
</blockquote>
<p>集群使用公式CRC 16 (key)% 16384 来计算键key属于哪个槽，其中CRC 16 (key)语<br>句用于计算键key的CRC 16 校验和。</p>
<p>集群中的每个节点负责处理一部分插槽。举个例子，如果一个集群可以有主节点，<br>其中：</p>
<p>节点A负责处理 0 号至 5460 号插槽。</p>
<p>节点B负责处理 5461 号至 10922 号插槽。</p>
<p>节点C负责处理 10923 号至 16383 号插槽。</p>
<h4 id="15-10-在集群中录入值"><a href="#15-10-在集群中录入值" class="headerlink" title="15. 10. 在集群中录入值"></a>15. 10. 在集群中录入值</h4><p>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽，如果不是<br>该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p>
<p>redis-cli客户端提供了–c参数实现自动重定向。</p>
<p>如redis-cli -c–p 6379 登入后，再录入、查询键值对可以自动重定向。</p>
<p>不在一个slot下的键值，是不能使用mget,mset等多键操作。</p>
<p>可以通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去。</p>
<h4 id="15-11-查询集群中的值"><a href="#15-11-查询集群中的值" class="headerlink" title="15. 11. 查询集群中的值"></a>15. 11. 查询集群中的值</h4><p>CLUSTERGETKEYSINSLOT<slot><count>返回count个slot槽中的键。</p>
<h4 id="15-12-故障恢复"><a href="#15-12-故障恢复" class="headerlink" title="15. 12. 故障恢复"></a>15. 12. 故障恢复</h4><p>如果主节点下线？从节点能否自动升为主节点？注意： <strong>15</strong> 秒超时</p>
<p>主节点恢复后，主从关系会如何？主节点回来变成从机。</p>
<p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage为yes，那么，整个<br>集群都挂掉</p>
<p>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage为no，那么，该插<br>槽数据全都不能使用，也无法存储。</p>
<p>redis.conf中的参数 cluster-require-full-coverage</p>
<h4 id="15-13-集群的-Jedis-开发"><a href="#15-13-集群的-Jedis-开发" class="headerlink" title="15. 13. 集群的 Jedis 开发"></a>15. 13. 集群的 Jedis 开发</h4><p>即使连接的不是主机，集群会自动切换主机存储。主机写，从机读。</p>
<p>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">publicclassJedisClusterTest&#123;</span><br><span class="line">publicstaticvoidmain(String[]args)&#123;</span><br><span class="line">Set&lt;HostAndPort&gt;set=newHashSet&lt;HostAndPort&gt;();</span><br><span class="line">set.add(newHostAndPort(&quot; 192. 168. 31. 211 &quot;, 6379 ));</span><br><span class="line">JedisClusterjedisCluster=newJedisCluster(set);</span><br><span class="line">jedisCluster.set(&quot;k 1 &quot;,&quot;v 1 &quot;);</span><br><span class="line">System.out.println(jedisCluster.get(&quot;k 1 &quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-14-Redis-集群提供了以下好处"><a href="#15-14-Redis-集群提供了以下好处" class="headerlink" title="15. 14. Redis 集群提供了以下好处"></a>15. 14. Redis 集群提供了以下好处</h4><p>实现扩容</p>
<p>分摊压力</p>
<p>无中心配置相对简单</p>
<h4 id="15-15-Redis-集群的不足"><a href="#15-15-Redis-集群的不足" class="headerlink" title="15. 15. Redis 集群的不足"></a>15. 15. Redis 集群的不足</h4><p>多键操作是不被支持的</p>
<p>多键的 Redis事务是不被支持的。lua脚本不被支持</p>
<p>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分<br>片的方案想要迁移至rediscluster，需要整体迁移而不是逐步过渡，复杂度较大。</p>
<h2 id="16-Redis-应用问题解决"><a href="#16-Redis-应用问题解决" class="headerlink" title="16. Redis 应用问题解决"></a>16. Redis 应用问题解决</h2><h4 id="16-1-缓存穿透"><a href="#16-1-缓存穿透" class="headerlink" title="16. 1. 缓存穿透"></a>16. 1. 缓存穿透</h4><h4 id="16-1-1-问题描述"><a href="#16-1-1-问题描述" class="headerlink" title="16. 1. 1. 问题描述"></a>16. 1. 1. 问题描述</h4><p>key对应的数据在数据源并不存在，每次针对此 key的请求从缓存获取不到，请<br>求都会压到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，<br>不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>
<h4 id="16-1-2-解决方案"><a href="#16-1-2-解决方案" class="headerlink" title="16. 1. 2. 解决方案"></a>16. 1. 2. 解决方案</h4><p>一个一定不存在缓存及查询不到的数据，由于缓存是不命中时被动写的，并且出<br>于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每<br>次请求都要到存储层去查询，失去了缓存的意义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决方案：</span><br><span class="line">（ 1 ） 对空值缓存：如果一个查询返回的数据为空（不管是数据是否不存在），我</span><br><span class="line">们仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最</span><br><span class="line">长不超过五分钟</span><br><span class="line">（ 2 ） 设置可访问的名单（白名单）：</span><br><span class="line">使用 bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移</span><br><span class="line">量，每次访问和bitmap里面的id进行比较，如果访问 id不在bitmaps里</span><br><span class="line">面，进行拦截，不允许访问。</span><br><span class="line">（ 3 ） 采用布隆过滤器：(布隆过滤器（BloomFilter）是 1970 年由布隆提出的。</span><br><span class="line">它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函</span><br><span class="line">数）。</span><br><span class="line">布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效</span><br><span class="line">率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困</span><br><span class="line">难。)</span><br><span class="line">将所有可能存在的数据哈希到一个足够大的 bitmaps中，一个一定不存在</span><br><span class="line">的数据会被这个 bitmaps拦截掉，从而避免了对底层存储系统的查询压</span><br><span class="line">力。</span><br><span class="line">（ 4 ） 进行实时监控：当发现Redis的命中率开始急速降低，需要排查访问对象和</span><br><span class="line">访问的数据，和运维人员配合，可以设置黑名单限制服务</span><br></pre></td></tr></table></figure>
<h4 id="16-2-缓存击穿"><a href="#16-2-缓存击穿" class="headerlink" title="16. 2. 缓存击穿"></a>16. 2. 缓存击穿</h4><h4 id="16-2-1-问题描述"><a href="#16-2-1-问题描述" class="headerlink" title="16. 2. 1. 问题描述"></a>16. 2. 1. 问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求<br>发现缓存过期一般都会从后端 DB加载数据并回设到缓存，这个时候大并发的请求可<br>能会瞬间把后端DB压垮。</p>
<h4 id="16-2-2-解决方案"><a href="#16-2-2-解决方案" class="headerlink" title="16. 2. 2. 解决方案"></a>16. 2. 2. 解决方案</h4><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时<br>候，需要考虑一个问题：缓存被“击穿”的问题。<br>解决问题：<br>（ <strong>1</strong> ）预先设置热门数据：在 redis高峰访问之前，把一些热门数据提前存入到<br>redis里面，加大这些热门数据key的时长<br>（ <strong>2</strong> ）实时调整：现场监控哪些数据热门，实时调整key的过期时长<br>（ <strong>3</strong> ）使用锁：<br>（ 1 ） 就是在缓存失效的时候（判断拿出来的值为空），不是立即去loaddb。<br>（ 2 ） 先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）<br>去set一个 mutexkey<br>（ 3 ） 当操作返回成功时，再进行 loaddb的操作，并回设缓存,最后删除<br>mutexkey；<br>（ 4 ） 当操作返回失败，证明有线程在 loaddb，当前线程睡眠一段时间再重试<br>整个get缓存的方法。</p>
<h4 id="16-3-缓存雪崩"><a href="#16-3-缓存雪崩" class="headerlink" title="16. 3. 缓存雪崩"></a>16. 3. 缓存雪崩</h4><h4 id="16-3-1-问题描述"><a href="#16-3-1-问题描述" class="headerlink" title="16. 3. 1. 问题描述"></a>16. 3. 1. 问题描述</h4><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求<br>发现缓存过期一般都会从后端 DB加载数据并回设到缓存，这个时候大并发的请求可<br>能会瞬间把后端DB压垮。<br>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key</p>
<p>正常访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓存失效瞬间</span><br></pre></td></tr></table></figure>

<h4 id="16-3-2-解决方案"><a href="#16-3-2-解决方案" class="headerlink" title="16. 3. 2. 解决方案"></a>16. 3. 2. 解决方案</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">缓存失效时的雪崩效应对底层系统的冲击非常可怕！</span><br><span class="line">解决方案：</span><br><span class="line">（ 1 ） 构建多级缓存架构：nginx缓存+redis缓存+其他缓存（ehcache等）</span><br><span class="line">（ 2 ） 使用锁或队列：</span><br><span class="line">用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行</span><br><span class="line">读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并</span><br><span class="line">发情况</span><br><span class="line">（ 3 ） 设置过期标志更新缓存：</span><br><span class="line">记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程</span><br><span class="line">在后台去更新实际key的缓存。</span><br><span class="line">（ 4 ） 将缓存失效时间分散开：</span><br><span class="line">比如我们可以在原有的失效时间基础上增加一个随机值，比如 1 - 5 分钟随</span><br><span class="line">机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效</span><br><span class="line">的事件。</span><br></pre></td></tr></table></figure>
<h4 id="16-4-分布式锁"><a href="#16-4-分布式锁" class="headerlink" title="16. 4. 分布式锁"></a>16. 4. 分布式锁</h4><h4 id="16-4-1-问题描述"><a href="#16-4-1-问题描述" class="headerlink" title="16. 4. 1. 问题描述"></a>16. 4. 1. 问题描述</h4><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于<br>分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发<br>控制锁策略失效，单纯的JavaAPI并不能提供分布式锁的能力。为了解决这个问题就<br>需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！</p>
<p>分布式锁主流的实现方案：</p>
<p>1 .基于数据库实现分布式锁</p>
<p>2 .基于缓存（Redis等）</p>
<p>3 .基于Zookeeper</p>
<p>每一种分布式锁解决方案都有各自的优缺点：</p>
<p>1 .性能：redis最高</p>
<p>2 .可靠性：zookeeper最高</p>
<p>这里，我们就基于redis实现分布式锁。</p>
<h4 id="16-4-2-解决方案：使用-redis-实现分布式锁"><a href="#16-4-2-解决方案：使用-redis-实现分布式锁" class="headerlink" title="16. 4. 2. 解决方案：使用 redis 实现分布式锁"></a>16. 4. 2. 解决方案：使用 redis 实现分布式锁</h4><p>redis:命令</p>
<p>#setsku: 1 :info“OK”NXPX 10000</p>
<p>EXsecond：设置键的过期时间为second秒。SETkeyvalueEXsecond效果等同于<br>SETEXkeysecondvalue。</p>
<p>PXmillisecond：设置键的过期时间为millisecond毫秒。SETkeyvaluePX<br>millisecond效果等同于PSETEXkeymillisecondvalue。</p>
<p>NX：只在键不存在时，才对键进行设置操作。SETkeyvalueNX效果等同于SETNX<br>keyvalue。</p>
<p>XX：只在键已经存在时，才对键进行设置操作。</p>
<p>1 .多个客户端同时获取锁（setnx）</p>
<p>2 .获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</p>
<p>3 .其他客户端等待重试</p>
<h4 id="16-4-3-编写代码"><a href="#16-4-3-编写代码" class="headerlink" title="16. 4. 3. 编写代码"></a>16. 4. 3. 编写代码</h4><p>Redis:setnum 0</p>
<p>@GetMapping(“testLock”)<br>publicvoidtestLock(){<br>&#x2F;&#x2F; 1 获取锁，setne<br>Booleanlock&#x3D;redisTemplate.opsForValue().setIfAbsent(“lock”,” 111 “);<br>&#x2F;&#x2F; 2 获取锁成功、查询 num的值<br>if(lock){<br>Objectvalue&#x3D;redisTemplate.opsForValue().get(“num”);<br>&#x2F;&#x2F; 2. 1 判断 num为空 return<br>if(StringUtils.isEmpty(value)){<br>return;<br>}<br>&#x2F;&#x2F; 2. 2 有值就转成成 int<br>intnum&#x3D;Integer.parseInt(value+””);<br>&#x2F;&#x2F; 2. 3 把 redis的 num加 1<br>redisTemplate.opsForValue().set(“num”,++num);<br>&#x2F;&#x2F; 2. 4 释放锁，del<br>redisTemplate.delete(“lock”);</p>
<p>}else{<br>&#x2F;&#x2F; 3 获取锁失败、每隔 0. 1 秒再获取<br>try{<br>Thread.sleep( 100 );<br>testLock();<br>}catch(InterruptedExceptione){<br>e.printStackTrace();<br>}<br>}<br>}</p>
<p>重启，服务集群，通过网关压力测试：</p>
<p>ab-n 1000 - c 100 <a href="http://">http:&#x2F;&#x2F;</a> 192. 168. 140. 1 : 8080 &#x2F;test&#x2F;testLock</p>
<p>查看redis中num的值：</p>
<p>基本实现。</p>
<p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放</p>
<p>解决：设置过期时间，自动释放锁。</p>
<h4 id="16-4-4-优化之设置锁的过期时间"><a href="#16-4-4-优化之设置锁的过期时间" class="headerlink" title="16. 4. 4. 优化之设置锁的过期时间"></a>16. 4. 4. 优化之设置锁的过期时间</h4><p>设置过期时间有两种方式：</p>
<p>1 .首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之<br>间出现异常，锁也无法释放）</p>
<p>2 .在set时指定过期时间（推荐）</p>
<p>设置过期时间：</p>
<p>压力测试肯定也没有问题。自行测试</p>
<p>问题：可能会释放其他服务器的锁。</p>
<p>场景：如果业务逻辑的执行时间是 7 s。执行流程如下</p>
<p>1 .index 1 业务逻辑没执行完， 3 秒后锁被自动释放。</p>
<p>2 .index 2 获取到锁，执行业务逻辑， 3 秒后锁被自动释放。</p>
<p>3 .index 3 获取到锁，执行业务逻辑</p>
<p>4 .index 1 业务逻辑执行完成，开始调用del释放锁，这时释放的是index 3 的锁，<br>导致index 3 的业务只执行 1 s就被别人释放。</p>
<p>最终等于没锁的情况。</p>
<p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这<br>个值，判断是否自己的锁</p>
<h4 id="16-4-5-优化之-UUID-防误删"><a href="#16-4-5-优化之-UUID-防误删" class="headerlink" title="16. 4. 5. 优化之 UUID 防误删"></a>16. 4. 5. 优化之 UUID 防误删</h4><p>问题：删除操作缺乏原子性。</p>
<p>场景：</p>
<p>1 .index 1 执行删除时，查询到的 lock值确实和 uuid相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uuid=v 1</span><br><span class="line">set(lock,uuid)；</span><br></pre></td></tr></table></figure>
<p>2 .index 1 执行删除前，lock刚好过期时间已到，被 redis自动释放</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 redis中没有了 lock，没有了锁。</span><br></pre></td></tr></table></figure>
<p>3 .index 2 获取了 lock</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index 2 线程获取到了 cpu的资源，开始执行方法</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uuid=v 2</span><br><span class="line">set(lock,uuid)；</span><br></pre></td></tr></table></figure>
<p>4 .index 1 执行删除，此时会把 index 2 的 lock删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index 1 因为已经在方法中了，所以不需要重新上锁。index 1 有执行的权</span><br></pre></td></tr></table></figure>
<p>限。index 1 已经比较完成了，这个时候，开始执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除的 index 2 的锁！</span><br></pre></td></tr></table></figure>
<h4 id="16-4-6-优化之-LUA-脚本保证删除的原子性"><a href="#16-4-6-优化之-LUA-脚本保证删除的原子性" class="headerlink" title="16. 4. 6. 优化之 LUA 脚本保证删除的原子性"></a>16. 4. 6. 优化之 LUA 脚本保证删除的原子性</h4><p>@GetMapping(“testLockLua”)<br>publicvoidtestLockLua(){<br>&#x2F;&#x2F; 1 声明一个 uuid,将做为一个 value放入我们的 key所对应的值中<br>Stringuuid&#x3D;UUID.randomUUID().toString();<br>&#x2F;&#x2F; 2 定义一个锁：lua脚本可以使用同一把锁，来实现删除！<br>StringskuId&#x3D;” 25 “;&#x2F;&#x2F;访问 skuId为 25 号的商品 100008348542<br>StringlocKey&#x3D;”lock:”+skuId;&#x2F;&#x2F;锁住的是每个商品的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 3 获取锁</span><br><span class="line">Booleanlock=redisTemplate.opsForValue().setIfAbsent(locKey,uuid, 3 ,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F;第一种：lock与过期时间中间不写任何的代码。<br>&#x2F;&#x2F;redisTemplate.expire(“lock”, 10 ,TimeUnit.SECONDS);&#x2F;&#x2F;设置过期时间<br>&#x2F;&#x2F;如果 true<br>if(lock){<br>&#x2F;&#x2F;执行的业务逻辑开始<br>&#x2F;&#x2F;获取缓存中的 num数据<br>Objectvalue&#x3D;redisTemplate.opsForValue().get(“num”);<br>&#x2F;&#x2F;如果是空直接返回<br>if(StringUtils.isEmpty(value)){<br>return;<br>}<br>&#x2F;&#x2F;不是空如果说在这出现了异常！那么delete就删除失败！也就是说锁永远存在！<br>intnum&#x3D;Integer.parseInt(value+””);<br>&#x2F;&#x2F;使 num每次+ 1 放入缓存<br>redisTemplate.opsForValue().set(“num”,String.valueOf(++num));<br>&#x2F;<em>使用 lua脚本来锁</em>&#x2F;<br>&#x2F;&#x2F;定义 lua脚本<br>Stringscript&#x3D;”ifredis.call(‘get’,KEYS[ 1 ])&#x3D;&#x3D;ARGV[ 1 ]thenreturnredis.call(‘del’,KEYS[ 1 ])<br>elsereturn 0 end”;<br>&#x2F;&#x2F;使用 redis执行 lua执行<br>DefaultRedisScript<Long>redisScript&#x3D;newDefaultRedisScript&lt;&gt;();<br>redisScript.setScriptText(script);<br>&#x2F;&#x2F;设置一下返回值类型为 Long<br>&#x2F;&#x2F;因为删除判断的时候，返回的 0 ,给其封装为数据类型。如果不封装那么默认返回<br>String类型，<br>&#x2F;&#x2F;那么返回字符串与 0 会有发生错误。<br>redisScript.setResultType(Long.class);<br>&#x2F;&#x2F;第一个要是 script脚本，第二个需要判断的 key，第三个就是 key所对应的值。</p>
<p>redisTemplate.execute(redisScript,Arrays.asList(locKey),uuid);<br>}else{<br>&#x2F;&#x2F;其他线程等待<br>try{<br>&#x2F;&#x2F;睡眠<br>Thread.sleep( 1000 );<br>&#x2F;&#x2F;睡醒了之后，调用方法。<br>testLockLua();<br>}catch(InterruptedExceptione){<br>e.printStackTrace();<br>}<br>}<br>}</p>
<p>Lua脚本详解：</p>
<p>项目中正确使用：</p>
<p>1 .定义key，key应该是为每个 sku定义的，也就是每个 sku有一把锁。</p>
<p>StringlocKey&#x3D; <strong>“lock:”</strong> +skuId;&#x2F;&#x2F;锁住的是每个商品的数据</p>
<p>Booleanlock&#x3D; <strong>redisTemplate</strong> .opsForValue().setIfAbsent(locKey,uuid, 3 ,TimeUnit. <strong>SECONDS</strong> );</p>
<h4 id="16-4-7-总结"><a href="#16-4-7-总结" class="headerlink" title="16. 4. 7. 总结"></a>16. 4. 7. 总结</h4><p>1 、加锁</p>
<p>&#x2F;&#x2F; 1 .从redis中获取锁,setk 1 v 1 px 20000 nx</p>
<p>Stringuuid&#x3D;UUID.randomUUID().toString();</p>
<p>Booleanlock&#x3D; <strong>this</strong>. <strong>redisTemplate</strong> .opsForValue()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.setIfAbsent( &quot;lock&quot; ,uuid, 2 ,TimeUnit. SECONDS );</span><br></pre></td></tr></table></figure>
<p>2 、使用 lua释放锁</p>
<p>&#x2F;&#x2F; 2 .释放锁del<br>Stringscript&#x3D; <strong>“ifredis.call(‘get’,KEYS[ 1 ])&#x3D;&#x3D;ARGV[ 1 ]thenreturnredis.call(‘del’,</strong></p>
<p><strong>KEYS[ 1 ])elsereturn 0 end”</strong> ;<br>&#x2F;&#x2F;设置lua脚本返回的数据类型<br>DefaultRedisScript<Long>redisScript&#x3D; <strong>new</strong> DefaultRedisScript&lt;&gt;();<br>&#x2F;&#x2F;设置lua脚本返回类型为Long<br>redisScript.setResultType(Long. <strong>class</strong> );</p>
<p>redisScript.setScriptText(script);<br><strong>redisTemplate</strong> .execute(redisScript,Arrays.asList( <strong>“lock”</strong> ),uuid);</p>
<p>3 、重试</p>
<p>Thread.sleep( 500 );</p>
<p>testLock();</p>
<p>为了确保分布式锁可用，我们至少要确保锁的实现同时 <strong>满足以下四个条件</strong> ：</p>
<ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也<br>能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人<br>加的锁给解了。</li>
<li>加锁和解锁必须具有原子性。</li>
</ul>
<h2 id="17-Redis-6-0-新功能"><a href="#17-Redis-6-0-新功能" class="headerlink" title="17. Redis 6. 0 新功能"></a>17. Redis 6. 0 新功能</h2><h4 id="17-1-ACL"><a href="#17-1-ACL" class="headerlink" title="17. 1 .ACL"></a>17. 1 .ACL</h4><h4 id="17-1-1-简介"><a href="#17-1-1-简介" class="headerlink" title="17. 1. 1. 简介"></a>17. 1. 1. 简介</h4><p>RedisACL是 AccessControlList（访问控制列表）的缩写，该功能允许根据可<br>以执行的命令和可以访问的键来限制某些连接。<br>在 Redis 5 版本之前，Redis安全规则只有密码控制还有通过 rename来调整<br>高危命令比如flushdb，KEYS*，shutdown等。Redis 6 则提供 ACL的功能对用户<br>进行更细粒度的权限控制：<br>（ 1 ）接入权限:用户名和密码<br>（ 2 ）可以执行的命令<br>（ 3 ）可以操作的KEY<br>参考官网：<a target="_blank" rel="noopener" href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p>
<h4 id="17-1-2-命令"><a href="#17-1-2-命令" class="headerlink" title="17. 1. 2. 命令"></a>17. 1. 2. 命令</h4><p>1 、使用acllist命令展现用户权限列表<br>（ 1 ）数据说明</p>
<p>2 、使用aclcat命令</p>
<p>（ 1 ）查看添加权限指令类别</p>
<p>（ 2 ）加参数类型名可以查看类型下具体命令</p>
<p>3 、使用aclwhoami命令查看当前用户</p>
<p>4 、使用aclsetuser命令创建和编辑用户 ACL<br>（ 1 ）ACL规则<br>下面是有效 ACL规则的列表。某些规则只是用于激活或删除标志，或对用户 ACL<br>执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连</p>
<p>接在一起。</p>
<p>（ 2 ）通过命令创建新用户默认权限<br>aclsetuseruser 1</p>
<p>在上面的示例中，我根本没有指定任何规则。如果用户不存在，这将使用justcreated<br>的默认属性来创建用户。如果用户已经存在，则上面的命令将不执行任何操作。</p>
<p>（ 3 ）设置有用户名、密码、ACL权限、并启用的用户<br>aclsetuseruser 2 on&gt;password~cached:*+get</p>
<p>( 4 )切换用户，验证权限</p>
<h4 id="ACL规则"><a href="#ACL规则" class="headerlink" title="ACL规则"></a>ACL规则</h4><p>类型 参数 说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启动和禁用用户</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on 激活某用户账号</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">off</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">禁用某用户账号。注意，已验证的连接仍然可以工</span><br><span class="line">作。如果默认用户被标记为off，则新连接将在未进</span><br><span class="line">行身份验证的情况下启动，并要求用户使用AUTH选</span><br><span class="line">项发送AUTH或HELLO，以便以某种方式进行身份验</span><br><span class="line">证。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">权限的添加删除</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+&lt;command&gt; 将指令添加到用户可以调用的指令列表中</span><br></pre></td></tr></table></figure>
<ul>
<li><command> 从用户可执行指令列表移除指令</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+@&lt;category&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加该类别中用户要调用的所有指令，有效类别为</span><br><span class="line">@admin、@set、@sortedset...等，通过调用ACL</span><br><span class="line">CAT命令查看完整列表。特殊类别@all表示所有命</span><br><span class="line">令，包括当前存在于服务器中的命令，以及将来将</span><br><span class="line">通过模块加载的命令。</span><br></pre></td></tr></table></figure>
<ul>
<li>@<actegory> 从用户可调用指令中移除类别<br>allcommands +@all的别名<br>nocommand -@all的别名<br>可操作键的添加<br>或删除 ~<pattern></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加可作为用户可操作的键的模式。例如~*允许所有</span><br><span class="line">的键</span><br></pre></td></tr></table></figure>

<h4 id="17-2-IO-多线程"><a href="#17-2-IO-多线程" class="headerlink" title="17. 2 .IO 多线程"></a>17. 2 .IO 多线程</h4><h4 id="17-2-1-简介"><a href="#17-2-1-简介" class="headerlink" title="17. 2. 1. 简介"></a>17. 2. 1. 简介</h4><p>Redis 6 终于支撑多线程了，告别单线程了吗？<br>IO 多线程其实指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线<br>程。Redis 6 执行命令依然是单线程。</p>
<h4 id="17-2-2-原理架构"><a href="#17-2-2-原理架构" class="headerlink" title="17. 2. 2. 原理架构"></a>17. 2. 2. 原理架构</h4><p>Redis 6 加入多线程,但跟Memcached这种从IO处理到数据访问多线程的实现模式有<br>些差异。Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单<br>线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制key、lua、事务，<br>LPUSH&#x2F;LPOP等等的并发问题。整体的设计大体如下:</p>
<p>另外，多线程IO默认也是不开启的，需要再配置文件中配置</p>
<p>io-threads-do-reads yes</p>
<p>io-threads 4</p>
<h4 id="17-3-工具支持-Cluster"><a href="#17-3-工具支持-Cluster" class="headerlink" title="17. 3. 工具支持 Cluster"></a>17. 3. 工具支持 Cluster</h4><p>之前老版 Redis想要搭集群需要单独安装 ruby环境，Redis 5 将redis-trib.rb的<br>功能集成到redis-cli。另外官方redis-benchmark工具开始支持cluster模式了，通过<br>多线程的方式对多个分片进行压测。</p>
<h4 id="17-4-Redis-新功能持续关注"><a href="#17-4-Redis-新功能持续关注" class="headerlink" title="17. 4 .Redis 新功能持续关注"></a>17. 4 .Redis 新功能持续关注</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Redis 6 新功能还有：</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 、RESP 3 新的Redis通信协议：优化服务端与客户端之间通信</span><br></pre></td></tr></table></figure>
<p>2 、Clientsidecaching客户端缓存：基于RESP 3 协议实现的客户端缓存功能。为<br>了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络<br>交互。</p>
<p>3 、Proxy集群代理模式：Proxy功能，让Cluster拥有像单实例一样的接入方式，<br>降低大家使用cluster的门槛。不过需要注意的是代理不改变Cluster的功能限制，不<br>支持的命令还是不会支持，比如跨slot的多Key操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 、ModulesAPI</span><br></pre></td></tr></table></figure>
<p>Redis 6 中模块API开发进展非常大，因为RedisLabs为了开发复杂的功能，从<br>一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，<br>而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放<br>的平台。</p>
--></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Miller</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/11/27/Redis7/Redis/">http://example.com/2023/11/27/Redis7/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Miller</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/27/MySQL/MySQL%E5%86%85%E5%AD%98/" title="MYSQL内存"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MYSQL内存</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/27/activiti/%E4%BC%9A%E7%AD%BE%E6%88%96%E7%AD%BE/" title="会签或签"><img class="cover" src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">会签或签</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Miller</div><div class="author-info__description">但行前路，不负韶华！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dongxiaopipi"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dongxiaopipi" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">1. NoSQL 数据库简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">1. 1. 技术发展</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E3%80%81%E8%A7%A3%E5%86%B3%E6%80%A7%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9ANoSQL%E3%80%81Java%E7%BA%BF%E7%A8%8B%E3%80%81Hadoop%E3%80%81Nginx%E3%80%81MQ%E3%80%81ElasticSearch"><span class="toc-number">2.0.0.0.1.</span> <span class="toc-text">3 、解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-1-Web-1-0-%E6%97%B6%E4%BB%A3"><span class="toc-number">3.</span> <span class="toc-text">1. 1. 1. Web 1. 0 时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-2-Web-2-0-%E6%97%B6%E4%BB%A3"><span class="toc-number">4.</span> <span class="toc-text">1. 1. 2. Web 2. 0 时代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E8%A7%A3%E5%86%B3-CPU-%E5%8F%8A%E5%86%85%E5%AD%98%E5%8E%8B%E5%8A%9B"><span class="toc-number">4.0.1.</span> <span class="toc-text">1. 1. 3. 解决 CPU 及内存压力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E8%A7%A3%E5%86%B3-IO-%E5%8E%8B%E5%8A%9B"><span class="toc-number">4.0.2.</span> <span class="toc-text">1. 1. 4. 解决 IO 压力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.0.3.</span> <span class="toc-text">1. 2 .NoSQL 数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-number">4.0.4.</span> <span class="toc-text">1. 2. 1. NoSQL 数据库概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-NoSQL-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.0.5.</span> <span class="toc-text">1. 2. 2. NoSQL 适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-NoSQL-%E4%B8%8D%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.0.6.</span> <span class="toc-text">1. 2. 3. NoSQL 不适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-Memcache"><span class="toc-number">4.0.7.</span> <span class="toc-text">1. 2. 4. Memcache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-Redis"><span class="toc-number">4.0.8.</span> <span class="toc-text">1. 2. 5. Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-MongoDB"><span class="toc-number">4.0.9.</span> <span class="toc-text">1. 2. 6. MongoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%89"><span class="toc-number">4.0.10.</span> <span class="toc-text">1. 3. 行式存储数据库（大数据时代）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E8%A1%8C%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.0.11.</span> <span class="toc-text">1. 3. 1. 行式数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.0.12.</span> <span class="toc-text">1. 3. 2. 列式数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-1-Hbase"><span class="toc-number">4.0.12.1.</span> <span class="toc-text">1. 3. 2. 1 .Hbase</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-2-Cassandra-k%C9%99%CB%88saendr%C9%99"><span class="toc-number">4.0.12.2.</span> <span class="toc-text">1. 3. 2. 2 .Cassandra[kəˈsændrə]</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%9B%BE%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">4.0.13.</span> <span class="toc-text">1. 4. 图关系型数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-DB-Engines-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%92%E5%90%8D"><span class="toc-number">4.0.14.</span> <span class="toc-text">1. 5 .DB-Engines 数据库排名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis-%E6%A6%82%E8%BF%B0%E5%AE%89%E8%A3%85"><span class="toc-number">5.</span> <span class="toc-text">2 .Redis 概述安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.0.1.</span> <span class="toc-text">2. 1. 应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E9%85%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%81%9A%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. 1. 1. 配合关系型数据库做高速缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%A4%9A%E6%A0%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="toc-number">5.0.3.</span> <span class="toc-text">2. 1. 2. 多样的数据结构存储持久化数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Redis-%E5%AE%89%E8%A3%85"><span class="toc-number">5.0.4.</span> <span class="toc-text">2. 2 .Redis 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%AE%89%E8%A3%85%E7%89%88%E6%9C%AC"><span class="toc-number">5.0.5.</span> <span class="toc-text">2. 2. 1. 安装版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.0.6.</span> <span class="toc-text">2. 2. 2. 安装步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%EF%BC%9A%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88%E7%9A%84-gcc-%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number">5.0.7.</span> <span class="toc-text">2. 2. 2. 1. 准备工作：下载安装最新版的 gcc 编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#yuminstallcentos-release-sclscl-utils-build"><span class="toc-number">5.0.7.0.1.</span> <span class="toc-text">yuminstallcentos-release-sclscl-utils-build</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-2-%E4%B8%8B%E8%BD%BD-redis-6-2-1-tar-gz-%E6%94%BE-opt-%E7%9B%AE%E5%BD%95"><span class="toc-number">5.0.8.</span> <span class="toc-text">2. 2. 2. 2. 下载 redis- 6. 2. 1 .tar.gz 放&#x2F;opt 目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-3-%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%EF%BC%9Atar-zxvfredis-6-2-1-tar-gz"><span class="toc-number">5.0.9.</span> <span class="toc-text">2. 2. 2. 3. 解压命令：tar-zxvfredis- 6. 2. 1 .tar.gz</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-4-%E8%A7%A3%E5%8E%8B%E5%AE%8C%E6%88%90%E5%90%8E%E8%BF%9B%E5%85%A5%E7%9B%AE%E5%BD%95%EF%BC%9Acdredis-6-2-1"><span class="toc-number">5.0.10.</span> <span class="toc-text">2. 2. 2. 4. 解压完成后进入目录：cdredis- 6. 2. 1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-5-%E5%9C%A8-redis-6-2-1-%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%86%8D%E6%AC%A1%E6%89%A7%E8%A1%8C-make-%E5%91%BD%E4%BB%A4%EF%BC%88%E5%8F%AA"><span class="toc-number">5.0.11.</span> <span class="toc-text">2. 2. 2. 5. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E7%BC%96%E8%AF%91%E5%A5%BD%EF%BC%89"><span class="toc-number">5.0.12.</span> <span class="toc-text">是编译好）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-6-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%87%86%E5%A4%87%E5%A5%BD-C-%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8Cmake-%E4%BC%9A%E6%8A%A5"><span class="toc-number">5.0.13.</span> <span class="toc-text">2. 2. 2. 6. 如果没有准备好 C 语言编译环境，make 会报</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E2%80%94Jemalloc-jemalloc-h%EF%BC%9A%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">5.0.14.</span> <span class="toc-text">错—Jemalloc&#x2F;jemalloc.h：没有那个文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-7-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E8%BF%90%E8%A1%8C-makedistclean"><span class="toc-number">5.0.15.</span> <span class="toc-text">2. 2. 2. 7. 解决方案：运行 makedistclean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-8-%E5%9C%A8-redis-6-2-1-%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%86%8D%E6%AC%A1%E6%89%A7%E8%A1%8C-make-%E5%91%BD%E4%BB%A4%EF%BC%88%E5%8F%AA"><span class="toc-number">5.0.16.</span> <span class="toc-text">2. 2. 2. 8. 在 redis- 6. 2. 1 目录下再次执行 make 命令（只</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E7%BC%96%E8%AF%91%E5%A5%BD%EF%BC%89-1"><span class="toc-number">5.0.17.</span> <span class="toc-text">是编译好）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-9-%E8%B7%B3%E8%BF%87-maketest%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C-makeinstall"><span class="toc-number">5.0.18.</span> <span class="toc-text">2. 2. 2. 9. 跳过 maketest继续执行:makeinstall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%EF%BC%9A-usr-local-bin"><span class="toc-number">5.0.19.</span> <span class="toc-text">2. 2. 3. 安装目录：&#x2F;usr&#x2F;local&#x2F;bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E5%89%8D%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">5.0.20.</span> <span class="toc-text">2. 2. 4. 前台启动（不推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">5.0.21.</span> <span class="toc-text">2. 2. 5. 后台启动（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-1-%E5%A4%87%E4%BB%BD-redis-conf"><span class="toc-number">5.0.21.1.</span> <span class="toc-text">2. 2. 5. 1. 备份 redis.conf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-2-%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%E8%AE%BE%E7%BD%AE-daemonizeno-%E6%94%B9%E6%88%90-yes"><span class="toc-number">5.0.21.2.</span> <span class="toc-text">2. 2. 5. 2. 后台启动设置 daemonizeno 改成 yes</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-3-Redis-%E5%90%AF%E5%8A%A8"><span class="toc-number">5.0.21.3.</span> <span class="toc-text">2. 2. 5. 3 .Redis 启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-4-%E7%94%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BF%E9%97%AE%EF%BC%9A-redis-cli"><span class="toc-number">5.0.21.4.</span> <span class="toc-text">2. 2. 5. 4. 用客户端访问： redis-cli</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-5-%E5%A4%9A%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%8F%AF%E4%BB%A5%EF%BC%9A-redis-cli-p-6379"><span class="toc-number">5.0.21.5.</span> <span class="toc-text">2. 2. 5. 5. 多个端口可以： redis-cli-p 6379</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-6-%E6%B5%8B%E8%AF%95%E9%AA%8C%E8%AF%81%EF%BC%9A-ping"><span class="toc-number">5.0.21.6.</span> <span class="toc-text">2. 2. 5. 6. 测试验证： ping</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-5-7-Redis-%E5%85%B3%E9%97%AD"><span class="toc-number">5.0.21.7.</span> <span class="toc-text">2. 2. 5. 7 .Redis 关闭</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-Redis-%E4%BB%8B%E7%BB%8D%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">5.0.22.</span> <span class="toc-text">2. 2. 6. Redis 介绍相关知识</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">3. 常用五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Redis-%E9%94%AE-key"><span class="toc-number">6.1.</span> <span class="toc-text">3. 1 .Redis 键 (key)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Redis-%E5%AD%97%E7%AC%A6%E4%B8%B2-String"><span class="toc-number">6.1.1.</span> <span class="toc-text">3. 2 .Redis 字符串 (String)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">3. 2. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.3.</span> <span class="toc-text">3. 2. 2. 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.4.</span> <span class="toc-text">3. 2. 3. 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-Redis-%E5%88%97%E8%A1%A8-List"><span class="toc-number">6.1.5.</span> <span class="toc-text">3. 3 .Redis 列表 (List)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.6.</span> <span class="toc-text">3. 3. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.7.</span> <span class="toc-text">3. 3. 2. 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.8.</span> <span class="toc-text">3. 3. 3. 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-Redis-%E9%9B%86%E5%90%88-Set"><span class="toc-number">6.1.9.</span> <span class="toc-text">3. 4 .Redis 集合 (Set)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.10.</span> <span class="toc-text">3. 4. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.11.</span> <span class="toc-text">3. 4. 2. 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.12.</span> <span class="toc-text">3. 4. 3. 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-Redis-%E5%93%88%E5%B8%8C-Hash"><span class="toc-number">6.1.13.</span> <span class="toc-text">3. 5 .Redis 哈希 (Hash)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.14.</span> <span class="toc-text">3. 5. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.15.</span> <span class="toc-text">3. 5. 2. 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.16.</span> <span class="toc-text">3. 5. 3. 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-Redis-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-Zset-sortedset"><span class="toc-number">6.1.17.</span> <span class="toc-text">3. 6 .Redis 有序集合 Zset(sortedset)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.18.</span> <span class="toc-text">3. 6. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">6.1.19.</span> <span class="toc-text">3. 6. 2. 常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.20.</span> <span class="toc-text">3. 6. 3. 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-4-%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%88%E8%B7%B3%E8%A1%A8%EF%BC%89"><span class="toc-number">6.1.21.</span> <span class="toc-text">3. 6. 4. 跳跃表（跳表）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.</span> <span class="toc-text">4. Redis 配置文件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-Units-%E5%8D%95%E4%BD%8D"><span class="toc-number">7.0.1.</span> <span class="toc-text">4. 1 .###Units 单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-INCLUDES-%E5%8C%85%E5%90%AB"><span class="toc-number">7.0.2.</span> <span class="toc-text">4. 2 .###INCLUDES 包含</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE"><span class="toc-number">7.0.3.</span> <span class="toc-text">4. 3 .### 网络相关配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-b-ind"><span class="toc-number">7.0.4.</span> <span class="toc-text">4. 3. 1. b ind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-p-rotected-mode"><span class="toc-number">7.0.5.</span> <span class="toc-text">4. 3. 2. p rotected- mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-P-ort"><span class="toc-number">7.0.6.</span> <span class="toc-text">4. 3. 3. P ort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-t-cp-backlog"><span class="toc-number">7.0.7.</span> <span class="toc-text">4. 3. 4. t cp-backlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-t-imeout"><span class="toc-number">7.0.8.</span> <span class="toc-text">4. 3. 5. t imeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-t-cp-keepalive"><span class="toc-number">7.0.9.</span> <span class="toc-text">4. 3. 6. t cp-keepalive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-GENERAL-%E9%80%9A%E7%94%A8"><span class="toc-number">7.0.10.</span> <span class="toc-text">4. 4 .###GENERAL 通用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-daemonize"><span class="toc-number">7.0.11.</span> <span class="toc-text">4. 4. 1. daemonize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-pidfile"><span class="toc-number">7.0.12.</span> <span class="toc-text">4. 4. 2. pidfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-loglevel"><span class="toc-number">7.0.13.</span> <span class="toc-text">4. 4. 3. loglevel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-logfile"><span class="toc-number">7.0.14.</span> <span class="toc-text">4. 4. 4. logfile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5-d-atabases-16"><span class="toc-number">7.0.15.</span> <span class="toc-text">4. 4. 5. d atabases 16</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-SECURITY-%E5%AE%89%E5%85%A8"><span class="toc-number">7.0.16.</span> <span class="toc-text">4. 5 .###SECURITY 安全</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81"><span class="toc-number">7.0.17.</span> <span class="toc-text">4. 5. 1. 设置密码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-LIMITS-%E9%99%90%E5%88%B6"><span class="toc-number">7.0.18.</span> <span class="toc-text">4. 6 .####LIMITS 限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-m-axclients"><span class="toc-number">7.0.19.</span> <span class="toc-text">4. 6. 1. m axclients</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-m-axmemory"><span class="toc-number">7.0.20.</span> <span class="toc-text">4. 6. 2. m axmemory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-3-m-axmemory-policy"><span class="toc-number">7.0.21.</span> <span class="toc-text">4. 6. 3. m axmemory-policy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-4-m-axmemory-samples"><span class="toc-number">7.0.22.</span> <span class="toc-text">4. 6. 4. m axmemory-samples</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Redis-%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">8.</span> <span class="toc-text">5. Redis 的发布和订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">8.0.1.</span> <span class="toc-text">5. 1. 什么是发布和订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-Redis-%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">8.0.2.</span> <span class="toc-text">5. 2 .Redis 的发布和订阅</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.0.3.</span> <span class="toc-text">5. 3. 发布订阅命令行实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Redis-%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">6. Redis 新数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-Bitmaps"><span class="toc-number">9.0.1.</span> <span class="toc-text">6. 1 .Bitmaps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.0.2.</span> <span class="toc-text">6. 1. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E5%91%BD%E4%BB%A4"><span class="toc-number">9.0.3.</span> <span class="toc-text">6. 1. 2. 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-Bitmaps-%E4%B8%8E-set-%E5%AF%B9%E6%AF%94"><span class="toc-number">9.0.4.</span> <span class="toc-text">6. 1. 3. Bitmaps 与 set 对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%92%8CBitmaps%E5%AD%98%E5%82%A8%E4%B8%80%E5%A4%A9%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E5%AF%B9%E6%AF%94"><span class="toc-number">9.0.5.</span> <span class="toc-text">set和Bitmaps存储一天活跃用户对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%92%8CBitmaps%E5%AD%98%E5%82%A8%E7%8B%AC%E7%AB%8B%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%AF%B9%E6%AF%94"><span class="toc-number">9.0.6.</span> <span class="toc-text">set和Bitmaps存储独立用户空间对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set%E5%92%8CBitmaps%E5%AD%98%E5%82%A8%E4%B8%80%E5%A4%A9%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E5%AF%B9%E6%AF%94%EF%BC%88%E7%8B%AC%E7%AB%8B%E7%94%A8%E6%88%B7%E6%AF%94%E8%BE%83%E5%B0%91%EF%BC%89"><span class="toc-number">9.0.7.</span> <span class="toc-text">set和Bitmaps存储一天活跃用户对比（独立用户比较少）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-HyperLogLog"><span class="toc-number">9.1.</span> <span class="toc-text">6. 2 .HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.1.</span> <span class="toc-text">6. 2. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%91%BD%E4%BB%A4"><span class="toc-number">9.1.2.</span> <span class="toc-text">6. 2. 2. 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-Geospatial"><span class="toc-number">9.1.3.</span> <span class="toc-text">6. 3 .Geospatial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.4.</span> <span class="toc-text">6. 3. 1. 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E5%91%BD%E4%BB%A4"><span class="toc-number">9.1.5.</span> <span class="toc-text">6. 3. 2. 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Redis-Jedis-%E6%B5%8B%E8%AF%95"><span class="toc-number">10.</span> <span class="toc-text">7. Redis_Jedis_测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-Jedis-%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84-jar-%E5%8C%85"><span class="toc-number">10.0.1.</span> <span class="toc-text">7. 1 .Jedis 所需要的 jar 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E8%BF%9E%E6%8E%A5-Redis-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.0.2.</span> <span class="toc-text">7. 2. 连接 Redis 注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-Jedis-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">10.0.3.</span> <span class="toc-text">7. 3 .Jedis 常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-%E5%88%9B%E5%BB%BA%E5%8A%A8%E6%80%81%E7%9A%84%E5%B7%A5%E7%A8%8B"><span class="toc-number">10.0.4.</span> <span class="toc-text">7. 3. 1. 创建动态的工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-%E5%88%9B%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%A8%8B%E5%BA%8F"><span class="toc-number">10.0.5.</span> <span class="toc-text">7. 3. 2. 创建测试程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.0.6.</span> <span class="toc-text">7. 4. 测试相关数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-Jedis-API-Key"><span class="toc-number">10.0.7.</span> <span class="toc-text">7. 4. 1. Jedis-API: Key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-Jedis-API-String"><span class="toc-number">10.0.8.</span> <span class="toc-text">7. 4. 2. Jedis-API: String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-Jedis-API-List"><span class="toc-number">10.0.9.</span> <span class="toc-text">7. 4. 3. Jedis-API: List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-Jedis-API-set"><span class="toc-number">10.0.10.</span> <span class="toc-text">7. 4. 4. Jedis-API: set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-5-Jedis-API-hash"><span class="toc-number">10.0.11.</span> <span class="toc-text">7. 4. 5. Jedis-API: hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-6-Jedis-API-zset"><span class="toc-number">10.0.12.</span> <span class="toc-text">7. 4. 6. Jedis-API: zset</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Redis-Jedis-%E5%AE%9E%E4%BE%8B"><span class="toc-number">11.</span> <span class="toc-text">8. Redis_Jedis_实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AA%E6%89%8B%E6%9C%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD"><span class="toc-number">11.0.1.</span> <span class="toc-text">8. 1. 完成一个手机验证码功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Redis-%E4%B8%8E-SpringBoot-%E6%95%B4%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">9. Redis 与 SpringBoot 整合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E6%95%B4%E5%90%88%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.0.1.</span> <span class="toc-text">9. 1. 整合步骤</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="Mysql主从复制"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mysql主从复制"/></a><div class="content"><a class="title" href="/2023/11/29/MySQL/Mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="Mysql主从复制">Mysql主从复制</a><time datetime="2023-11-29T02:15:37.000Z" title="发表于 2023-11-29 10:15:37">2023-11-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/Docker/" title="Docker"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker"/></a><div class="content"><a class="title" href="/2023/11/27/Docker/" title="Docker">Docker</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/ElasticSearch/" title="ElasticSearch"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ElasticSearch"/></a><div class="content"><a class="title" href="/2023/11/27/ElasticSearch/" title="ElasticSearch">ElasticSearch</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/JDK/" title="JDK1.8新特性"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDK1.8新特性"/></a><div class="content"><a class="title" href="/2023/11/27/JDK/" title="JDK1.8新特性">JDK1.8新特性</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/27/JVM/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/" title="JVM字节码"><img src="https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM字节码"/></a><div class="content"><a class="title" href="/2023/11/27/JVM/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/" title="JVM字节码">JVM字节码</a><time datetime="2023-11-27T14:15:37.000Z" title="发表于 2023-11-27 22:15:37">2023-11-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Miller</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>